{
  "categories": [
    {
      "slug": "ai",
      "name": "Ai",
      "icon": "ðŸ¤–",
      "subcategories": [
        {
          "slug": "general",
          "name": "General",
          "skills": [
            {
              "slug": "{{projectName}}",
              "name": "{{projectName}}",
              "id": "OC-0100",
              "version": "1.0.0",
              "description": "Agent skills for working with {{projectCapitalized}} MinionTypes. Provides CRUD operations, CLI usage, and best practices for AI agents managing {{projectName}} data.",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# {{projectCapitalized}} Agent Skills\n\nSkills for agents operating on the `{{projectName}}` toolbox.\n\n## Prerequisites\n\nInstall the SDK and CLI:\n\n```bash\n# TypeScript\npnpm add {{sdkName}}\n\n# Python\npip install {{pythonPackage}}\n\n# CLI\npnpm add -g {{cliName}}\n```\n\n---\n\n## Using the CLI\n\nThe `{{cliCommand}}` CLI provides basic project info and utilities:\n\n```bash\n# Show project info (SDK name, CLI name, Python package)\n{{cliCommand}} info\n```\n\nUse the CLI as the primary interface for scripted operations. For programmatic access within agent code, use the SDK directly.\n\n---\n\n## Using the SDK\n\n### TypeScript\n\n```ts\nimport { customTypes } from '{{sdkName}}/schemas';\n\n// List all available MinionTypes in this toolbox\nfor (const type of customTypes) {\n  console.log(`${type.icon} ${type.name} (${type.slug})`);\n  console.log(`  ${type.description}`);\n  console.log(`  Fields: ${type.schema.map(f => f.name).join(', ')}`);\n}\n\n// Access a specific type\nconst myType = customTypes.find(t => t.slug === 'YOUR_TYPE_SLUG');\n```\n\n### Python\n\n```python\nfrom {{pythonModule}}.schemas import custom_types\n\n# List all available MinionTypes\nfor t in custom_types:\n    print(f\"{t.icon} {t.name} ({t.slug})\")\n    print(f\"  {t.description}\")\n```\n\n---\n\n## Skill: Create Minion\n\nWhen creating a new Minion of any type in this toolbox:\n\n1. Look up the MinionType from `customTypes` by slug\n2. Validate all required fields are present according to the schema\n3. Set `string` fields to their values, `number` fields to numeric values\n4. Set `select` fields to one of their valid options\n5. Set `boolean` fields to `true` or `false`\n6. Always include a timestamp for any `createdAt` or similar fields (ISO 8601 format)\n\n---\n\n## Skill: Read / Query Minions\n\nWhen reading or searching for Minions:\n\n1. Query by MinionType slug to filter by type\n2. Use field values for secondary filtering\n3. For references (fields ending in `Id`), resolve the linked Minion for full context\n4. Return results in a structured format the calling agent can parse\n\n---\n\n## Skill: Update Minion\n\nWhen updating an existing Minion:\n\n1. Load the current Minion by ID\n2. Validate the update against the MinionType schema\n3. Only modify the fields that need changing â€” preserve existing values\n4. If the type has a `status` field, follow valid status transitions\n5. If the type has an `updatedAt` field, set it to the current timestamp\n6. Log significant field changes for audit if the context requires it\n\n---\n\n## Skill: Delete / Archive Minion\n\nWhen removing a Minion:\n\n1. Prefer soft-delete: set `status` to `\"cancelled\"` or `\"archived\"` if available\n2. Never hard-delete Minions that other Minions reference via ID fields\n3. Check for dependent Minions before any destructive operation\n4. If hard-delete is required, ensure all references are cleaned up first\n\n---\n\n## Hard Rules\n\n- Every Minion MUST conform to its MinionType schema\n- All `select` fields must use valid option values\n- All ID reference fields must point to existing Minions\n- Timestamps must be in ISO 8601 format\n- Never create orphaned Minions â€” always set reference fields when applicable\n- This agent only writes to `{{projectName}}` â€” it reads from other toolboxes but never writes to them"
            },
            {
              "slug": "minions-workflows",
              "name": "minions-workflows",
              "id": "OC-0172",
              "version": "1.0.0",
              "description": "Workflow definitions, step sequences, transitions, and run history",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-workflows â€” Agent Skills\n\n## What is a Workflow in the Minions Context?\n\nBefore defining types, it's worth being precise. A \"workflow\" can mean several different things:\n\n```\na reusable multi-step process             â†’ WorkflowDefinition\na single step in that process             â†’ WorkflowStep\na running instance of a workflow          â†’ WorkflowRun\na transition between steps               â†’ WorkflowTransition\nwhat triggered it                         â†’ schedule, event, or manual\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// workflow-definition\n{\n  type: \"workflow-definition\",\n  fields: {\n    name: string,\n    description: string,\n    clawspaceId: string,             // which clawspace this workflow belongs to\n    version: string,                 // semver, e.g. \"1.0.0\"\n    triggerType: \"schedule\" | \"event\" | \"manual\",\n    triggerConfig: string,           // cron expression, event name, or empty\n    status: \"active\" | \"paused\" | \"archived\",\n    createdAt: datetime,\n    updatedAt: datetime\n  }\n}\n\n// workflow-step\n{\n  type: \"workflow-step\",\n  fields: {\n    workflowId: string,\n    name: string,\n    stepIndex: number,               // sequential order within the workflow\n    agentId: string,                 // which agent executes this step\n    skillRef: string,                // skill identifier within that agent\n    inputMapping: string,            // JSON mapping of inputs from previous step\n    outputMapping: string,           // JSON mapping of outputs to next step\n    onSuccess: string,               // next step name or \"complete\"\n    onFailure: string,               // step name, \"retry\", \"abort\", or \"human-review\"\n    timeoutMs: number                // max execution time before failure\n  }\n}\n```\n\n**Execution**\n```ts\n// workflow-run\n{\n  type: \"workflow-run\",\n  fields: {\n    workflowId: string,\n    status: \"pending\" | \"running\" | \"paused\" | \"completed\" | \"failed\" | \"aborted\",\n    currentStepIndex: number,\n    startedAt: datetime,\n    completedAt: datetime,\n    triggeredBy: string,             // scheduleId, eventName, or userId\n    inputs: Record<string, any>,     // initial run inputs\n    outputs: Record<string, any>,    // accumulated outputs\n    errorMessage: string\n  }\n}\n\n// workflow-transition\n{\n  type: \"workflow-transition\",\n  fields: {\n    runId: string,\n    fromStep: string,\n    toStep: string,\n    triggeredAt: datetime,\n    reason: string,                  // \"success\", \"failure\", \"timeout\", \"human-override\"\n    durationMs: number               // time spent on the from-step\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nworkflow-definition  --contains-->       workflow-step\nworkflow-definition  --instantiated-->   workflow-run\nworkflow-run         --logged-->         workflow-transition\nworkflow-step        --executes_via-->   agent-definition (minions-agents)\nworkflow-step        --uses_skill-->     skill-definition (minions-skills)\nworkflow-run         --triggered_by-->   schedule (minions-scheduler)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`minions-workflows` provides the execution engine for all multi-step processes:\n\n```\nminions-orchestration  â†’ workflow-definitions are scoped per clawspaceId\nminions-agents         â†’ each workflow-step maps to an agent + skill\nminions-skills         â†’ skillRef in workflow-step points to a skill-definition\nminions-scheduler      â†’ schedule triggers workflow-runs automatically\nminions-tasks          â†’ each workflow-run may spawn tasks for tracking\nminions-approvals      â†’ workflow-steps with onFailure: \"human-review\" create approval-requests\nminions-costs          â†’ each workflow-run accumulates cost across all step executions\n```\n\nThe key insight: **workflows are data, not code**. An OrchestratorAgent reads a workflow-definition and executes steps sequentially, routing outputs from one agent to the inputs of the next. Changing a workflow means editing a Minion, not rewriting agent logic.\n\n---\n\n## Agent SKILLS for `minions-workflows`\n\n```markdown\n# WorkflowAgent Skills\n\n## Context\nYou own the execution of all workflows across all clawspaces.\nYou load workflow-definitions, execute steps in sequence,\nhandle success/failure branching, and log every transition.\nYou do not perform domain work â€” you coordinate agents.\n\n## Skill: Start Workflow Run\n1. On trigger (schedule, event, or manual):\n   - Load the workflow-definition by id\n   - Create a `workflow-run` Minion with status \"running\"\n   - Set currentStepIndex to 0\n   - Begin executing the first step\n\n## Skill: Execute Step\n1. Load the workflow-step at currentStepIndex\n2. Prepare inputs using inputMapping from accumulated run outputs\n3. Invoke the target agent's skill via agent-message\n4. Wait for completion (up to timeoutMs)\n5. On success:\n   - Apply outputMapping to merge results into run outputs\n   - Create workflow-transition with reason \"success\"\n   - Advance to onSuccess step\n6. On failure:\n   - Create workflow-transition with reason \"failure\"\n   - Follow onFailure directive:\n     - \"retry\": re-execute the same step (max 3 retries)\n     - \"abort\": set run status to \"failed\", log error\n     - \"human-review\": create approval-request, pause run\n     - step-name: branch to that step\n7. On timeout:\n   - Create workflow-transition with reason \"timeout\"\n   - Follow onFailure directive\n\n## Skill: Resume Paused Run\n1. On approval-request decision:\n   - If approved: resume from current step with any modified inputs\n   - If rejected: abort the run, log reason\n\n## Skill: Complete Run\n1. When the final step's onSuccess is \"complete\":\n   - Set run status to \"completed\", set completedAt\n   - Log final workflow-transition\n   - Emit \"workflow-complete\" to OrchestratorAgent\n   - Record cost summary via minions-costs\n\n## Hard Rules\n- Never skip a step â€” always execute in order unless branching via onFailure\n- Every step transition must produce a workflow-transition Minion\n- Max 3 retries per step before escalating to onFailure\n- Timed-out steps always follow the failure path\n- Workflow-run Minions are immutable after completion â€” never edit a finished run\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-workflows/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nworkflows types list\nworkflows types show <type-slug>\n```\n\n### CRUD\n\n```bash\nworkflows create <type> -t \"Title\" -s \"status\"\nworkflows list <type>\nworkflows show <id>\nworkflows update <id> --data '{ \"status\": \"active\" }'\nworkflows delete <id>\nworkflows search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nworkflows stats\nworkflows validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-test-scenarios",
              "name": "minions-test-scenarios",
              "id": "OC-0169",
              "version": "1.0.0",
              "description": "Conversation scripts, tester personas, edge cases, and golden datasets",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-test-scenarios â€” Agent Skills\n\n## What is a Test Scenario in the Minions Context?\n\n```\na multi-turn conversation test            â†’ TestScenario\na simulated user persona                  â†’ TesterPersona\nexpected input-output pairs               â†’ GoldenDataset\n```\n\nAI-as-Tester: the ScenarioAgent dynamically converses with the agent-under-test.\n\n## MinionTypes\n```ts\n// test-scenario â€” name, turns, expected outcome, difficulty, tags\n// tester-persona â€” traits, communication style, technical level\n// golden-dataset â€” curated expected pairs for regression testing\n```\n\n## Agent SKILLS\n```markdown\n# ScenarioAgent Skills\n## Skill: Design Scenario â€” create multi-turn test with assertions\n## Skill: Run AI-as-Tester â€” dynamically converse using persona\n## Hard Rules â€” every scenario must have expected outcomes defined\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-test-scenarios/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\ntest-scenarios types list\ntest-scenarios types show <type-slug>\n```\n\n### CRUD\n\n```bash\ntest-scenarios create <type> -t \"Title\" -s \"status\"\ntest-scenarios list <type>\ntest-scenarios show <id>\ntest-scenarios update <id> --data '{ \"status\": \"active\" }'\ntest-scenarios delete <id>\ntest-scenarios search \"query\"\n```\n\n### Stats & Validation\n\n```bash\ntest-scenarios stats\ntest-scenarios validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-taxonomy",
              "name": "minions-taxonomy",
              "id": "OC-0164",
              "version": "1.0.0",
              "description": "Organizational metadata â€” groups, categories, tags, namespaces, statuses, and priorities",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-taxonomy â€” Agent Skills\n\n## What is Taxonomy in the Minions Context?\n\nBefore defining types, it's worth being precise. \"Taxonomy\" in a system with 500+ MinionTypes can mean very different things:\n\n```\nhow you group things by purpose        â†’ MinionGroup\nhow you browse things hierarchically   â†’ MinionCategory\nhow you label things freely            â†’ MinionTag\nwho owns or originates a type          â†’ MinionNamespace\nwhat lifecycle stage something is in   â†’ MinionStatus\nhow urgent or important something is   â†’ MinionPriority\n```\n\nThe key insight is that none of these are domain concepts â€” they are **meta-concepts**. They don't describe jobs, proposals, or agents. They describe *how you organize and navigate everything else*. That's what makes `minions-taxonomy` foundational.\n\n---\n\n## MinionTypes\n\n**Grouping by Purpose**\n```ts\n// minion-group\n// answers: \"what things belong together for a shared goal?\"\n{\n  type: \"minion-group\",\n  fields: {\n    name: string,              // \"Freelance Job Hunter\"\n    description: string,       // what this group accomplishes together\n    minionTypes: string[],     // [\"job-posting\", \"job-signal\", \"match-score\"]\n    categoryId: string,        // optional parent category\n    namespaceId: string,       // who owns this group\n    tags: string[],\n    status: \"active\" | \"draft\" | \"archived\"\n  }\n}\n```\n\n**Hierarchical Browsing**\n```ts\n// minion-category\n// answers: \"where does this live in the tree?\"\n{\n  type: \"minion-category\",\n  fields: {\n    name: string,              // \"Finance\"\n    parentCategoryId: string,  // null if root, else \"Finance\" > \"Invoicing\" > \"LineItem\"\n    description: string,\n    path: string,              // \"finance/invoicing/line-item\" â€” computed, for fast lookup\n    icon: string,\n    color: string,\n    order: number              // display order among siblings\n  }\n}\n```\n\n**Freeform Labeling**\n```ts\n// minion-tag\n// answers: \"what traits does this have?\"\n{\n  type: \"minion-tag\",\n  fields: {\n    name: string,              // \"has-approval-flow\", \"ai-generated\", \"auditable\"\n    color: string,\n    description: string,\n    namespaceId: string,       // scopes the tag to an owner if needed\n    isSystem: boolean          // true = created by toolbox, false = user-defined\n  }\n}\n\n// minion-tag-assignment\n// the actual link between a tag and any Minion instance\n{\n  type: \"minion-tag-assignment\",\n  fields: {\n    tagId: string,\n    targetType: string,        // \"job-posting\", \"task\", \"agent-definition\"\n    targetId: string,\n    assignedAt: datetime,\n    assignedBy: string\n  }\n}\n```\n\n**Ownership and Origin**\n```ts\n// minion-namespace\n// answers: \"who owns or produced this set of types?\"\n{\n  type: \"minion-namespace\",\n  fields: {\n    name: string,              // \"system\", \"user\", \"toolbox:minions-jobs\"\n    owner: string,\n    ownerType: \"system\" | \"user\" | \"toolbox\" | \"agent\",\n    description: string,\n    isLocked: boolean          // true = only system can modify types in this namespace\n  }\n}\n```\n\n**Lifecycle State**\n```ts\n// minion-status\n// answers: \"what stage of its life is this type or instance in?\"\n{\n  type: \"minion-status\",\n  fields: {\n    name: string,              // \"in-progress\", \"blocked\", \"done\"\n    label: string,             // human readable display label\n    color: string,\n    isTerminal: boolean,       // true = no further transitions expected\n    allowedTransitions: string[], // which statuses can follow this one\n    order: number,             // position in a typical flow\n    namespaceId: string        // statuses can be scoped per domain\n  }\n}\n```\n\n**Importance and Urgency**\n```ts\n// minion-priority\n// answers: \"how important or urgent is this relative to others?\"\n{\n  type: \"minion-priority\",\n  fields: {\n    name: string,              // \"critical\", \"high\", \"medium\", \"low\"\n    label: string,\n    weight: number,            // numeric for sorting: 100, 75, 50, 25\n    color: string,\n    icon: string,\n    isDefault: boolean         // which priority is assumed when none is set\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nminion-group        --contains-->           MinionType (by name ref)\nminion-group        --belongs_to-->         minion-category\nminion-group        --scoped_to-->          minion-namespace\nminion-category     --parent_of-->          minion-category\nminion-tag          --scoped_to-->          minion-namespace\nminion-tag-assignment --tags-->             any Minion (via targetType + targetId)\nminion-status       --transitions_to-->     minion-status\nminion-status       --scoped_to-->          minion-namespace\nminion-priority     --scoped_to-->          minion-namespace\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`minions-taxonomy` is unique in that **every other toolbox depends on it, but it depends on nothing**. It sits at the base of the entire ecosystem.\n\n```\nminions-tasks       uses minion-priority for task.priority\n                    uses minion-status for task.status\n                    uses minion-tag-assignment to label any task\n                    uses minion-group to say \"these task types belong to Freelance Hunter\"\n\nminions-jobs        uses minion-tag-assignment to tag job-postings (\"red-flag\", \"shortlisted\")\n                    uses minion-namespace to mark types as owned by \"toolbox:minions-jobs\"\n                    uses minion-category to place job-posting under \"Jobs > Freelance > Posting\"\n\nminions-agents      uses minion-status for agent-definition.status\n                    uses minion-group to bundle all agent-related types together\n                    uses minion-namespace \"system\" to lock core agent types\n\nminions-pipeline    uses minion-status as the definition of each pipeline stage state\n                    uses minion-priority to rank pipeline entries\n\nminions-approvals   uses minion-status for approval-request.decision state\n                    uses minion-tag-assignment to flag audit-log-entries\n\nevery toolbox       uses minion-namespace to declare ownership of its types\n                    uses minion-group to expose its purpose bundle in the UI\n```\n\nThe practical result: when you browse 500 MinionTypes in the UI, you can filter by any combination â€”\n\n```\ncategory: \"Jobs\"  AND  tag: \"ai-generated\"  AND  namespace: \"toolbox:minions-jobs\"\nâ†’ returns: job-posting, job-signal, job-watchlist\n```\n\n---\n\n## Agent SKILLS for `minions-taxonomy`\n\n```markdown\n# TaxonomyAgent Skills\n\n## Context\nYou manage all organizational metadata in the Minions ecosystem.\nYou own minions-taxonomy. You read from all other toolboxes to classify\nand label their Minion instances, but you never write to their stores directly.\nYour job is to keep the ecosystem navigable as it grows.\n\n## Skill: Bootstrap Taxonomy\n- On first run, create the root minion-category tree:\n  Jobs > Freelance, Jobs > Contract\n  Agents > Orchestrator, Agents > Worker, Agents > Watcher\n  Finance > Costs, Finance > Contracts\n  Profile > Skills, Profile > Portfolio\n  Operations > Approvals, Operations > Audit, Operations > Scheduling\n- Create system minion-namespace entries: \"system\", \"user\"\n- Create one minion-namespace per installed toolbox: \"toolbox:minions-jobs\" etc.\n- Create default minion-priority set: critical (100), high (75), medium (50), low (25)\n- Mark one priority isDefault: true (medium)\n- Create default minion-status sets per domain (jobs, tasks, approvals, agents)\n\n## Skill: Register New Toolbox\n- When a new toolbox is installed:\n  1. Create a minion-namespace for it\n  2. Create or find a minion-group matching its purpose\n  3. Add all its MinionType names to that group's minionTypes list\n  4. Place the group under the correct minion-category node\n  5. Apply system tags to each type: \"toolbox-managed\", and any trait tags\n\n## Skill: Tag Minion Instances\n- When instructed by Orchestrator or another agent:\n  1. Create a minion-tag-assignment linking a tag to a target Minion\n  2. Verify the tag exists â€” if not, create it in the appropriate namespace\n  3. Log the assignment with assignedBy set to the requesting agent\n\n## Skill: Maintain Category Tree\n- When a new minion-group has no matching category:\n  1. Propose a category path to the Orchestrator for approval\n  2. On approval, create the minion-category chain (parent first, then child)\n  3. Link the group to the leaf category\n\n## Skill: Audit Taxonomy Health\n- On schedule (weekly):\n  1. Find MinionTypes not assigned to any minion-group â†’ report as \"unclassified\"\n  2. Find minion-tags with zero assignments â†’ report as \"unused tags\"\n  3. Find minion-categories with no groups â†’ report as \"empty categories\"\n  4. Send summary to Orchestrator for review\n\n## Skill: Answer Navigation Queries\n- When an agent asks \"what types belong to group X\":\n  â†’ return minionTypes[] from the matching minion-group\n- When an agent asks \"find all types tagged Y in namespace Z\":\n  â†’ query minion-tag-assignments filtered by tag name and namespace\n- When an agent asks \"what is the default priority\":\n  â†’ return the minion-priority where isDefault == true\n\n## Hard Rules\n- Never delete a minion-namespace marked isLocked\n- Never remove a MinionType from a group without Orchestrator approval\n- Always set namespaceId when creating tags, statuses, or priorities\n- System-created minion-status entries (isSystem: true) cannot be renamed\n```\n\n---\n\n## Why `minion-tag-assignment` is a Separate Type\n\nWorth calling out explicitly: the tag-to-Minion link is its own MinionType rather than a field on each Minion. This means:\n\n```\nany Minion can be tagged without modifying its own schema\ntags can be added, removed, and queried uniformly across all types\nthe full tagging history is queryable (who tagged what, when, and why)\nagents can tag job-postings, tasks, proposals, and runs all through one interface\n```\n\nThis is the same pattern as `task-assignment` in `minions-tasks` â€” the relation itself is a first-class Minion, which keeps every individual type clean and makes cross-domain queries possible.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-taxonomy/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\ntaxonomy types list\n\n# Show detailed schema for a specific type\ntaxonomy types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\ntaxonomy create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\ntaxonomy create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\ntaxonomy list <type>\n\n# Show a specific Minion\ntaxonomy show <id>\n\n# Search by text\ntaxonomy search \"query\"\n\n# Output as JSON (for piping)\ntaxonomy list --json\ntaxonomy show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\ntaxonomy update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\ntaxonomy delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\ntaxonomy stats\n\n# Validate a Minion JSON file against its schema\ntaxonomy validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-social-research",
              "name": "minions-social-research",
              "id": "OC-0160",
              "version": "1.0.0",
              "description": "Trend sources, competitor snapshots, hashtag sets, and audience notes",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-social-research â€” Agent Skills\n\n## What is Social Research in the Minions Context?\n\n```\na configured trend source                  â†’ TrendSource\na competitor snapshot                       â†’ CompetitorSnapshot\na curated hashtag set                       â†’ HashtagSet\nan observed audience insight                â†’ AudienceInsight\n```\n\n---\n\n## MinionTypes\n\n```ts\n// trend-source â€” feeds into content planning\n// competitor-snapshot â€” point-in-time capture\n// hashtag-set â€” curated per theme/platform\n// audience-insight â€” observed pattern with confidence\n```\n\nSee TOML for full field definitions.\n\n---\n\n## Relations\n\n```\ntrend-source       --informs-->          content-calendar (minions-content-plans)\ncompetitor-snapshot --compared_to-->     social-account (minions-social-accounts)\nhashtag-set        --used_in-->         text-post (minions-content-assets)\naudience-insight   --scoped_to-->       account-group (minions-social-accounts)\n```\n\n---\n\n## Agent SKILLS for `minions-social-research`\n\n```markdown\n# ResearchAgent Skills\n\n## Skill: Scan Trends\n1. Crawl active trend-sources\n2. Create competitor-snapshots at regular intervals\n3. Update hashtag-sets based on trending topics\n\n## Skill: Generate Insights\n1. Analyze engagement data across account groups\n2. Create audience-insight Minions with confidence scores\n\n## Hard Rules\n- Competitors are snapshotted, never live-tracked\n- Insights must cite their source data\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-social-research/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nsocial-research types list\nsocial-research types show <type-slug>\n```\n\n### CRUD\n\n```bash\nsocial-research create <type> -t \"Title\" -s \"status\"\nsocial-research list <type>\nsocial-research show <id>\nsocial-research update <id> --data '{ \"status\": \"active\" }'\nsocial-research delete <id>\nsocial-research search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nsocial-research stats\nsocial-research validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-social-accounts",
              "name": "minions-social-accounts",
              "id": "OC-0159",
              "version": "1.0.0",
              "description": "Account definitions, platforms, namespaces/purposes, and API keys",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-social-accounts â€” Agent Skills\n\n## What is a Social Account in the Minions Context?\n\n```\na managed social media account              â†’ SocialAccount\na logical grouping of accounts by purpose   â†’ AccountGroup\nper-account content generation mode config  â†’ ContentModeConfig\n```\n\n---\n\n## MinionTypes\n\n```ts\n// social-account\n{\n  type: \"social-account\",\n  fields: {\n    name: string,\n    platform: \"twitter\" | \"linkedin\" | \"instagram\" | \"tiktok\" | \"youtube\" | \"threads\",\n    handle: string,\n    purpose: string,\n    namespace: string,\n    apiKeyRef: string,\n    status: \"active\" | \"paused\" | \"archived\",\n    createdAt: datetime\n  }\n}\n\n// account-group\n{\n  type: \"account-group\",\n  fields: {\n    name: string,\n    description: string,\n    accountIds: string[],\n    purpose: string,\n    status: \"active\" | \"archived\"\n  }\n}\n\n// content-mode-config\n{\n  type: \"content-mode-config\",\n  fields: {\n    accountId: string,\n    textMode: \"prompt-only\" | \"api-generated\",\n    imageMode: \"prompt-only\" | \"api-generated\" | \"none\",\n    videoMode: \"prompt-only\" | \"api-generated\" | \"none\",\n    isActive: boolean\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nsocial-account     --member_of-->        account-group\nsocial-account     --configured_by-->    content-mode-config\naccount-group      --planned_in-->       content-calendar (minions-content-plans)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-content-plans       â†’ calendars are scoped to account groups\nminions-content-assets      â†’ assets are created per account\nminions-content-publishing  â†’ publish jobs target specific accounts\nminions-costs               â†’ API generation costs tracked per account\n```\n\n---\n\n## Agent SKILLS for `minions-social-accounts`\n\n```markdown\n# AccountAgent Skills\n\n## Skill: Register Account\n1. Create social-account with platform, handle, purpose\n2. Set content-mode-config for text/image/video generation modes\n3. Add to appropriate account-group\n\n## Hard Rules\n- Every account must have a content-mode-config\n- Never delete accounts â€” archive them\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-social-accounts/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nsocial-accounts types list\nsocial-accounts types show <type-slug>\n```\n\n### CRUD\n\n```bash\nsocial-accounts create <type> -t \"Title\" -s \"status\"\nsocial-accounts list <type>\nsocial-accounts show <id>\nsocial-accounts update <id> --data '{ \"status\": \"active\" }'\nsocial-accounts delete <id>\nsocial-accounts search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nsocial-accounts stats\nsocial-accounts validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-skills",
              "name": "minions-skills",
              "id": "OC-0158",
              "version": "1.0.0",
              "description": "Reusable skill definitions that agents can load, compose, and version",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-skills â€” Agent Skills\n\n## What is a Skill in the Minions Context?\n\nA \"skill\" can mean different things depending on the layer you're looking at:\n\n```\nsomething an agent knows how to do      â†’ SkillDefinition\na skill assigned to a specific agent    â†’ SkillAssignment\nthe instructions for executing it       â†’ SkillPrompt\nthe result of running it                â†’ SkillResult\na composed chain of skills              â†’ SkillChain\nhow good an agent is at it over time    â†’ SkillPerformance\n```\n\nThe key distinction from tasks: a **task** is a one-off unit of work. A **skill** is a reusable, versioned capability that can be loaded by any agent and executed repeatedly across many tasks. Skills are the vocabulary of what agents can do â€” tasks are instances of that vocabulary being applied.\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// skill-definition\n{\n  type: \"skill-definition\",\n  fields: {\n    name: string,                  // \"score-job-fit\", \"write-proposal\", \"extract-signals\"\n    description: string,\n    version: string,               // semver: \"1.0.0\", \"1.2.3\"\n    category: string,              // \"analysis\", \"writing\", \"browsing\", \"communication\"\n    inputSchema: Record<string, any>,   // what the skill expects\n    outputSchema: Record<string, any>,  // what it produces\n    promptRef: string,             // ref to minions-prompts version\n    toolsRequired: string[],       // e.g. [\"browser\", \"web-search\"]\n    qualityGates: QualityGate[],   // minimum thresholds to pass\n    isComposed: boolean,           // true if this is a chain of other skills\n    status: \"stable\" | \"experimental\" | \"deprecated\",\n    ownerId: string,\n    createdAt: datetime,\n    updatedAt: datetime\n  }\n}\n\n// skill-version\n{\n  type: \"skill-version\",\n  fields: {\n    skillId: string,\n    version: string,\n    promptBody: string,            // full prompt at this version\n    inputSchema: Record<string, any>,\n    outputSchema: Record<string, any>,\n    changelog: string,\n    publishedAt: datetime,\n    publishedBy: string,\n    isCurrent: boolean\n  }\n}\n```\n\n**Assignment & Access**\n```ts\n// skill-assignment\n{\n  type: \"skill-assignment\",\n  fields: {\n    agentId: string,\n    skillId: string,\n    skillVersion: string,          // pinned version the agent uses\n    assignedAt: datetime,\n    assignedBy: string,\n    isActive: boolean,\n    overrideConfig: Record<string, any>  // agent-specific tuning\n  }\n}\n\n// skill-chain\n{\n  type: \"skill-chain\",\n  fields: {\n    name: string,\n    description: string,\n    steps: SkillChainStep[],       // ordered list of { skillId, inputMapping, outputMapping }\n    isParallel: boolean,           // true = steps can run concurrently\n    onFailure: \"stop\" | \"skip\" | \"fallback\",\n    version: string,\n    status: \"stable\" | \"experimental\" | \"deprecated\"\n  }\n}\n```\n\n**Execution**\n```ts\n// skill-result\n{\n  type: \"skill-result\",\n  fields: {\n    skillId: string,\n    skillVersion: string,\n    agentRunId: string,\n    inputs: Record<string, any>,\n    outputs: Record<string, any>,\n    qualityScore: number,          // 0-1 composite from quality gates\n    gateResults: GateResult[],     // per-gate pass/fail + score\n    passed: boolean,\n    failureReason: string,\n    tokensUsed: number,\n    executedAt: datetime,\n    durationMs: number\n  }\n}\n\n// skill-retry\n{\n  type: \"skill-retry\",\n  fields: {\n    skillResultId: string,         // the failed result this retries\n    skillId: string,\n    agentRunId: string,\n    attempt: number,               // 1, 2, 3...\n    adjustedInputs: Record<string, any>,  // what changed vs original\n    retryReason: string,\n    outcome: \"success\" | \"failed\" | \"abandoned\"\n  }\n}\n```\n\n**Quality & Performance**\n```ts\n// skill-quality-gate\n{\n  type: \"skill-quality-gate\",\n  fields: {\n    skillId: string,\n    name: string,                  // \"clarity\", \"relevance\", \"factual-accuracy\"\n    description: string,\n    evaluationMethod: \"llm-score\" | \"rule\" | \"human\",\n    threshold: number,             // minimum passing score 0-1\n    weight: number,                // contribution to composite score\n    isBlocking: boolean            // if true, failure stops execution\n  }\n}\n\n// skill-performance\n{\n  type: \"skill-performance\",\n  fields: {\n    skillId: string,\n    agentId: string,\n    periodStart: datetime,\n    periodEnd: datetime,\n    totalExecutions: number,\n    passRate: number,\n    averageQualityScore: number,\n    averageDurationMs: number,\n    averageTokensUsed: number,\n    failureReasons: string[]       // aggregated common failure causes\n  }\n}\n```\n\n**Feedback & Improvement**\n```ts\n// skill-feedback\n{\n  type: \"skill-feedback\",\n  fields: {\n    skillResultId: string,\n    skillId: string,\n    authorId: string,\n    authorType: \"human\" | \"agent\",\n    rating: number,                // 1-5\n    notes: string,\n    suggestedImprovement: string,\n    createdAt: datetime\n  }\n}\n\n// skill-improvement\n{\n  type: \"skill-improvement\",\n  fields: {\n    skillId: string,\n    triggeredBy: string,           // feedbackId or performanceId\n    hypothesis: string,            // what change is being tested\n    promptChange: string,          // diff from current version\n    testCaseIds: string[],         // from minions-evaluations\n    status: \"proposed\" | \"testing\" | \"adopted\" | \"rejected\",\n    result: string,\n    createdAt: datetime\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nskill-definition    --has_version-->        skill-version\nskill-definition    --assigned_to-->        skill-assignment  (via agentId)\nskill-definition    --has_gate-->           skill-quality-gate\nskill-definition    --composed_into-->      skill-chain\nskill-chain         --contains-->           skill-definition  (many)\nskill-assignment    --used_by-->            agent-definition  (minions-agents)\nskill-result        --produced_by-->        agent-run         (minions-agents)\nskill-result        --received-->           skill-feedback\nskill-result        --triggered-->          skill-retry\nskill-feedback      --led_to-->             skill-improvement\nskill-improvement   --tested_by-->          test-case         (minions-evaluations)\nskill-performance   --summarizes-->         skill-result      (many)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-agents       â†’ agent-definition loads skill-assignments to know what it can do\n                     â†’ agent-run records which skill-results it produced\n\nminions-prompts      â†’ skill-definition.promptRef points to a versioned prompt\n                     â†’ skill-version.promptBody is a snapshot of that prompt\n\nminions-evaluations  â†’ test-case references skillId to benchmark specific skills\n                     â†’ skill-improvement uses testCaseIds to validate changes\n\nminions-tasks        â†’ a task with assigneeType \"agent\" resolves to a skill execution\n                     â†’ task-outcome.lessons feed into skill-feedback\n\nminions-costs        â†’ cost-entry.sourceType can be \"skill-result\"\n                     â†’ skill-performance.averageTokensUsed informs budget planning\n```\n\nThe critical relationship is with `minions-agents`: an agent without skills is just a definition. Skills are what give an agent its actual behavioral surface area. The `skill-assignment` with a pinned `skillVersion` ensures that when you update a skill, existing agents don't silently change behavior â€” they stay on their pinned version until explicitly upgraded.\n\n---\n\n## Agent SKILLS file (`skills-agent.skills.md`)\n\n```markdown\n# SkillsAgent Skills\n\n## Context\nYou manage the skill registry for the entire agent fleet. You own minions-skills.\nYou read from minions-agents to know which agents exist and what they are assigned.\nYou read from minions-evaluations to validate improvements.\nYou read from minions-prompts to resolve prompt references.\nYou never execute skills yourself â€” you define, version, assign, and improve them.\n\n## Skill: Register New Skill\n1. Receive a skill specification (name, description, input/output schema, prompt)\n2. Check for an existing skill-definition with the same name\n   - If exists: create a new skill-version instead\n   - If new: create a skill-definition Minion with version \"1.0.0\"\n3. Create a skill-version Minion with isCurrent: true\n4. Set previous version isCurrent: false\n5. Define at least one skill-quality-gate for the new skill\n6. Emit notification to OrchestratorAgent: \"new-skill-available\"\n\n## Skill: Assign Skill to Agent\n1. Verify skill-definition exists and status is \"stable\"\n2. Verify agent-definition exists in minions-agents\n3. Check toolsRequired â€” confirm agent has access to those tools\n4. Create skill-assignment Minion with pinned skillVersion\n5. Log to audit trail\n\n## Skill: Evaluate Skill Performance\n1. On schedule (daily): query all skill-result Minions from last 24h\n2. Group by skillId + agentId\n3. Compute and store skill-performance Minion:\n   - passRate, averageQualityScore, averageDurationMs, averageTokensUsed\n   - Aggregate failureReasons from failed results\n4. Flag any skill where passRate < 0.7 for review\n5. Emit \"skill-degradation-alert\" to OrchestratorAgent if flagged\n\n## Skill: Process Feedback\n1. On new skill-feedback Minion created:\n   - If rating < 3: create skill-improvement Minion with status \"proposed\"\n   - If rating >= 4: log positive signal to skill-performance\n2. For proposed improvements: check if 3+ feedbacks share the same pattern\n   - If yes: escalate improvement to status \"testing\"\n\n## Skill: Test and Adopt Improvement\n1. On skill-improvement with status \"testing\":\n   - Load linked test-case Minions from minions-evaluations\n   - Run test cases against the proposed promptChange\n   - Compare scores to current version baseline\n2. If improvement scores higher on all gates:\n   - Create new skill-version with the new prompt\n   - Update skill-improvement status to \"adopted\"\n3. If not: set status to \"rejected\" with result notes\n\n## Skill: Deprecate Skill\n1. Verify no active skill-assignment Minions reference this skill\n   - If active assignments exist: notify assigned agents' owners first\n2. Set skill-definition status to \"deprecated\"\n3. Emit \"skill-deprecated\" to OrchestratorAgent with affected agentIds\n\n## Hard Rules\n- Never assign a skill with status \"deprecated\" or \"experimental\" without explicit approval\n- Never delete a skill-version â€” only deprecate\n- Always pin a specific skillVersion in skill-assignment, never \"latest\"\n- A skill with zero quality gates must not be assigned to any agent\n- All skill-improvement changes must pass test cases before adoption\n```\n\n---\n\nThe pinned version rule in the SKILLS file is the most important design decision here. It means skills can evolve independently of agents â€” you can ship `write-proposal@2.0.0` and only upgrade agents to it deliberately, one at a time, with test results proving the new version is better before any agent in production touches it.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-skills/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\nskills types list\n\n# Show detailed schema for a specific type\nskills types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\nskills create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\nskills create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\nskills list <type>\n\n# Show a specific Minion\nskills show <id>\n\n# Search by text\nskills search \"query\"\n\n# Output as JSON (for piping)\nskills list --json\nskills show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\nskills update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\nskills delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\nskills stats\n\n# Validate a Minion JSON file against its schema\nskills validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-scheduler",
              "name": "minions-scheduler",
              "id": "OC-0156",
              "version": "1.0.0",
              "description": "Schedules, cron triggers, and timed execution definitions",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-scheduler â€” Agent Skills\n\n## What is a Schedule in the Minions Context?\n\nBefore defining types, it's worth being precise. \"Scheduling\" can mean several different things:\n\n```\nsomething that runs on a timer          â†’ Schedule\nsomething that fires when X happens     â†’ Trigger\na single execution of a schedule        â†’ ScheduleRun\na queue of things waiting to run        â†’ ExecutionQueue\na pause or override on a schedule       â†’ ScheduleOverride\nwhat happened across all runs           â†’ ScheduleHistory\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// schedule\n{\n  type: \"schedule\",\n  fields: {\n    name: string,\n    description: string,\n    cronExpression: string,       // \"0 */6 * * *\" = every 6 hours\n    timezone: string,             // \"Europe/Berlin\"\n    targetAgentId: string,\n    targetSkill: string,          // which SKILL the agent should run\n    inputPayload: Record<string, any>,  // static inputs passed each run\n    status: \"active\" | \"paused\" | \"archived\",\n    createdAt: datetime,\n    lastRunAt: datetime,\n    nextRunAt: datetime,\n    maxRetries: number,\n    retryDelaySeconds: number,\n    tags: string[]\n  }\n}\n\n// trigger\n{\n  type: \"trigger\",\n  fields: {\n    name: string,\n    description: string,\n    eventType: string,            // \"job-posting.created\", \"approval.approved\"\n    sourceMinonType: string,      // which MinionType emits this event\n    condition: string,            // expression: \"budget > 500 AND platform == upwork\"\n    targetAgentId: string,\n    targetSkill: string,\n    inputMapping: Record<string, any>,  // how event fields map to skill inputs\n    isActive: boolean,\n    lastFiredAt: datetime,\n    fireCount: number\n  }\n}\n```\n\n**Execution**\n```ts\n// schedule-run\n{\n  type: \"schedule-run\",\n  fields: {\n    scheduleId: string,\n    triggeredAt: datetime,\n    startedAt: datetime,\n    completedAt: datetime,\n    status: \"queued\" | \"running\" | \"success\" | \"failed\" | \"retrying\" | \"cancelled\",\n    attempt: number,              // 1 = first try, 2 = first retry, etc.\n    agentRunId: string,           // ref to the actual agent-run Minion\n    output: Record<string, any>,\n    errorMessage: string,\n    durationMs: number\n  }\n}\n\n// trigger-fire\n{\n  type: \"trigger-fire\",\n  fields: {\n    triggerId: string,\n    firedAt: datetime,\n    sourceRefType: string,        // what caused it\n    sourceRefId: string,\n    resolvedInputs: Record<string, any>,\n    agentRunId: string,\n    status: \"success\" | \"failed\" | \"skipped\",\n    skipReason: string            // why it was skipped if condition not fully met\n  }\n}\n\n// execution-queue-item\n{\n  type: \"execution-queue-item\",\n  fields: {\n    sourceType: \"schedule\" | \"trigger\" | \"manual\",\n    sourceId: string,\n    targetAgentId: string,\n    targetSkill: string,\n    inputs: Record<string, any>,\n    priority: \"critical\" | \"high\" | \"medium\" | \"low\",\n    queuedAt: datetime,\n    scheduledFor: datetime,       // earliest it should run\n    status: \"waiting\" | \"running\" | \"done\" | \"cancelled\",\n    agentRunId: string\n  }\n}\n```\n\n**Control**\n```ts\n// schedule-override\n{\n  type: \"schedule-override\",\n  fields: {\n    scheduleId: string,\n    type: \"pause\" | \"skip-next\" | \"run-now\" | \"change-cron\",\n    reason: string,\n    requestedBy: string,\n    appliedAt: datetime,\n    expiresAt: datetime,          // when the override lifts automatically\n    newCronExpression: string     // only for change-cron type\n  }\n}\n\n// schedule-window\n{\n  type: \"schedule-window\",\n  fields: {\n    scheduleId: string,\n    label: string,                // \"business hours only\", \"weekdays\"\n    allowedDaysOfWeek: string[],  // [\"mon\", \"tue\", \"wed\", \"thu\", \"fri\"]\n    allowedFromTime: string,      // \"08:00\"\n    allowedToTime: string,        // \"20:00\"\n    timezone: string,\n    isActive: boolean\n  }\n}\n```\n\n**History & Metrics**\n```ts\n// schedule-history\n{\n  type: \"schedule-history\",\n  fields: {\n    scheduleId: string,\n    periodStart: datetime,\n    periodEnd: datetime,\n    totalRuns: number,\n    successCount: number,\n    failureCount: number,\n    averageDurationMs: number,\n    lastStatus: string\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nschedule          --produces-->         schedule-run\nschedule          --constrained_by-->   schedule-window\nschedule          --overridden_by-->    schedule-override\nschedule-run      --executes-->         agent-run (minions-agents)\ntrigger           --produces-->         trigger-fire\ntrigger-fire      --executes-->         agent-run (minions-agents)\nschedule          --queues-->           execution-queue-item\ntrigger           --queues-->           execution-queue-item\nexecution-queue-item --resolves_to-->   agent-run (minions-agents)\nschedule-run      --summarized_in-->    schedule-history\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-agents      â†’ every schedule and trigger ultimately produces an agent-run\nminions-jobs        â†’ \"job-posting.created\" fires a trigger â†’ JobScoutAgent runs\nminions-approvals   â†’ a schedule can be paused via schedule-override pending approval\nminions-costs       â†’ each schedule-run contributes a cost-entry\nminions-tasks       â†’ a recurring-task in minions-tasks can reference a schedule as its engine\nminions-comms       â†’ on schedule failure, a notification is dispatched to Mehdi\n```\n\nThe key relationship with `minions-tasks` is worth elaborating. A `recurring-task` in `minions-tasks` describes *what* repeats at the data/intent level. A `schedule` in `minions-scheduler` describes *when and how* it runs at the execution level. They complement each other â€” the recurring-task owns the business logic, the schedule owns the timing mechanism.\n\n---\n\n## Agent SKILLS for `minions-scheduler`\n\n```markdown\n# SchedulerAgent Skills\n\n## Context\nYou manage all time-based and event-based execution in the Minions ecosystem.\nYou own minions-scheduler. You read from minions-agents to know which agents\nand skills exist. You write schedule-run and trigger-fire records for every\nexecution. You never run agents directly â€” you queue them via execution-queue-item\nand hand off to the relevant agent.\n\n## Skill: Register Schedule\n1. Validate cronExpression is well-formed\n2. Validate targetAgentId exists in minions-agents\n3. Validate targetSkill exists in that agent's skill-assignment list\n4. Create `schedule` Minion with status \"active\"\n5. Compute and set nextRunAt from cronExpression + timezone\n6. Notify Orchestrator: \"schedule registered: {name}\"\n\n## Skill: Evaluate Due Schedules\n- Run this skill on a frequent heartbeat (e.g. every minute via OpenClaw)\n1. Load all `schedule` Minions where status == \"active\" AND nextRunAt <= now\n2. For each due schedule:\n   a. Check for active `schedule-window` â€” if outside window, skip and advance nextRunAt\n   b. Check for active `schedule-override` of type \"skip-next\" â€” skip and clear override\n   c. Otherwise: create `execution-queue-item` with priority from schedule\n   d. Update schedule.lastRunAt = now, compute new nextRunAt\n3. Emit \"queue-updated\" to Orchestrator\n\n## Skill: Evaluate Triggers\n1. On any Minion create/update event, check all active `trigger` Minions\n2. For each trigger where eventType matches:\n   a. Evaluate condition expression against the event payload\n   b. If condition passes: resolve inputMapping, create `execution-queue-item`\n   c. Create `trigger-fire` Minion with status and resolved inputs\n   d. Increment trigger.fireCount, update lastFiredAt\n\n## Skill: Process Execution Queue\n1. Load `execution-queue-item` Minions where status == \"waiting\"\n   AND scheduledFor <= now, ordered by priority then queuedAt\n2. For each item: instruct target agent to run targetSkill with inputs\n3. Update item status to \"running\", record agentRunId when returned\n4. On completion: update item status to \"done\" or \"failed\"\n\n## Skill: Handle Failures and Retries\n1. On schedule-run failure:\n   a. Check schedule.maxRetries vs current attempt number\n   b. If retries remaining: create new execution-queue-item with\n      scheduledFor = now + retryDelaySeconds, increment attempt\n   c. If no retries remaining: update schedule-run status to \"failed\"\n   d. Create notification Minion in minions-comms: \"Schedule {name} failed\n      after {maxRetries} attempts\"\n2. Log failure in schedule-history\n\n## Skill: Apply Override\n1. On receiving \"override-schedule\" instruction from Orchestrator:\n   a. Create `schedule-override` Minion with type, reason, expiresAt\n   b. If type == \"pause\": update schedule.status to \"paused\"\n   c. If type == \"run-now\": immediately create execution-queue-item,\n      bypass window and nextRunAt checks\n   d. If type == \"change-cron\": update schedule.cronExpression,\n      recompute nextRunAt\n2. Log override in audit-log (minions-approvals)\n\n## Skill: Summarize Schedule Health\n- Run daily, triggered by its own schedule\n1. For each active schedule, load last 7 days of schedule-run Minions\n2. Compute success rate, average duration, failure patterns\n3. Create or update `schedule-history` Minion for each schedule\n4. If any schedule has success rate < 80%: flag in notification to Mehdi\n\n## Hard Rules\n- Never execute an agent directly â€” always route through execution-queue-item\n- Never create a schedule without validating the target agent and skill exist\n- Always respect schedule-window constraints before queuing\n- Always log every trigger-fire, even skipped ones, with skipReason\n- Always create a schedule-run record before the agent-run starts,\n  not after â€” so failures mid-run are still captured\n```\n\n---\n\nThe `schedule-window` type is worth highlighting â€” it's what prevents your JobScoutAgent from crawling Upwork at 3am or on weekends if platform ToS or rate limits make that risky. And the separation between `schedule` (the definition) and `schedule-run` (the instance) is what gives you a clean history without mutating the original schedule record.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-scheduler/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\nscheduler types list\n\n# Show detailed schema for a specific type\nscheduler types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\nscheduler create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\nscheduler create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\nscheduler list <type>\n\n# Show a specific Minion\nscheduler show <id>\n\n# Search by text\nscheduler search \"query\"\n\n# Output as JSON (for piping)\nscheduler list --json\nscheduler show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\nscheduler update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\nscheduler delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\nscheduler stats\n\n# Validate a Minion JSON file against its schema\nscheduler validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-scaffolds",
              "name": "minions-scaffolds",
              "id": "OC-0155",
              "version": "1.0.0",
              "description": "Project scaffolding templates, tech stack configs, and initial file sets",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-scaffolds â€” Agent Skills\n\n## What is a Scaffold in the Minions Context?\n\n```\na project scaffolding template            â†’ ScaffoldTemplate\ntech stack choices and dependencies       â†’ TechStackConfig\na boilerplate file to include             â†’ InitialFile\n```\n\n---\n\n## MinionTypes\n\n```ts\n// scaffold-template\n{\n  type: \"scaffold-template\",\n  fields: {\n    name: string,                   // \"vite-react-ts\", \"next-convex\", \"cli-tool\"\n    description: string,\n    techStack: string,              // \"React + TypeScript + Vite\"\n    framework: string,              // \"vite\", \"next\", \"astro\"\n    language: string,               // \"typescript\", \"python\"\n    packageManager: \"pnpm\" | \"npm\" | \"yarn\" | \"bun\",\n    initCommand: string,            // \"npx create-vite@latest ./ --template react-ts\"\n    postInitSteps: string[],        // [\"pnpm install\", \"pnpm add convex\"]\n    version: string,\n    status: \"active\" | \"deprecated\"\n  }\n}\n\n// tech-stack-config â€” per-dependency version pinning and purpose\n// initial-file â€” template files (README, .gitignore, config files)\n```\n\n---\n\n## Relations\n\n```\nscaffold-template  --has_config-->       tech-stack-config\nscaffold-template  --includes-->         initial-file\nscaffold-template  --used_by-->          repo-definition (minions-repos)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-repos        â†’ repo creation triggers scaffold selection\nminions-agent-tasks  â†’ post-scaffold, agent-tasks implement features\nminions-documents    â†’ scaffold templates can be versioned as documents\nminions-taxonomy     â†’ tech stacks can be categorized (frontend, backend, CLI, etc.)\n```\n\n---\n\n## Agent SKILLS for `minions-scaffolds`\n\n```markdown\n# ScaffoldAgent Skills\n\n## Context\nYou manage project templates and initial setup. When RepoAgent creates\na repo, you scaffold the initial project structure using the appropriate\ntemplate for the chosen tech stack.\n\n## Skill: Scaffold Project\n1. Select scaffold-template matching the project requirements\n2. Run initCommand in the repo directory\n3. Execute postInitSteps (install deps, add configs)\n4. Write initial-files (README, .env.example, etc.)\n5. Commit initial scaffold: `git commit -m \"feat: initial scaffold\"`\n\n## Skill: Manage Templates\n1. Create/update scaffold-template Minions\n2. Version tech-stack-config for dependency updates\n3. Deprecate outdated templates\n\n## Hard Rules\n- Every scaffold must produce a buildable project\n- Initial commit must include a working CI config\n- Templates are versioned â€” never modify in place\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-scaffolds/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nscaffolds types list\nscaffolds types show <type-slug>\n```\n\n### CRUD\n\n```bash\nscaffolds create <type> -t \"Title\" -s \"status\"\nscaffolds list <type>\nscaffolds show <id>\nscaffolds update <id> --data '{ \"status\": \"active\" }'\nscaffolds delete <id>\nscaffolds search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nscaffolds stats\nscaffolds validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-risks",
              "name": "minions-risks",
              "id": "OC-0154",
              "version": "1.0.0",
              "description": "Risk register, likelihood, impact, and mitigation plans",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-risks â€” Agent Skills\n\n## What is a Risk in the Minions Context?\n\n```\nan identified project risk                â†’ Risk\na status update on a tracked risk         â†’ RiskUpdate\n```\n\n## MinionTypes\n```ts\n// risk â€” title, likelihood, impact, risk score, mitigation plan, owner\n// risk-update â€” periodic reassessment of likelihood and impact\n```\n\n## Relations\n```\nrisk              --belongs_to-->        project (minions-projects)\nrisk              --updated_by-->        risk-update\nrisk              --mitigated_via-->     task (minions-tasks)\n```\n\n## Agent SKILLS\n```markdown\n# RiskAgent Skills\n## Skill: Identify Risks â€” scan project state for new risks\n## Skill: Update Risk Register â€” periodic risk-update Minions\n## Hard Rules â€” high-impact risks require mitigation plans within 24h\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-risks/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nrisks types list\nrisks types show <type-slug>\n```\n\n### CRUD\n\n```bash\nrisks create <type> -t \"Title\" -s \"status\"\nrisks list <type>\nrisks show <id>\nrisks update <id> --data '{ \"status\": \"active\" }'\nrisks delete <id>\nrisks search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nrisks stats\nrisks validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-repos",
              "name": "minions-repos",
              "id": "OC-0153",
              "version": "1.0.0",
              "description": "GitHub repo definitions, workflow templates, label sets, and branch protection rules",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-repos â€” Agent Skills\n\n## What is a Repo in the Minions Context?\n\n```\na GitHub repository to be created           â†’ RepoDefinition\na reusable GitHub Actions workflow          â†’ WorkflowTemplate\na curated set of issue/PR labels            â†’ LabelSet\nbranch protection and merge rules           â†’ BranchRule\n```\n\n---\n\n## MinionTypes\n\n```ts\n// repo-definition\n{\n  type: \"repo-definition\",\n  fields: {\n    name: string,                   // \"my-awesome-app\"\n    description: string,\n    visibility: \"public\" | \"private\",\n    defaultBranch: string,          // \"main\"\n    template: string,               // scaffold template to use\n    org: string,                    // \"mxn2020\"\n    status: \"planned\" | \"created\" | \"configured\" | \"archived\",\n    createdAt: datetime,\n    repoUrl: string                 // \"https://github.com/mxn2020/my-awesome-app\"\n  }\n}\n\n// workflow-template â€” reusable CI/CD YAML templates\n// label-set â€” predefined label collections (e.g. \"standard\", \"agile\")\n// branch-rule â€” protection policies per branch\n```\n\nSee TOML for full field definitions.\n\n---\n\n## Relations\n\n```\nrepo-definition    --uses_template-->    scaffold-template (minions-scaffolds)\nrepo-definition    --has_workflows-->    workflow-template\nrepo-definition    --has_labels-->       label-set\nrepo-definition    --has_rules-->        branch-rule\nrepo-definition    --receives_tasks-->   agent-task (minions-agent-tasks)\nrepo-definition    --has_releases-->     release-plan (minions-releases)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-scaffolds      â†’ scaffold selected at repo creation time\nminions-agent-tasks    â†’ agent-tasks reference repoDefinitionId\nminions-releases       â†’ release plans and publish targets scoped to repo\nminions-tasks          â†’ repo configuration issues create tasks\nminions-costs          â†’ GitHub Actions minutes can be tracked\n```\n\n---\n\n## Agent SKILLS for `minions-repos`\n\n```markdown\n# RepoAgent Skills\n\n## Context\nYou create and configure GitHub repositories using the `gh` CLI.\nYou ensure every repo has proper CI/CD workflows, labels, and\nbranch protection from day one.\n\n## Skill: Create Repository\n1. Load repo-definition with name, description, visibility\n2. Run `gh repo create <org>/<name> --public --description \"â€¦\"`\n3. Apply workflow-templates: write YAML files to `.github/workflows/`\n4. Apply label-set: create labels via `gh label create <name> --color <hex>`\n5. Apply branch-rules: configure via `gh api repos/{owner}/{repo}/branches/{branch}/protection`\n6. Update repo-definition status to \"configured\"\n\n## Skill: Apply Workflow Template\n1. Load workflow-template content\n2. Write to `.github/workflows/<filename>` in the repo\n3. Commit and push\n\n## Hard Rules\n- Every repo must have at least CI and release workflows\n- Branch protection on main is mandatory for public repos\n- Never delete repos â€” archive them\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-repos/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nrepos types list\nrepos types show <type-slug>\n```\n\n### CRUD\n\n```bash\nrepos create <type> -t \"Title\" -s \"status\"\nrepos list <type>\nrepos show <id>\nrepos update <id> --data '{ \"status\": \"active\" }'\nrepos delete <id>\nrepos search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nrepos stats\nrepos validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-releases",
              "name": "minions-releases",
              "id": "OC-0152",
              "version": "1.0.0",
              "description": "Release planning, version bumps, changelog generation, and publish targets",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-releases â€” Agent Skills\n\n## What is a Release in the Minions Context?\n\n```\na planned release with version target       â†’ ReleasePlan\na version bump event                        â†’ VersionBump\na registry or platform to publish to        â†’ PublishTarget\na confirmation of successful publish        â†’ ReleaseReceipt\n```\n\n---\n\n## MinionTypes\n\n```ts\n// release-plan\n{\n  type: \"release-plan\",\n  fields: {\n    repoDefinitionId: string,\n    version: string,                 // \"1.2.0\"\n    releaseType: \"major\" | \"minor\" | \"patch\" | \"prerelease\",\n    featureTaskIds: string[],        // agent-tasks included in this release\n    changelog: string,               // generated from task results\n    scheduledAt: datetime,\n    status: \"planned\" | \"ready\" | \"released\" | \"cancelled\",\n    createdAt: datetime\n  }\n}\n\n// version-bump â€” from/to versions with tag references\n// publish-target â€” npm, PyPI, GitHub Releases, etc.\n// release-receipt â€” confirmation per target with published URL\n```\n\n---\n\n## Relations\n\n```\nrelease-plan       --targets-->          repo-definition (minions-repos)\nrelease-plan       --includes-->         agent-task (minions-agent-tasks)\nrelease-plan       --bumps-->            version-bump\nrelease-plan       --published_to-->     publish-target\npublish-target     --confirmed_by-->     release-receipt\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-repos          â†’ releases scoped to repos\nminions-agent-tasks    â†’ completed tasks feed into release plans\nminions-approvals      â†’ release approval gates\nminions-scheduler      â†’ scheduled releases\nminions-comms          â†’ release notifications\n```\n\n---\n\n## Agent SKILLS for `minions-releases`\n\n```markdown\n# ReleaseAgent Skills\n\n## Context\nYou manage the release lifecycle. You plan releases from completed\nagent-task batches, generate changelogs, bump versions, tag, and publish.\n\n## Skill: Plan Release\n1. Collect merged agent-tasks since last release\n2. Determine version bump type from task types (feature=minor, fix=patch)\n3. Generate changelog from task-results\n4. Create release-plan Minion\n\n## Skill: Execute Release\n1. Bump version in package.json / pyproject.toml\n2. Create version-bump Minion\n3. Run `gh release create v<version> --generate-notes`\n4. For each publish-target: run publish command\n5. Create release-receipt Minions\n\n## Hard Rules\n- Releases require all included tasks to be merged\n- Version bumps follow semver strictly\n- Every release must have a changelog\n- Failed publishes create retry tasks\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-releases/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nreleases types list\nreleases types show <type-slug>\n```\n\n### CRUD\n\n```bash\nreleases create <type> -t \"Title\" -s \"status\"\nreleases list <type>\nreleases show <id>\nreleases update <id> --data '{ \"status\": \"active\" }'\nreleases delete <id>\nreleases search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nreleases stats\nreleases validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-qa-reports",
              "name": "minions-qa-reports",
              "id": "OC-0148",
              "version": "1.0.0",
              "description": "Aggregated test reports, health dashboards, trend analysis, and regression alerts",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-qa-reports â€” Agent Skills\n\n## What are QA Reports in the Minions Context?\n\n```\nan aggregated report across QA runs       â†’ QaReport\na health score per clawspace/toolbox      â†’ HealthScore\na detected quality regression             â†’ RegressionAlert\na trend snapshot over time                â†’ TrendSnapshot\n```\n\nReports are the primary output of ClawspaceQA â€” concise but detailed.\n\n---\n\n## MinionTypes\n\n```ts\n// qa-report â€” human-readable aggregation with recommendations\n{\n  type: \"qa-report\",\n  fields: {\n    name: string,\n    clawspace: string,              // or \"all\" for ecosystem-wide\n    periodStart: datetime,\n    periodEnd: datetime,\n    totalRuns: number,\n    overallPassRate: number,\n    failedSuites: string[],\n    regressions: string[],\n    recommendations: string[],\n    generatedAt: datetime\n  }\n}\n\n// health-score â€” A/B/C/D/F grading per target\n{\n  type: \"health-score\",\n  fields: {\n    targetType: \"clawspace\" | \"toolbox\" | \"ecosystem\",\n    targetName: string,\n    score: number,                  // 0-100\n    grade: \"A\" | \"B\" | \"C\" | \"D\" | \"F\",\n    breakdown: {                    // per-category scores\n      schema: number,\n      build: number,\n      cli: number,\n      structure: number,\n      consistency: number\n    },\n    previousScore: number,\n    trend: \"improving\" | \"stable\" | \"declining\",\n    computedAt: datetime\n  }\n}\n\n// regression-alert â€” automatic when scores drop\n// trend-snapshot â€” periodic captures for dashboards\n```\n\n### Report Format\n\nReports are structured for quick scanning:\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  ClawspaceQA Report â€” WiesnTracker          â”‚\nâ”‚  Period: 2026-02-20 â†’ 2026-02-23            â”‚\nâ”‚  Health: A (96/100) â–² +2                    â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  âœ… minions-venues        100%  (12/12)     â”‚\nâ”‚  âœ… minions-availability   92%  (11/12)     â”‚\nâ”‚  âš ï¸  minions-alerts        83%  (10/12)     â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  Failures:                                  â”‚\nâ”‚  â€¢ minions-alerts: CLI `stats` missing flag â”‚\nâ”‚  â€¢ minions-alerts: SKILLS.md outdated       â”‚\nâ”‚                                             â”‚\nâ”‚  Recommendations:                           â”‚\nâ”‚  â€¢ Update SKILLS.md to match TOML schema    â”‚\nâ”‚  â€¢ Add --json flag to CLI stats command     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## Relations\n\n```\nqa-report          --aggregates-->       qa-run (minions-qa-runs)\nqa-report          --produces-->         health-score\nqa-report          --detects-->          regression-alert\nhealth-score       --tracked_in-->       trend-snapshot\nregression-alert   --triggers-->         task (minions-tasks)\n```\n\n---\n\n## Agent SKILLS for `minions-qa-reports`\n\n```markdown\n# ReportAgent Skills\n\n## Context\nYou generate concise, actionable reports from QA run data. Your reports\nmust be scannable in seconds but contain all detail needed to act on\nfailures. You track health trends and surface regressions immediately.\n\n## Skill: Generate Report\n1. Aggregate qa-runs for the period and target\n2. Compute pass rate per suite and per clawspace\n3. Identify failed test cases and their error details\n4. Write concise recommendations for each failure\n5. Create qa-report Minion\n\n## Skill: Compute Health Score\n1. Weight category scores: schema (30%), build (25%), structure (20%), cli (15%), consistency (10%)\n2. Convert to letter grade (A=90+, B=80+, C=70+, D=60+, F=<60)\n3. Compare to previous score for trend detection\n4. Create health-score Minion\n\n## Skill: Detect Regressions\n1. Compare current health-score to previous\n2. If any category drops >10 points: create regression-alert\n3. If overall grade drops: create high-severity alert\n4. Create investigation task in minions-tasks\n\n## Skill: Ecosystem Report\n1. Generate per-clawspace reports\n2. Aggregate into ecosystem-wide summary\n3. Rank clawspaces by health: best to worst\n4. Surface systemic issues (e.g. \"5 clawspaces have outdated SKILLS.md\")\n\n## Hard Rules\n- Reports must be concise â€” no filler text\n- Every failure must have a recommendation\n- Health scores use consistent weighting across all targets\n- Regressions always create tasks â€” never ignored\n```\n\n\n---\n\n## CLI Reference\n\n```bash\npnpm add -g @minions-qa-reports/cli\n```\n\n### Commands\n\n```bash\nqa-reports types list\nqa-reports types show <type-slug>\nqa-reports create <type> -t \"Title\" -s \"status\"\nqa-reports list <type>\nqa-reports show <id>\nqa-reports update <id> --data '{ \"field\": \"value\" }'\nqa-reports delete <id>\nqa-reports search \"query\"\nqa-reports stats\n```"
            },
            {
              "slug": "minions-publishing",
              "name": "minions-publishing",
              "id": "OC-0147",
              "version": "1.0.0",
              "description": "Platform credentials, publish queue, and post receipts",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-publishing â€” Agent Skills\n\n## What is Publishing in the Minions Context?\n\nBefore defining types, it's worth being precise:\n\n```\na platform where articles are published    â†’ PublishTarget\nan article queued for publishing           â†’ PublishQueueEntry\nconfirmation of a successful publish       â†’ PublishReceipt\na cross-posted version of an article       â†’ CrossPost\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// publish-target\n{\n  type: \"publish-target\",\n  fields: {\n    blogId: string,\n    platform: \"wordpress\" | \"ghost\" | \"medium\" | \"hashnode\" | \"custom\",\n    name: string,\n    apiEndpoint: string,\n    authMethod: \"api-key\" | \"oauth\" | \"token\",\n    isActive: boolean,\n    lastPublishedAt: datetime\n  }\n}\n\n// publish-queue-entry\n{\n  type: \"publish-queue-entry\",\n  fields: {\n    articleId: string,\n    publishTargetId: string,\n    scheduledAt: datetime,\n    status: \"queued\" | \"publishing\" | \"published\" | \"failed\",\n    priority: \"urgent\" | \"normal\" | \"low\",\n    approvalRequestId: string\n  }\n}\n\n// publish-receipt\n{\n  type: \"publish-receipt\",\n  fields: {\n    articleId: string,\n    publishTargetId: string,\n    publishedAt: datetime,\n    publishedUrl: string,\n    platformPostId: string,\n    status: \"live\" | \"unlisted\" | \"removed\"\n  }\n}\n\n// cross-post\n{\n  type: \"cross-post\",\n  fields: {\n    articleId: string,\n    originalReceiptId: string,\n    targetPlatform: string,\n    publishedUrl: string,\n    publishedAt: datetime,\n    status: \"published\" | \"pending\" | \"failed\"\n  }\n}\n```\n\n---\n\n## Relations\n\n```\npublish-target       --receives-->       publish-queue-entry\npublish-queue-entry  --produces-->       publish-receipt\npublish-receipt      --spawns-->         cross-post\narticle (minions-articles) --queued_to--> publish-queue-entry\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-articles     â†’ approved articles enter the publish queue\nminions-blogs        â†’ publish targets are scoped to a blog\nminions-approvals    â†’ scheduled publishes may require approval\nminions-scheduler    â†’ publish times are driven by scheduler\nminions-comms        â†’ publish success/failure triggers notifications\n```\n\n---\n\n## Agent SKILLS for `minions-publishing`\n\n```markdown\n# PublisherAgent Skills\n\n## Context\nYou manage the publishing pipeline. You take approved articles,\nqueue them for publication, execute the publish, and track receipts.\n\n## Skill: Queue Article\n1. Receive approved article from WriterAgent\n2. Create publish-queue-entry with target and schedule\n3. If approval required, create approval-request first\n\n## Skill: Execute Publish\n1. At scheduled time: load queue entry and article content\n2. Call publish-target API to create post\n3. Create publish-receipt with URL and platform ID\n4. Update queue entry status to \"published\"\n\n## Skill: Cross-Post\n1. After primary publish: check cross-post rules\n2. For each secondary platform: create cross-post entry\n3. Publish with canonical URL pointing to primary\n\n## Hard Rules\n- Never publish without a publish-receipt\n- Always set canonical URL on cross-posts\n- Failed publishes create retry tasks, not silent failures\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-publishing/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\npublishing types list\npublishing types show <type-slug>\n```\n\n### CRUD\n\n```bash\npublishing create <type> -t \"Title\" -s \"status\"\npublishing list <type>\npublishing show <id>\npublishing update <id> --data '{ \"status\": \"active\" }'\npublishing delete <id>\npublishing search \"query\"\n```\n\n### Stats & Validation\n\n```bash\npublishing stats\npublishing validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-prospecting",
              "name": "minions-prospecting",
              "id": "OC-0146",
              "version": "1.0.0",
              "description": "Web search configs, prospect discovery rules, and lead scoring criteria",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-prospecting â€” Agent Skills\n\n## What is a Prospecting in the Minions Context?\n\n```\na web search configuration               â†’ SearchConfig\na rule for qualifying prospects           â†’ DiscoveryRule\ncriteria for scoring leads                â†’ ScoringCriteria\n```\n\n## MinionTypes\n```ts\n// search-config â€” territory, query, search engine, industry, max results\n// discovery-rule â€” condition, score contribution\n// scoring-criteria â€” field, weight, direction\n```\n\n## Agent SKILLS\n```markdown\n# ProspectAgent Skills\n## Skill: Run Search â€” execute web searches per territory + industry\n## Skill: Qualify Prospects â€” apply discovery rules and scoring\n## Hard Rules â€” never contact a prospect without qualification scoring\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-prospecting/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nprospecting types list\nprospecting types show <type-slug>\n```\n\n### CRUD\n\n```bash\nprospecting create <type> -t \"Title\" -s \"status\"\nprospecting list <type>\nprospecting show <id>\nprospecting update <id> --data '{ \"status\": \"active\" }'\nprospecting delete <id>\nprospecting search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nprospecting stats\nprospecting validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-proposals",
              "name": "minions-proposals",
              "id": "OC-0145",
              "version": "1.0.0",
              "description": "Proposal drafts, answer sets, scoring, and prompt version references",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-proposals â€” Agent Skills\n\n## What is a Proposal in the Minions Context?\n\nA \"proposal\" sounds simple but covers several distinct concepts that need separating:\n\n```\na reusable scaffold for writing proposals    â†’ ProposalTemplate\na generated proposal for a specific job      â†’ ProposalDraft\na previous version before revision           â†’ ProposalRevision\nanswers to platform screening questions      â†’ AnswerSet\nhow good the proposal is                     â†’ ProposalScore\nwhat gets sent to the platform               â†’ SubmissionPackage\ndid it work                                  â†’ ProposalOutcome\n```\n\n---\n\n## MinionTypes\n\n**Templates**\n```ts\n// proposal-template\n{\n  type: \"proposal-template\",\n  fields: {\n    name: string,\n    platform: \"upwork\" | \"freelancer\" | \"malt\" | \"contra\" | \"linkedin\" | \"other\",\n    style: \"concise\" | \"detailed\" | \"technical\" | \"consultative\",\n    body: string,               // scaffold with {{placeholders}}\n    placeholders: string[],     // [\"{{client_name}}\", \"{{key_skill}}\", \"{{relevant_project}}\"]\n    promptVersionRef: string,   // pinned version from minions-prompts\n    isActive: boolean,\n    createdAt: datetime,\n    updatedAt: datetime\n  }\n}\n```\n\n**Drafts**\n```ts\n// proposal-draft\n{\n  type: \"proposal-draft\",\n  fields: {\n    jobId: string,              // ref to job-posting\n    templateId: string,         // ref to proposal-template\n    matchScoreId: string,       // ref to match-score used to inform writing\n    version: number,\n    body: string,\n    status: \"draft\" | \"revised\" | \"approved\" | \"submitted\" | \"archived\",\n    promptVersionRef: string,\n    createdAt: datetime,\n    revisedAt: datetime,\n    createdBy: string           // agent id\n  }\n}\n\n// proposal-revision\n{\n  type: \"proposal-revision\",\n  fields: {\n    proposalId: string,\n    version: number,\n    body: string,\n    savedAt: datetime,\n    savedBy: string,            // agent or human id\n    changeReason: string        // \"compliance check failed\", \"human edit\", \"score too low\"\n  }\n}\n```\n\n**Screening Questions**\n```ts\n// answer-set\n{\n  type: \"answer-set\",\n  fields: {\n    proposalId: string,\n    jobId: string,\n    questions: string[],        // raw questions extracted from job posting\n    answers: string[],          // generated answers, index-matched to questions\n    generatedAt: datetime,\n    reviewedAt: datetime,\n    status: \"draft\" | \"approved\"\n  }\n}\n```\n\n**Scoring**\n```ts\n// proposal-score\n{\n  type: \"proposal-score\",\n  fields: {\n    proposalId: string,\n    version: number,\n    clarityScore: number,       // 0-1\n    relevanceScore: number,     // 0-1: how well it addresses the specific job\n    specificityScore: number,   // 0-1: concrete examples vs generic claims\n    complianceScore: number,    // 0-1: no fabricated claims, ToS safe\n    overallScore: number,       // weighted composite\n    flags: string[],            // [\"unverified claim detected\", \"too generic\"]\n    scoredAt: datetime,\n    scoredBy: string            // agent id\n  }\n}\n```\n\n**Submission**\n```ts\n// submission-package\n{\n  type: \"submission-package\",\n  fields: {\n    proposalId: string,\n    applicationId: string,\n    proposalBody: string,       // final resolved body, no placeholders\n    answerSetId: string,\n    resumeDocumentId: string,\n    caseStudyIds: string[],     // ref to portfolio-item or document\n    attachmentIds: string[],\n    assembledAt: datetime,\n    approvalRequestId: string,  // must be approved before submitting\n    status: \"assembling\" | \"ready\" | \"submitted\"\n  }\n}\n```\n\n**Outcome**\n```ts\n// proposal-outcome\n{\n  type: \"proposal-outcome\",\n  fields: {\n    proposalId: string,\n    applicationId: string,\n    result: \"no-reply\" | \"rejected\" | \"interview\" | \"won\",\n    clientFeedback: string,\n    followUpSent: boolean,\n    resolvedAt: datetime,\n    lessons: string             // fed back to memory and eval layers\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nproposal-template   --used_by-->          proposal-draft\nproposal-draft      --informed_by-->      match-score\nproposal-draft      --version_of-->       proposal-revision\nproposal-draft      --has_answers-->      answer-set\nproposal-draft      --scored_by-->        proposal-score\nproposal-draft      --packaged_in-->      submission-package\nsubmission-package  --requires-->         approval-request\nproposal-draft      --produced-->         proposal-outcome\nproposal-outcome    --feeds-->            memory-item\nproposal-outcome    --feeds-->            eval-metric\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-jobs          â†’ proposal-draft reads job-posting and job-signal\n                        to understand what the client actually wants\n\nminions-profile       â†’ ProposalWriter pulls bio-claim and portfolio-item\n                        to populate placeholders honestly\n\nminions-match         â†’ match-score informs which portfolio items to lead with\n                        and what skills to emphasize\n\nminions-prompts       â†’ promptVersionRef pins the exact prompt version used\n                        enabling A/B comparison across proposals\n\nminions-approvals     â†’ submission-package cannot proceed without an\n                        approval-request with decision \"approved\"\n\nminions-applications  â†’ on approval, ApplicationAgent consumes the\n                        submission-package and creates the application record\n\nminions-memory        â†’ proposal-outcome.lessons written to memory-item\n                        so future proposals improve over time\n\nminions-evaluations   â†’ proposal-score feeds eval-metric for benchmarking\n                        which templates and prompt versions perform best\n```\n\n---\n\n## Agent SKILLS for `minions-proposals`\n\n```markdown\n# ProposalAgent Skills\n\n## Context\nYou are the ProposalAgent. You own the minions-proposals toolbox.\nYou read from minions-jobs, minions-profile, and minions-match.\nYou write only to minions-proposals.\nEvery factual claim in a proposal must trace to a verified bio-claim\nor portfolio-item. You never fabricate.\n\n## Skill: Select Template\n1. Load the job-posting and its job-signal Minions\n2. Identify the platform and job style (technical, creative, consulting)\n3. Query proposal-template Minions filtered by platform and style\n4. Select the active template with the highest historical win rate\n   (derived from proposal-outcome Minions linked to this template)\n5. Pin the promptVersionRef from the selected template\n\n## Skill: Draft Proposal\n1. Load the match-score for this job â€” note which skills scored highest\n   and which portfolio items were flagged as most relevant\n2. Load bio-claim Minions (verified only) and portfolio-item Minions\n   whose relevantSkillTags overlap with job-signal.mustHaveSkills\n3. Resolve all {{placeholders}} in the template body using only\n   verified Minion data â€” never infer or invent\n4. Generate answer-set for any screening questions extracted\n   from the job-posting description\n5. Create proposal-draft Minion with status \"draft\"\n\n## Skill: Score Draft\n1. Evaluate the draft on four dimensions:\n   - Clarity: is it easy to read and structured well?\n   - Relevance: does it directly address the job-signal signals?\n   - Specificity: does it cite concrete projects and outcomes?\n   - Compliance: are all claims traceable to verified Minion data?\n2. Create a proposal-score Minion with scores and any flags\n3. If overallScore < 0.7 or any flag is present â†’ trigger Skill: Revise\n4. If overallScore >= 0.7 and no flags â†’ trigger Skill: Assemble Package\n\n## Skill: Revise Draft\n1. Load the proposal-score flags\n2. Save current body as a proposal-revision Minion before changing anything\n3. Address each flag specifically:\n   - \"too generic\" â†’ replace with a concrete portfolio-item outcome\n   - \"unverified claim\" â†’ remove or replace with a verified bio-claim\n   - \"low relevance\" â†’ reorder to lead with must-have skill matches\n4. Re-score. Maximum 3 revision cycles before escalating to human review.\n\n## Skill: Assemble Submission Package\n1. Create submission-package Minion referencing:\n   - approved proposal-draft\n   - answer-set\n   - resume document (latest from minions-documents)\n   - top 2 case study documents matched to this job\n2. Set status to \"ready\"\n3. Create approval-request Minion in minions-approvals with full\n   package summary and diff vs any previous application to same client\n\n## Skill: Record Outcome\n1. When ApplicationAgent reports a result, create proposal-outcome Minion\n2. Extract lessons â€” what worked, what did not, client feedback if any\n3. Write a memory-item to minions-memory scoped to this client and platform\n4. Write an eval-metric to minions-evaluations linked to the prompt version\n   and template used â€” this feeds the A/B improvement loop\n\n## Hard Rules\n- Never populate a placeholder with unverified data\n- Never submit a package without a linked approval-request at status \"approved\"\n- Always save a proposal-revision before any edit to an existing draft\n- Maximum 10 proposal-drafts created per day across all jobs\n- If revision cycles exceed 3, set draft status to \"needs-human-review\"\n  and notify via minions-comms\n```\n\n---\n\nThe `lessons` field on `proposal-outcome` flowing into both `minions-memory` and `minions-evaluations` is the key feedback loop â€” over time the ProposalAgent builds a empirical picture of which templates, prompt versions, and portfolio emphasis patterns actually win work, and that knowledge persists across sessions.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-proposals/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\nproposals types list\n\n# Show detailed schema for a specific type\nproposals types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\nproposals create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\nproposals create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\nproposals list <type>\n\n# Show a specific Minion\nproposals show <id>\n\n# Search by text\nproposals search \"query\"\n\n# Output as JSON (for piping)\nproposals list --json\nproposals show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\nproposals update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\nproposals delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\nproposals stats\n\n# Validate a Minion JSON file against its schema\nproposals validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-pipeline",
              "name": "minions-pipeline",
              "id": "OC-0142",
              "version": "1.0.0",
              "description": "Funnel stage tracking across the full job search lifecycle",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-pipeline â€” Agent Skills\n\n## What is a Pipeline in the Minions Context?\n\nA \"pipeline\" could mean several things, so it's worth being precise:\n\n```\nthe stages a job opportunity moves through    â†’ PipelineStage\na job sitting at a specific stage             â†’ PipelineEntry\nthe movement between stages                   â†’ PipelineTransition\nthe overall health of the funnel              â†’ FunnelMetric\na rule that moves things automatically        â†’ PipelineRule\na goal or target for the funnel               â†’ PipelineGoal\n```\n\nThe pipeline is the **single source of truth for where every opportunity stands**. Every other toolbox produces data; the pipeline consumes it and tells you what's happening across your entire job search at a glance.\n\n---\n\n## MinionTypes\n\n**Stages**\n```ts\n// pipeline-stage\n{\n  type: \"pipeline-stage\",\n  fields: {\n    name: string,                // \"Discovered\", \"Shortlisted\", \"Applied\", \"Interviewing\", \"Won\", \"Lost\"\n    description: string,\n    order: number,               // position in the funnel, 1 = earliest\n    color: string,\n    isTerminal: boolean,         // true = Won, Lost, Cancelled â€” no further movement\n    isDefault: boolean,          // the stage new entries land in automatically\n    autoAdvanceCondition: string // e.g. \"approval-request.decision == approved\"\n  }\n}\n```\n\n**Entries**\n```ts\n// pipeline-entry\n{\n  type: \"pipeline-entry\",\n  fields: {\n    jobId: string,\n    applicationId: string,       // null until application exists\n    stageId: string,\n    enteredStageAt: datetime,\n    assignedTo: string,          // agent or human id\n    priority: \"critical\" | \"high\" | \"medium\" | \"low\",\n    notes: string,\n    isStale: boolean,            // true if no movement for N days\n    staleSince: datetime\n  }\n}\n\n// pipeline-transition\n{\n  type: \"pipeline-transition\",\n  fields: {\n    entryId: string,\n    fromStageId: string,\n    toStageId: string,\n    transitionedAt: datetime,\n    transitionedBy: string,      // agent id or human\n    trigger: \"manual\" | \"auto\" | \"agent\",\n    reason: string\n  }\n}\n```\n\n**Rules & Automation**\n```ts\n// pipeline-rule\n{\n  type: \"pipeline-rule\",\n  fields: {\n    name: string,\n    description: string,\n    triggerEvent: string,        // \"application.submitted\", \"message.received\", \"approval.approved\"\n    fromStageId: string,         // null = applies from any stage\n    toStageId: string,\n    condition: string,           // optional additional condition\n    isActive: boolean,\n    priority: number             // order of evaluation if multiple rules match\n  }\n}\n```\n\n**Goals & Targets**\n```ts\n// pipeline-goal\n{\n  type: \"pipeline-goal\",\n  fields: {\n    name: string,                // \"10 applications per week\"\n    metric: string,              // \"totalApplied\", \"totalWon\", \"winRate\"\n    targetValue: number,\n    period: \"daily\" | \"weekly\" | \"monthly\",\n    startDate: datetime,\n    currentValue: number,\n    status: \"on-track\" | \"at-risk\" | \"missed\" | \"achieved\"\n  }\n}\n```\n\n**Metrics & Reporting**\n```ts\n// funnel-metric\n{\n  type: \"funnel-metric\",\n  fields: {\n    periodStart: datetime,\n    periodEnd: datetime,\n    totalDiscovered: number,\n    totalShortlisted: number,\n    totalApplied: number,\n    totalReplied: number,\n    totalInterviewed: number,\n    totalWon: number,\n    discoveryToApplyRate: number,    // percentage\n    applyToReplyRate: number,\n    replyToWinRate: number,\n    averageTimeToApply: number,      // hours\n    averageTimeToReply: number,      // hours\n    averageDealValue: number\n  }\n}\n\n// stage-metric\n{\n  type: \"stage-metric\",\n  fields: {\n    stageId: string,\n    periodStart: datetime,\n    periodEnd: datetime,\n    totalEntered: number,\n    totalExited: number,\n    totalStale: number,\n    averageTimeInStage: number,      // hours\n    conversionRate: number           // % that advanced to next stage\n  }\n}\n\n// pipeline-snapshot\n{\n  type: \"pipeline-snapshot\",\n  fields: {\n    takenAt: datetime,\n    totalActive: number,\n    byStage: string,                 // JSON map of stageId â†’ count\n    totalStale: number,\n    totalWonThisPeriod: number,\n    totalLostThisPeriod: number,\n    goalsStatus: string              // JSON map of goalId â†’ status\n  }\n}\n```\n\n---\n\n## Relations\n\n```\npipeline-stage      --orders-->              pipeline-stage (next)\npipeline-entry      --sits_in-->             pipeline-stage\npipeline-entry      --references-->          job-posting (minions-jobs)\npipeline-entry      --references-->          application (minions-applications)\npipeline-entry      --has_transition-->      pipeline-transition\npipeline-transition --triggered_by-->        pipeline-rule\npipeline-rule       --moves_to-->            pipeline-stage\npipeline-goal       --measures-->            funnel-metric\npipeline-snapshot   --captures-->            pipeline-entry (all active)\nstage-metric        --describes-->           pipeline-stage\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\nThe pipeline is the **read-aggregation layer** â€” it doesn't own much data itself, it tracks the position and movement of data owned by other toolboxes:\n\n```\nminions-jobs          â†’ creates pipeline-entry when job-posting is discovered\n                        (entry lands in \"Discovered\" stage automatically)\n\nminions-match         â†’ triggers transition from \"Discovered\" â†’ \"Shortlisted\"\n                        when match-score exceeds threshold\n\nminions-proposals     â†’ transition from \"Shortlisted\" â†’ \"Proposal Ready\"\n                        when proposal-draft status = \"approved\"\n\nminions-approvals     â†’ transition from \"Proposal Ready\" â†’ \"Applied\"\n                        when approval-request.decision = \"approved\"\n\nminions-applications  â†’ updates pipeline-entry.applicationId on submission\n                        transition to \"Applied\" confirmed by platform receipt\n\nminions-comms         â†’ transition from \"Applied\" â†’ \"Replied\"\n                        when inbound message received on thread\n\nminions-contracts     â†’ transition to \"Won\"\n                        when contract.status = \"signed\"\n\nminions-tasks         â†’ stale pipeline entries generate tasks\n                        \"Follow up on application to X\"\n```\n\n---\n\n## Default Stage Sequence\n\n```\nDiscovered â†’ Shortlisted â†’ Proposal Ready â†’ Applied â†’ Replied â†’ Interviewing â†’ Won\n                                                                              â†’ Lost\n                                                  â†’ No Reply (stale after 7d) â†’ Lost\n```\n\nEach arrow is a `pipeline-rule` â€” pre-shipped with the toolbox as defaults, overridable by the user.\n\n---\n\n## Agent SKILLS for `minions-pipeline`\n\n```markdown\n# PipelineAgent Skills\n\n## Context\nYou manage the full lifecycle view of every job opportunity. You do not\ndiscover jobs, write proposals, or submit applications â€” those agents report\nto you via transitions. Your job is to maintain an accurate, up-to-date\npicture of where everything stands and surface what needs attention.\n\n## Skill: Initialize Entry\n- When JobScoutAgent creates a new `job-posting`, create a `pipeline-entry`\n  Minion with stageId pointing to the \"Discovered\" stage\n- Set assignedTo: OrchestratorAgent\n- Set isStale: false\n\n## Skill: Advance Stage\n- Listen for trigger events from other agents:\n  - \"match-score.created\" + overallScore > threshold â†’ advance to \"Shortlisted\"\n  - \"proposal-draft.status = approved\" â†’ advance to \"Proposal Ready\"\n  - \"approval-request.decision = approved\" â†’ advance to \"Applied\"\n  - \"message.isInbound = true\" on related thread â†’ advance to \"Replied\"\n  - \"contract.status = signed\" â†’ advance to \"Won\"\n- For each advance: create a `pipeline-transition` Minion with trigger, reason,\n  and transitionedBy set to the triggering agent id\n\n## Skill: Detect Stale Entries\n- Run daily: check all active pipeline-entry Minions\n- If enteredStageAt is more than the stage's stale threshold with no transition:\n  - Set isStale: true, staleSince: now\n  - Create a task in minions-tasks: \"Follow up on [job title]\"\n  - Assign task to OrchestratorAgent\n  - Notify via minions-comms\n\n## Skill: Apply Pipeline Rules\n- On any state change event, evaluate all active `pipeline-rule` Minions\n  in priority order\n- If triggerEvent matches and condition passes: execute the transition\n- Log which rule triggered the transition in pipeline-transition.reason\n\n## Skill: Track Goals\n- On each pipeline-snapshot: compare current metrics against all\n  active `pipeline-goal` Minions\n- Update goal.currentValue and goal.status accordingly\n- If status changes to \"at-risk\" or \"missed\": notify OrchestratorAgent\n\n## Skill: Generate Snapshot\n- Run every 24 hours: create a `pipeline-snapshot` Minion\n  - Count active entries by stage\n  - Count stale entries\n  - Count won/lost in the last 24h\n  - Evaluate all goal statuses\n- Send snapshot summary to OrchestratorAgent for daily briefing\n\n## Skill: Generate Funnel Metrics\n- Run weekly: create a `funnel-metric` Minion covering the past 7 days\n- Compute conversion rates between each stage pair\n- Compute average time in each stage via `stage-metric` Minions\n- Surface the weakest conversion rate to OrchestratorAgent\n  with a suggested action\n\n## Hard Rules\n- Never move an entry backward in the funnel without a manual human instruction\n- Never mark an entry as \"Won\" without a signed contract or explicit human confirmation\n- Never delete a pipeline-entry â€” set terminal stage instead so history is preserved\n- Always create a pipeline-transition record for every stage change, even manual ones\n```\n\n---\n\nThe key insight for the pipeline is that it **owns no domain data** â€” it only tracks position. This makes it the cleanest aggregation point in the system, and the `funnel-metric` Minion with conversion rates between stages becomes your primary feedback signal for improving every other agent over time. If `applyToReplyRate` is low, ProposalAgent needs better prompts. If `discoveryToApplyRate` is low, MatchAgent's thresholds are too strict.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-pipeline/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\npipeline types list\n\n# Show detailed schema for a specific type\npipeline types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\npipeline create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\npipeline create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\npipeline list <type>\n\n# Show a specific Minion\npipeline show <id>\n\n# Search by text\npipeline search \"query\"\n\n# Output as JSON (for piping)\npipeline list --json\npipeline show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\npipeline update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\npipeline delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\npipeline stats\n\n# Validate a Minion JSON file against its schema\npipeline validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-outreach",
              "name": "minions-outreach",
              "id": "OC-0141",
              "version": "1.0.0",
              "description": "Email templates, drip sequences, personalization rules, and send schedules",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-outreach â€” Agent Skills\n\n## What is a Outreach in the Minions Context?\n\n```\na reusable email template                 â†’ EmailTemplate\na multi-step email sequence               â†’ DripSequence\na record of a sent email                  â†’ OutreachSend\n```\n\n## MinionTypes\n```ts\n// email-template â€” subject, body, intent, personalization fields\n// drip-sequence â€” steps with delays, target segment\n// outreach-send â€” lead, template, step index, sent/opened/clicked timestamps\n```\n\n## Agent SKILLS\n```markdown\n# OutreachAgent Skills\n## Skill: Create Drip Sequence â€” define multi-step personalized emails\n## Skill: Execute Send â€” personalize and send per schedule\n## Hard Rules â€” respect cooldowns, never send duplicate emails\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-outreach/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\noutreach types list\noutreach types show <type-slug>\n```\n\n### CRUD\n\n```bash\noutreach create <type> -t \"Title\" -s \"status\"\noutreach list <type>\noutreach show <id>\noutreach update <id> --data '{ \"status\": \"active\" }'\noutreach delete <id>\noutreach search \"query\"\n```\n\n### Stats & Validation\n\n```bash\noutreach stats\noutreach validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-oss-quality",
              "name": "minions-oss-quality",
              "id": "OC-0139",
              "version": "1.0.0",
              "description": "Linting rules, test coverage targets, usability checklists, and release gates",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-oss-quality â€” Agent Skills\n\n## What is an Quality in the Minions Context?\n\n```\na quality check that gates releases       â†’ QualityGate\na quality assessment snapshot             â†’ QualityReport\n```\n\n## MinionTypes\n```ts\n// quality-gate â€” name, type (lint/test/usability), threshold, current value, passing\n// quality-report â€” test coverage, lint errors, build status, usability score, grade\n```\n\n## Relations\n```\nquality-gate      --scoped_to-->         oss-project (minions-oss-projects)\nquality-report    --assesses-->          oss-project\nquality-gate      --blocks-->            release (minions-oss-releases)\n```\n\n## Agent SKILLS\n```markdown\n# QualityAgent Skills\n## Skill: Run Quality Checks â€” lint, test, build, usability\n## Skill: Generate Report â€” aggregate into quality-report\n## Hard Rules â€” releases are blocked if any quality-gate fails\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-oss-quality/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\noss-quality types list\noss-quality types show <type-slug>\n```\n\n### CRUD\n\n```bash\noss-quality create <type> -t \"Title\" -s \"status\"\noss-quality list <type>\noss-quality show <id>\noss-quality update <id> --data '{ \"status\": \"active\" }'\noss-quality delete <id>\noss-quality search \"query\"\n```\n\n### Stats & Validation\n\n```bash\noss-quality stats\noss-quality validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-oss-projects",
              "name": "minions-oss-projects",
              "id": "OC-0138",
              "version": "1.0.0",
              "description": "Project definitions, repos, version history, and health status",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-oss-projects â€” Agent Skills\n\n## What is an OSS Project in the Minions Context?\n\n```\nan active open-source project             â†’ OssProject\na periodic health snapshot                 â†’ ProjectMetric\n```\n\n## MinionTypes\n```ts\n// oss-project â€” name, repo URL, package name, version, health, stars, downloads\n// project-metric â€” periodic snapshot of stars, forks, issues, downloads\n```\n\n## Relations\n```\noss-project       --born_from-->         oss-idea (minions-oss-ideas)\noss-project       --has_feature-->       feature (minions-oss-features)\noss-project       --has_release-->       release (minions-oss-releases)\noss-project       --tracked_by-->        project-metric\n```\n\n## Agent SKILLS\n```markdown\n# ProjectAgent Skills\n## Skill: Initialize Project â€” create repo, scaffold, first commit\n## Skill: Track Health â€” periodic project-metric snapshots\n## Hard Rules â€” every project must trace to an oss-idea\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-oss-projects/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\noss-projects types list\noss-projects types show <type-slug>\n```\n\n### CRUD\n\n```bash\noss-projects create <type> -t \"Title\" -s \"status\"\noss-projects list <type>\noss-projects show <id>\noss-projects update <id> --data '{ \"status\": \"active\" }'\noss-projects delete <id>\noss-projects search \"query\"\n```\n\n### Stats & Validation\n\n```bash\noss-projects stats\noss-projects validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-orders",
              "name": "minions-orders",
              "id": "OC-0134",
              "version": "1.0.0",
              "description": "Order records, service selections, onboarding checklists, and invoices",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-orders â€” Agent Skills\n\n## What is a Order in the Minions Context?\n\n```\nan order placed by a client               â†’ Order\nonboarding steps for a new client         â†’ OnboardingChecklist\nan invoice for an order                   â†’ OrderInvoice\n```\n\n## MinionTypes\n```ts\n// order â€” lead, deal, services, total amount, status\n// onboarding-checklist â€” steps, current step, status\n// order-invoice â€” invoice number, amount, issued/due/paid dates, status\n```\n\n## Agent SKILLS\n```markdown\n# OrderAgent Skills\n## Skill: Process Order â€” create order, initiate onboarding\n## Skill: Generate Invoice â€” create invoice from order\n## Hard Rules â€” every order must have an onboarding checklist\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-orders/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\norders types list\norders types show <type-slug>\n```\n\n### CRUD\n\n```bash\norders create <type> -t \"Title\" -s \"status\"\norders list <type>\norders show <id>\norders update <id> --data '{ \"status\": \"active\" }'\norders delete <id>\norders search \"query\"\n```\n\n### Stats & Validation\n\n```bash\norders stats\norders validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-orchestration",
              "name": "minions-orchestration",
              "id": "OC-0133",
              "version": "1.0.0",
              "description": "Clawspace registry, toolbox-to-agent mappings, and fleet configuration",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-orchestration â€” Agent Skills\n\n## What is Orchestration in the Minions Context?\n\nBefore defining types, it's worth being precise. \"Orchestration\" can mean several different things:\n\n```\nthe registry of all clawspaces                â†’ Clawspace\nthe mapping of toolboxes to agents            â†’ ToolboxRegistration\nthe fleet composition for a clawspace         â†’ AgentFleetConfig\nthe act of coordinating agent execution       â†’ handled by OrchestratorAgent + minions-workflows\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// clawspace\n{\n  type: \"clawspace\",\n  fields: {\n    name: string,                    // \"OpportunityHunter\", \"WiesnTracker\", etc.\n    description: string,\n    status: \"active\" | \"paused\" | \"archived\",\n    toolboxIds: string[],            // all toolbox ids in this clawspace\n    agentIds: string[],              // all agent ids in this clawspace\n    orchestratorAgentId: string,     // the orchestrator for this clawspace\n    createdAt: datetime\n  }\n}\n\n// toolbox-registration\n{\n  type: \"toolbox-registration\",\n  fields: {\n    toolboxId: string,\n    toolboxName: string,             // \"minions-jobs\", \"minions-tasks\", etc.\n    agentId: string,                 // the agent that owns this toolbox\n    agentName: string,\n    role: \"owner\" | \"reader\" | \"shared\",\n    clawspaceId: string,\n    registeredAt: datetime\n  }\n}\n\n// agent-fleet-config\n{\n  type: \"agent-fleet-config\",\n  fields: {\n    clawspaceId: string,\n    orchestratorAgentId: string,\n    workerAgentIds: string[],\n    sharedToolboxIds: string[],      // toolboxes available to all agents\n    status: \"active\" | \"paused\",\n    lastUpdatedAt: datetime\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nclawspace              --contains-->          toolbox-registration\nclawspace              --governed_by-->        agent-fleet-config\ntoolbox-registration   --maps-->              agent-definition (minions-agents)\nagent-fleet-config     --references-->        agent-definition (minions-agents)\nagent-fleet-config     --includes-->          toolbox (any toolbox)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`minions-orchestration` is the meta-layer â€” it knows about everything but owns nothing domain-specific:\n\n```\nminions-agents         â†’ agent-fleet-config references agent-definitions by id\nminions-workflows      â†’ workflow-definitions are scoped to a clawspaceId\nminions-tasks          â†’ clawspace health checks may spawn tasks\nminions-comms          â†’ clawspace status changes trigger notifications\nminions-approvals      â†’ pausing or archiving a clawspace may require approval\n```\n\nThe key design rule: **orchestration is about composition, not execution**. It registers what exists and how it's wired. Actual execution flows through `minions-workflows`.\n\n---\n\n## Agent SKILLS for `minions-orchestration`\n\n```markdown\n# OrchestrationAgent Skills\n\n## Context\nYou manage the clawspace registry and fleet composition. You know which\ntoolboxes exist, which agents own them, and how each clawspace is wired.\nYou do not execute domain logic â€” you maintain the map.\n\n## Skill: Register Clawspace\n1. Create a `clawspace` Minion with name, description, status \"active\"\n2. For each toolbox in the clawspace, create a `toolbox-registration` Minion\n3. Create an `agent-fleet-config` Minion with orchestrator and worker agent ids\n4. Emit \"clawspace-registered\" to all relevant agents\n\n## Skill: Update Fleet Composition\n1. On receiving \"add-agent\" or \"remove-agent\" instruction:\n   - Update the `agent-fleet-config` workerAgentIds\n   - Create or archive the relevant `toolbox-registration`\n2. Log the change as a task-history-entry in minions-tasks\n\n## Skill: Health Check\n1. On schedule: iterate all active clawspaces\n2. For each: verify all registered agents are healthy (via minions-agents)\n3. If any agent is degraded or unresponsive:\n   - Flag the clawspace status\n   - Notify via minions-comms\n   - Create a task in minions-tasks to investigate\n\n## Skill: Archive Clawspace\n1. Set clawspace status to \"archived\"\n2. Set agent-fleet-config status to \"paused\"\n3. Do not delete any data â€” only change status\n4. Require approval via minions-approvals before archiving\n\n## Hard Rules\n- Never delete a clawspace â€” only archive\n- Every toolbox must have exactly one owning agent via toolbox-registration\n- Fleet config changes always require logging\n- Shared toolbox registrations use role: \"shared\"\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-orchestration/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\norchestration types list\norchestration types show <type-slug>\n```\n\n### CRUD\n\n```bash\norchestration create <type> -t \"Title\" -s \"status\"\norchestration list <type>\norchestration show <id>\norchestration update <id> --data '{ \"status\": \"active\" }'\norchestration delete <id>\norchestration search \"query\"\n```\n\n### Stats & Validation\n\n```bash\norchestration stats\norchestration validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-memory",
              "name": "minions-memory",
              "id": "OC-0130",
              "version": "1.0.0",
              "description": "Persistent cross-session memory, recalled facts, and agent knowledge base",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-memory â€” Agent Skills\n\n## What is Memory in the Minions Context?\n\nMemory is one of the most overloaded words in AI systems. Before defining types, it's worth being precise about what kind of memory we're talking about:\n\n```\nsomething recalled from a past session      â†’ memory-item\na compressed summary of a past session      â†’ memory-summary\na way to find memory quickly                â†’ memory-index\nsomething learned from an outcome           â†’ memory-lesson\na boundary on what an agent can remember    â†’ memory-scope\na deliberate instruction to forget          â†’ memory-expiry\n```\n\nThe key distinction from a simple database is **relevance decay** â€” memory in an agent system is not just stored, it has confidence, freshness, and scope. A fact remembered with high confidence last week is worth more than one recalled vaguely six months ago.\n\n---\n\n## MinionTypes\n\n**Core Recall**\n```ts\n// memory-item\n{\n  type: \"memory-item\",\n  fields: {\n    agentId: string,           // which agent owns this memory\n    scope: \"private\"           // only this agent\n          | \"fleet\"            // all agents in this system\n          | \"session\",         // only this run\n    key: string,               // semantic label: \"client:upwork:xyz:prefers_short_proposals\"\n    value: string,             // the actual remembered content\n    confidence: number,        // 0.0 - 1.0, decays over time\n    sourceRefType: string,     // what produced this memory\n    sourceRefId: string,       // e.g. a task-outcome, agent-run, thread\n    createdAt: datetime,\n    lastAccessedAt: datetime,\n    lastReinforcedAt: datetime, // confidence resets when re-confirmed\n    expiresAt: datetime         // null = permanent\n  }\n}\n\n// memory-summary\n{\n  type: \"memory-summary\",\n  fields: {\n    agentId: string,\n    sessionId: string,         // which run/conversation this summarizes\n    summary: string,           // compressed narrative of what happened\n    keyFacts: string,          // extracted bullet facts for quick recall\n    emotionalContext: string,  // tone of interaction if relevant (client was frustrated, etc.)\n    createdAt: datetime,\n    tokenCount: number         // helps agents decide how much context budget to use\n  }\n}\n```\n\n**Indexing & Retrieval**\n```ts\n// memory-index\n{\n  type: \"memory-index\",\n  fields: {\n    memoryId: string,\n    memoryType: \"memory-item\" | \"memory-summary\" | \"memory-lesson\",\n    keywords: string,          // for keyword search\n    embedding: string,         // vector for semantic search\n    indexedAt: datetime\n  }\n}\n\n// memory-query\n{\n  type: \"memory-query\",\n  fields: {\n    agentId: string,\n    query: string,             // what the agent was looking for\n    strategy: \"keyword\"\n             | \"semantic\"\n             | \"hybrid\",\n    resultsFound: number,\n    topResultIds: string,\n    executedAt: datetime,\n    usedInRunId: string        // which agent-run triggered this query\n  }\n}\n```\n\n**Learning Loop**\n```ts\n// memory-lesson\n{\n  type: \"memory-lesson\",\n  fields: {\n    sourceType: \"task-outcome\"\n               | \"proposal-score\"\n               | \"application-event\"\n               | \"eval-metric\",\n    sourceId: string,\n    lesson: string,            // \"Short proposals on Upwork perform better than long ones\"\n    domain: string,            // \"proposals\", \"client-comms\", \"job-scoring\"\n    confidence: number,\n    reinforcedCount: number,   // how many times this lesson has been confirmed\n    createdAt: datetime,\n    lastReinforcedAt: datetime\n  }\n}\n\n// memory-reinforcement\n{\n  type: \"memory-reinforcement\",\n  fields: {\n    memoryId: string,\n    memoryType: \"memory-item\" | \"memory-lesson\",\n    reinforcedBy: string,      // agent-run or task-outcome id\n    previousConfidence: number,\n    newConfidence: number,\n    reinforcedAt: datetime,\n    reason: string\n  }\n}\n```\n\n**Boundaries & Hygiene**\n```ts\n// memory-scope-policy\n{\n  type: \"memory-scope-policy\",\n  fields: {\n    agentId: string,\n    allowedScopes: string,     // which scopes this agent can read/write\n    maxItemsPerScope: number,\n    defaultExpiry: string,     // e.g. \"30d\", \"never\"\n    sensitiveKeyPatterns: string // patterns that must never be stored e.g. \"password:*\"\n  }\n}\n\n// memory-expiry\n{\n  type: \"memory-expiry\",\n  fields: {\n    memoryId: string,\n    memoryType: string,\n    reason: \"ttl-elapsed\"\n            | \"manual-delete\"\n            | \"policy-violation\"\n            | \"contradiction-detected\",\n    expiredAt: datetime,\n    expiredBy: string          // agent or human that triggered it\n  }\n}\n\n// memory-contradiction\n{\n  type: \"memory-contradiction\",\n  fields: {\n    memoryIdA: string,\n    memoryIdB: string,\n    description: string,       // \"client prefers short proposals\" vs \"client asked for detail\"\n    detectedAt: datetime,\n    detectedBy: string,\n    resolution: \"keep-a\"\n               | \"keep-b\"\n               | \"merge\"\n               | \"discard-both\"\n               | \"unresolved\",\n    resolvedAt: datetime\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nmemory-item         --indexed_by-->         memory-index\nmemory-summary      --indexed_by-->         memory-index\nmemory-lesson       --indexed_by-->         memory-index\nmemory-item         --sourced_from-->       agent-run / task-outcome / thread\nmemory-lesson       --sourced_from-->       task-outcome / eval-metric / proposal-score\nmemory-lesson       --reinforced_by-->      memory-reinforcement\nmemory-item         --reinforced_by-->      memory-reinforcement\nmemory-item         --contradicts-->        memory-contradiction\nmemory-item         --governed_by-->        memory-scope-policy\nmemory-query        --produced_by-->        agent-run\nmemory-expiry       --terminates-->         memory-item / memory-lesson\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`memory-item` is the bridge from every other toolbox back into long-term agent knowledge:\n\n```\nminions-proposals   â†’ proposal-score produces memory-lesson:\n                      \"specificity score low when portfolio not cited\"\n\nminions-jobs        â†’ job-signal produces memory-item:\n                      \"client:upwork:abc123:always_posts_react_jobs\"\n\nminions-clients     â†’ client-interaction produces memory-item:\n                      \"client:xyz:prefers_async_comms\"\n\nminions-applications â†’ application-event produces memory-lesson:\n                      \"applications submitted Monday morning get faster replies\"\n\nminions-evaluations â†’ eval-metric produces memory-lesson:\n                      \"proposal-v3 prompt outperforms v2 on specificity by 18%\"\n\nminions-tasks       â†’ task-outcome.lessons field feeds directly into memory-lesson\n```\n\nThe `memory-contradiction` type is what prevents the system from accumulating stale or conflicting beliefs over time â€” without it, a fleet of agents will eventually hold contradictory facts with equal confidence and behave inconsistently.\n\n---\n\n## Agent SKILLS for `minions-memory`\n\n```markdown\n# MemoryAgent Skills\n\n## Context\nYou manage the persistent memory layer for the entire agent fleet.\nYou are the only agent that writes to minions-memory.\nOther agents REQUEST memory from you â€” they do not write directly.\nYour job is to keep memory accurate, fresh, scoped, and contradiction-free.\n\n## Skill: Store Memory\n- When any agent emits a \"store-memory\" request:\n  1. Check memory-scope-policy for that agent â€” is this scope allowed?\n  2. Check sensitiveKeyPatterns â€” reject if key matches a sensitive pattern\n  3. Check for existing memory-item with same agentId + key\n     - If exists and value is same: create memory-reinforcement, increase confidence\n     - If exists and value differs: create memory-contradiction, flag for resolution\n     - If new: create memory-item with confidence 0.7 as default\n  4. Create memory-index entry (keywords + embedding)\n\n## Skill: Recall Memory\n- When any agent emits a \"recall-memory\" request with a query:\n  1. Determine strategy: keyword / semantic / hybrid based on query type\n  2. Search memory-index using the chosen strategy\n  3. Filter by agentId scope (private) or fleet scope\n  4. Rank results by: confidence Ã— recency Ã— reinforcedCount\n  5. Return top N results\n  6. Update lastAccessedAt on retrieved memory-items\n  7. Log a memory-query Minion for observability\n\n## Skill: Extract Lessons\n- After every task-outcome, proposal-score, or eval-metric Minion is created:\n  1. Read the lessons or notes field\n  2. Check if a memory-lesson with similar content already exists\n     - If yes: create memory-reinforcement\n     - If no: create new memory-lesson with confidence 0.6\n  3. Index the lesson\n\n## Skill: Detect Contradictions\n- On every new memory-item write:\n  1. Query existing memory-items with similar keys for the same agentId\n  2. If values conflict: create memory-contradiction Minion\n  3. Attempt auto-resolution:\n     - If one is significantly newer and more recently reinforced â†’ keep newer\n     - If confidence gap > 0.3 â†’ keep higher confidence\n     - Otherwise â†’ mark as unresolved, notify Orchestrator\n\n## Skill: Expire Memory\n- On schedule (daily):\n  1. Find all memory-items where expiresAt < now â†’ create memory-expiry\n  2. Find memory-items where lastAccessedAt > 90 days and confidence < 0.3\n     â†’ decay confidence by 0.1, expiry if confidence reaches 0\n  3. Find unresolved memory-contradictions older than 7 days\n     â†’ escalate to Orchestrator for manual resolution\n\n## Skill: Summarize Session\n- At the end of every significant agent-run:\n  1. Read the agent-run inputs, outputs, toolCallsLog\n  2. Generate a memory-summary: narrative + keyFacts\n  3. Index the summary\n  4. If any keyFacts contradict existing memory-items â†’ run contradiction detection\n\n## Hard Rules\n- Never store values matching sensitiveKeyPatterns\n- Never allow an agent to read memory outside its allowed scopes\n- Every write must produce a memory-index entry â€” unsearchable memory is useless\n- Contradictions must never be silently discarded â€” always log a memory-contradiction\n- Confidence must never be manually set above 0.95 â€” leave room for uncertainty\n```\n\n---\n\nThe `memory-contradiction` type and the confidence decay in the expiry skill are the two things most memory implementations skip and then regret. Without them the memory store becomes a graveyard of stale, conflicting facts that agents silently trust â€” which is worse than no memory at all.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-memory/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\nmemory types list\n\n# Show detailed schema for a specific type\nmemory types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\nmemory create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\nmemory create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\nmemory list <type>\n\n# Show a specific Minion\nmemory show <id>\n\n# Search by text\nmemory search \"query\"\n\n# Output as JSON (for piping)\nmemory list --json\nmemory show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\nmemory update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\nmemory delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\nmemory stats\n\n# Validate a Minion JSON file against its schema\nmemory validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-match",
              "name": "minions-match",
              "id": "OC-0129",
              "version": "1.0.0",
              "description": "Match scoring, shortlists, and hard gate evaluation between jobs and profile",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-match â€” Agent Skills\n\n## What is a Match in the Minions Context?\n\nBefore defining types, it's worth being precise. \"Matching\" covers several distinct concepts:\n\n```\nevaluating a job against your profile     â†’ MatchScore\nrules that disqualify regardless of score â†’ HardGate\nuser preferences that bias scoring        â†’ MatchPreference\na curated selection of top results        â†’ Shortlist\nexplaining why something scored how it did â†’ MatchExplanation\ntracking score changes over time          â†’ ScoreHistory\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// match-score\n{\n  type: \"match-score\",\n  fields: {\n    jobId: string,                    // ref to job-posting\n    profileId: string,                // ref to candidate profile\n    overallScore: number,             // 0.0 - 1.0\n    skillOverlapScore: number,\n    budgetFitScore: number,\n    timezoneFitScore: number,\n    clientReputationScore: number,    // based on client-profile history\n    competitionScore: number,         // estimated competition level\n    hardGateFailed: boolean,\n    hardGateReasons: string[],\n    scoredAt: datetime,\n    scoredByAgentId: string,\n    version: number                   // increments if re-scored\n  }\n}\n```\n\n**Explanation layer** â€” makes scores auditable, not just numbers\n```ts\n// match-explanation\n{\n  type: \"match-explanation\",\n  fields: {\n    matchScoreId: string,\n    dimension: string,               // \"skillOverlap\", \"budgetFit\", etc.\n    score: number,\n    reasoning: string,               // human-readable explanation\n    evidenceIds: string[],           // bio-claim or portfolio-item ids used\n    confidence: \"high\" | \"medium\" | \"low\"\n  }\n}\n```\n\n**Hard Gates** â€” absolute disqualifiers\n```ts\n// hard-gate\n{\n  type: \"hard-gate\",\n  fields: {\n    name: string,\n    condition: string,               // e.g. \"budgetAmount < rateCard.hourlyMin * 10\"\n    reason: string,                  // shown in explanation\n    severity: \"block\" | \"warn\",      // block = never apply, warn = flag but allow\n    isActive: boolean,\n    appliesTo: string[]              // platforms this gate applies to, empty = all\n  }\n}\n\n// hard-gate-result\n{\n  type: \"hard-gate-result\",\n  fields: {\n    matchScoreId: string,\n    gateId: string,\n    triggered: boolean,\n    evaluatedValue: string,          // what the actual value was\n    evaluatedAt: datetime\n  }\n}\n```\n\n**Preferences** â€” soft biases that shift scoring weight\n```ts\n// match-preference\n{\n  type: \"match-preference\",\n  fields: {\n    name: string,\n    field: string,                   // which job-posting field this affects\n    direction: \"prefer\" | \"avoid\",\n    weight: number,                  // 0.0 - 1.0, how much it shifts score\n    value: string,                   // what value to prefer or avoid\n    isActive: boolean\n  }\n}\n```\n\n**Shortlist** â€” the output of a scoring cycle\n```ts\n// shortlist\n{\n  type: \"shortlist\",\n  fields: {\n    name: string,\n    createdAt: datetime,\n    createdByAgentId: string,\n    jobIds: string[],\n    matchScoreIds: string[],\n    rationale: string,               // why these were selected\n    status: \"pending\" | \"reviewed\" | \"actioned\" | \"expired\",\n    reviewedBy: string,\n    reviewedAt: datetime\n  }\n}\n```\n\n**Score History** â€” tracks re-scoring over time\n```ts\n// score-history-entry\n{\n  type: \"score-history-entry\",\n  fields: {\n    jobId: string,\n    matchScoreId: string,\n    overallScore: number,\n    recordedAt: datetime,\n    changeReason: string             // \"profile updated\", \"job edited\", \"re-scored\"\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nmatch-score         --explains_via-->       match-explanation\nmatch-score         --evaluated_by-->       hard-gate-result\nmatch-score         --belongs_to-->         shortlist\nmatch-score         --references-->         job-posting\nmatch-score         --references-->         bio-claim\nmatch-score         --references-->         portfolio-item\nhard-gate           --produces-->           hard-gate-result\nmatch-preference    --influences-->         match-score\nscore-history-entry --tracks-->             match-score\nshortlist           --triggers-->           task (propose for these jobs)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`minions-match` sits between discovery and action â€” it reads from several toolboxes and feeds into others:\n\n```\nreads from:\n  minions-jobs      â†’ job-posting, job-signal (raw material to score)\n  minions-profile   â†’ bio-claim, skill-claim, portfolio-item, rate-card, availability\n\nwrites to:\n  minions-tasks     â†’ spawns a task per shortlisted job: \"generate proposal\"\n  minions-pipeline  â†’ advances job-posting to \"shortlisted\" stage\n  minions-approvals â†’ if a borderline score needs human judgment before proceeding\n  minions-memory    â†’ stores win/loss outcomes to improve future scoring\n\nconsumed by:\n  minions-proposals â†’ ProposalWriter reads match-explanation to know what to emphasize\n  minions-clients   â†’ client-reputation feeds back into clientReputationScore over time\n```\n\nThe `match-explanation` â†’ `proposal-draft` connection is particularly important. Rather than the ProposalWriter starting from scratch, it reads which `evidenceIds` scored highest in the match and leads the proposal with exactly those portfolio items and bio claims.\n\n---\n\n## Agent SKILLS for `minions-match`\n\n```markdown\n# MatchAgent Skills\n\n## Context\nYou are MatchAgent. You own the minions-match toolbox. You read from\nminions-jobs and minions-profile but never write to them. You write\nmatch-score, match-explanation, hard-gate-result, shortlist, and\nscore-history-entry Minions. You report shortlists to the Orchestrator.\n\n## Skill: Evaluate Hard Gates\n1. Load all active `hard-gate` Minions\n2. For each new `job-posting`, evaluate every gate condition\n3. Create a `hard-gate-result` Minion for each gate evaluated\n4. If any gate with severity \"block\" is triggered:\n   - Set hardGateFailed = true on the match-score\n   - Stop scoring â€” do not proceed to soft scoring\n   - Update job-posting status to \"disqualified\"\n5. If a \"warn\" gate triggers, continue scoring but flag in explanations\n\n## Skill: Score a Job\n1. Only score jobs where hardGateFailed == false\n2. Load all `bio-claim`, `skill-claim`, `portfolio-item`, `rate-card`,\n   and `availability` Minions from minions-profile\n3. Load `job-signal` for this job-posting\n4. Compute each dimension:\n   - skillOverlapScore: match mustHaveSkills against skill-claim Minions\n   - budgetFitScore: compare budgetAmount against rate-card range\n   - timezoneFitScore: compare clientCountry against availability timezone\n   - clientReputationScore: check if client-profile exists and its rating\n   - competitionScore: infer from platform, budget, and job age\n5. Weight dimensions using active `match-preference` Minions\n6. Compute overallScore as weighted average\n7. Create `match-score` Minion with all dimension scores\n\n## Skill: Explain a Score\n1. For each scored dimension, create a `match-explanation` Minion:\n   - State the reasoning in plain language\n   - List the specific evidenceIds (bio-claim or portfolio-item) used\n   - Assign confidence based on how direct the evidence is\n2. Explanations must be readable by both humans and the ProposalWriter agent\n\n## Skill: Build Shortlist\n1. After scoring a batch of jobs, filter:\n   - overallScore >= 0.65\n   - hardGateFailed == false\n2. Sort by overallScore descending\n3. Apply a cap: maximum 10 jobs per shortlist\n4. Create a `shortlist` Minion with rationale summarizing why each job made the cut\n5. Emit \"shortlist-ready\" message to Orchestrator with shortlistId\n\n## Skill: Re-score on Profile Change\n1. When notified that a bio-claim, skill-claim, or rate-card has changed:\n   - Identify all match-score Minions with status \"pending\" or \"shortlisted\"\n   - Re-score affected jobs\n   - Create new score-history-entry Minions recording the change\n   - Update shortlist if rankings shift significantly\n\n## Skill: Learn from Outcomes\n1. When a job-posting reaches terminal status (won, lost, withdrawn):\n   - Record outcome against the match-score\n   - Write a memory-item to minions-memory:\n     { key: \"match-outcome\", value: { score, result, platform, skillTags } }\n2. Over time this builds a calibration dataset for improving score weights\n\n## Hard Rules\n- Never write to minions-jobs or minions-profile\n- Never shortlist a job where any \"block\" hard-gate triggered\n- Always create match-explanation Minions before reporting a shortlist â€”\n  the ProposalWriter depends on them\n- A match-score without explanations is incomplete and must not be used\n```\n\n---\n\nThe `clientReputationScore` dimension and the \"Learn from Outcomes\" skill are worth highlighting â€” together they mean the MatchAgent gets measurably better over time. Early on it scores purely on profile fit; after a few dozen applications it starts weighting platforms, budget ranges, and skill combinations that historically convert, feeding that signal back through `minions-memory` into future scoring cycles.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-match/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\nmatch types list\n\n# Show detailed schema for a specific type\nmatch types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\nmatch create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\nmatch create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\nmatch list <type>\n\n# Show a specific Minion\nmatch show <id>\n\n# Search by text\nmatch search \"query\"\n\n# Output as JSON (for piping)\nmatch list --json\nmatch show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\nmatch update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\nmatch delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\nmatch stats\n\n# Validate a Minion JSON file against its schema\nmatch validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-jobs",
              "name": "minions-jobs",
              "id": "OC-0127",
              "version": "1.0.0",
              "description": "Canonical schemas for job postings and extracted signals across freelance platforms",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-jobs â€” Agent Skills\n\n## What is a Job in the Minions Context?\n\nBefore defining types, it's worth being precise. A \"job\" can mean very different things depending on where you are in the workflow:\n\n```\na raw listing from a platform        â†’ JobPosting\nwhere that listing came from         â†’ JobSource\nstructured intelligence extracted    â†’ JobSignal\na saved ongoing search               â†’ JobWatchlist\na flag or label on a posting         â†’ JobTag\nwhat happened to it over time        â†’ JobEvent\n```\n\n---\n\n## MinionTypes\n\n**Discovery**\n```ts\n// job-source\n{\n  type: \"job-source\",\n  fields: {\n    platform: \"upwork\" | \"freelancer\" | \"malt\" | \"contra\" | \"linkedin\" | \"other\",\n    searchQuery: string,\n    filters: {\n      budgetMin: number,\n      budgetMax: number,\n      skills: string[],\n      countries: string[],\n      jobType: \"fixed\" | \"hourly\" | \"any\"\n    },\n    crawlPolicy: \"api\" | \"rss\" | \"scrape\",\n    authMode: \"none\" | \"api-key\" | \"oauth\" | \"session\",\n    isActive: boolean,\n    lastCrawledAt: datetime,\n    crawlIntervalMinutes: number\n  }\n}\n\n// job-posting\n{\n  type: \"job-posting\",\n  fields: {\n    sourceId: string,           // ref to job-source\n    platform: string,\n    url: string,\n    title: string,\n    description: string,\n    budget: {\n      type: \"fixed\" | \"hourly\",\n      amount: number,\n      currency: string,\n      isEstimate: boolean\n    },\n    skills: string[],\n    clientCountry: string,\n    clientTimezone: string,\n    postedAt: datetime,\n    crawledAt: datetime,\n    updatedAt: datetime,\n    status: \"new\" | \"shortlisted\" | \"applied\" | \"rejected\" | \"closed\" | \"expired\"\n  }\n}\n```\n\n**Intelligence Extraction**\n```ts\n// job-signal\n{\n  type: \"job-signal\",\n  fields: {\n    jobId: string,              // ref to job-posting\n    mustHaveSkills: string[],\n    niceToHaveSkills: string[],\n    impliedSkills: string[],    // inferred but not stated explicitly\n    redFlags: string[],         // \"unpaid trial\", \"no budget stated\", \"vague scope\"\n    greenFlags: string[],       // \"long-term potential\", \"clear brief\", \"repeat client\"\n    clientSignals: {\n      hireRate: number,         // if extractable from platform\n      reviewScore: number,\n      totalSpent: number,\n      isVerified: boolean\n    },\n    estimatedWinProbability: number,\n    budgetConfidence: \"high\" | \"medium\" | \"low\",\n    extractedAt: datetime\n  }\n}\n\n// job-watchlist\n{\n  type: \"job-watchlist\",\n  fields: {\n    name: string,\n    sourceId: string,           // ref to job-source\n    query: string,\n    filters: {\n      budgetMin: number,\n      skills: string[],\n      countries: string[]\n    },\n    isActive: boolean,\n    lastMatchedAt: datetime,\n    totalMatchesFound: number\n  }\n}\n```\n\n**Lifecycle Tracking**\n```ts\n// job-event\n{\n  type: \"job-event\",\n  fields: {\n    jobId: string,\n    eventType: \"discovered\" | \"updated\" | \"shortlisted\" | \"applied\" \n               | \"rejected\" | \"closed\" | \"expired\" | \"reopened\",\n    occurredAt: datetime,\n    triggeredBy: string,        // agent id or \"human\"\n    notes: string\n  }\n}\n\n// job-duplicate\n{\n  type: \"job-duplicate\",\n  fields: {\n    canonicalJobId: string,     // the one we keep\n    duplicateJobId: string,     // the one we suppress\n    detectedAt: datetime,\n    similarityScore: number,\n    reason: string              // \"same url\", \"same title+client\", \"near-identical description\"\n  }\n}\n```\n\n---\n\n## Relations\n\n```\njob-source       --produces-->          job-posting\njob-watchlist    --monitors-->          job-source\njob-posting      --has_signal-->        job-signal\njob-posting      --has_event-->         job-event\njob-posting      --deduplicated_by-->   job-duplicate\njob-posting      --scored_by-->         match-score       (minions-match)\njob-posting      --has_proposal-->      proposal-draft    (minions-proposals)\njob-posting      --has_application-->   application       (minions-applications)\njob-posting      --has_task-->          task              (minions-tasks)\njob-posting      --linked_to-->         client-profile    (minions-clients)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`job-posting` is the central object that almost every other toolbox references:\n\n```\nminions-match       reads job-posting + job-signal â†’ produces match-score\nminions-proposals   reads job-posting + job-signal â†’ produces proposal-draft\nminions-applications reads job-posting             â†’ produces application\nminions-pipeline    reads job-posting              â†’ creates pipeline-entry\nminions-clients     reads job-posting              â†’ builds or updates client-profile\nminions-tasks       reads job-posting              â†’ spawns tasks like \"research client\"\nminions-memory      reads job-posting              â†’ stores seen job ids to prevent duplicates\n```\n\nThe `job-signal` is what separates raw discovery from intelligence â€” it's the layer the MatchAgent actually reasons over, not the raw posting text.\n\n---\n\n## Agent SKILLS for `minions-jobs`\n\n```markdown\n# JobScoutAgent Skills\n\n## Context\nYou are the JobScoutAgent. You own the minions-jobs toolbox.\nYou read from `job-source` Minions to know where and how to search.\nYou write `job-posting`, `job-signal`, `job-event`, and `job-duplicate` Minions.\nYou do not score, rank, or write proposals â€” that belongs to other agents.\nYou report to the OrchestratorAgent when a crawl cycle completes.\n\n## Skill: Crawl Sources\n1. Load all `job-source` Minions where isActive == true\n2. For each source, check if lastCrawledAt + crawlIntervalMinutes < now\n3. If due: query the platform using the configured crawlPolicy and authMode\n4. For each result returned:\n   - Check `minions-memory` for known sourceId â€” skip if already seen and unchanged\n   - If new: create a `job-posting` Minion with status \"new\"\n   - If updated: update the existing Minion, create a `job-event` with type \"updated\"\n   - Create a `job-event` with type \"discovered\" for all new postings\n5. Update lastCrawledAt on the `job-source` Minion\n\n## Skill: Extract Signals\n1. For each `job-posting` with status \"new\" and no linked `job-signal`:\n   - Parse description for explicit skills (mustHave), implied skills, red flags, green flags\n   - Attempt to extract client signals from platform data if available\n   - Estimate budget confidence: high if stated clearly, medium if range given, low if missing\n   - Compute estimatedWinProbability as a rough prior (not the full match score)\n   - Create a `job-signal` Minion linked to the job-posting\n\n## Skill: Deduplicate\n1. For each new `job-posting`, compare against recent postings:\n   - Exact match on url â†’ immediate duplicate\n   - Same title + same clientCountry + budget within 10% â†’ likely duplicate\n   - Near-identical description (embedding similarity > 0.95) â†’ probable duplicate\n2. If duplicate detected:\n   - Create a `job-duplicate` Minion referencing canonical and duplicate ids\n   - Set duplicate posting status to \"rejected\"\n   - Do not surface to downstream agents\n\n## Skill: Monitor Watchlists\n1. Load all `job-watchlist` Minions where isActive == true\n2. For each watchlist, run the saved query against its linked `job-source`\n3. New matches â†’ follow the same crawl + signal extraction flow\n4. Update lastMatchedAt and totalMatchesFound on the watchlist\n\n## Skill: Expire Stale Postings\n1. On each cycle, check all `job-posting` Minions with status \"new\" or \"shortlisted\"\n2. If postedAt > 30 days ago and no application exists:\n   - Update status to \"expired\"\n   - Create a `job-event` with type \"expired\"\n\n## Skill: Report to Orchestrator\n1. After each crawl cycle, emit an agent-message to OrchestratorAgent:\n   {\n     type: \"crawl-complete\",\n     newPostings: number,\n     signalsExtracted: number,\n     duplicatesFound: number,\n     expiredPostings: number,\n     topNewJobIds: string[]   // top 5 by estimatedWinProbability\n   }\n\n## Hard Rules\n- Never modify a job-posting owned by another agent\n- Never create a proposal or score â€” emit to Orchestrator and let MatchAgent handle it\n- Never submit anything to a platform â€” read only\n- Always create a job-event for every status change\n- Never surface a posting with hardGateFailed == true to the Orchestrator\n```\n\n---\n\nThe `job-signal` extraction step is the most valuable part of this toolbox â€” it transforms unstructured platform text into structured Minion data that every downstream agent (MatchAgent, ProposalAgent, ClientAgent) can reason over cleanly without re-parsing raw job descriptions each time.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-jobs/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\njobs types list\n\n# Show detailed schema for a specific type\njobs types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\njobs create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\njobs create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\njobs list <type>\n\n# Show a specific Minion\njobs show <id>\n\n# Search by text\njobs search \"query\"\n\n# Output as JSON (for piping)\njobs list --json\njobs show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\njobs update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\njobs delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\njobs stats\n\n# Validate a Minion JSON file against its schema\njobs validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-evaluations",
              "name": "minions-evaluations",
              "id": "OC-0126",
              "version": "1.0.0",
              "description": "Benchmarks, test cases, and prompt scoring for continuous agent improvement",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-evaluations â€” Agent Skills\n\n## What is an Evaluation in the Minions Context?\n\nBefore defining types, it's worth being precise. \"Evaluation\" can mean very different things depending on who is asking:\n\n```\nis this agent output good enough?          â†’ TestCase + TestRun\nhow does this prompt version compare?      â†’ Benchmark + EvalMetric\nwhat quality dimensions matter here?       â†’ Rubric + RubricCriterion\nhow has quality changed over time?         â†’ EvalTrend\nwho or what decided this passed?           â†’ EvalJudgment\n```\n\nThe core purpose of `minions-evals` is to give the system a **memory of quality** â€” so agents don't just run, they improve. Every skill, every prompt version, every agent behavior can be measured, compared, and iterated on.\n\n---\n\n## MinionTypes\n\n**Test Definition**\n```ts\n// test-case\n{\n  type: \"test-case\",\n  fields: {\n    name: string,\n    description: string,\n    agentId: string,\n    skillId: string,\n    promptVersionRef: string,      // links to minions-prompts version\n    inputs: Record<string, any>,   // what goes in\n    expectedOutputs: Record<string, any>, // what should come out\n    rubricId: string,              // how to judge the output\n    tags: string[],\n    status: \"active\" | \"draft\" | \"deprecated\",\n    createdAt: datetime,\n    createdBy: string\n  }\n}\n\n// rubric\n{\n  type: \"rubric\",\n  fields: {\n    name: string,\n    description: string,\n    criteriaIds: string[],         // ordered list of rubric-criterion ids\n    passingThreshold: number,      // minimum weighted score to pass\n    version: number,\n    isActive: boolean\n  }\n}\n\n// rubric-criterion\n{\n  type: \"rubric-criterion\",\n  fields: {\n    rubricId: string,\n    name: string,                  // e.g. \"Relevance\", \"Factual Accuracy\"\n    description: string,           // what does good look like for this criterion\n    weight: number,                // relative importance 0â€“1\n    scoringGuide: string,          // instructions for the judge\n    minScore: number,\n    maxScore: number\n  }\n}\n```\n\n**Execution**\n```ts\n// test-run\n{\n  type: \"test-run\",\n  fields: {\n    testCaseId: string,\n    agentRunId: string,            // links to minions-agents agent-run\n    promptVersionRef: string,\n    actualOutput: Record<string, any>,\n    passed: boolean,\n    totalScore: number,\n    maxPossibleScore: number,\n    ranAt: datetime,\n    durationMs: number,\n    judgeType: \"llm\" | \"human\" | \"heuristic\"\n  }\n}\n\n// eval-judgment\n{\n  type: \"eval-judgment\",\n  fields: {\n    testRunId: string,\n    criterionId: string,\n    score: number,\n    maxScore: number,\n    rationale: string,             // why this score was given\n    judgedBy: string,              // agent id or human id\n    judgedByType: \"llm\" | \"human\" | \"heuristic\",\n    judgedAt: datetime,\n    confidence: number             // how confident is the judge 0â€“1\n  }\n}\n```\n\n**Benchmarking**\n```ts\n// benchmark\n{\n  type: \"benchmark\",\n  fields: {\n    name: string,\n    description: string,\n    testCaseIds: string[],\n    dimension: string,             // \"proposal quality\", \"job scoring accuracy\"\n    passingThreshold: number,\n    ownerId: string,\n    lastRunAt: datetime,\n    lastScore: number,\n    status: \"active\" | \"retired\"\n  }\n}\n\n// benchmark-run\n{\n  type: \"benchmark-run\",\n  fields: {\n    benchmarkId: string,\n    testRunIds: string[],\n    overallScore: number,\n    passRate: number,              // % of test cases passed\n    ranAt: datetime,\n    triggeredBy: string,           // agent id, human, or schedule id\n    notes: string\n  }\n}\n```\n\n**Trend & Comparison**\n```ts\n// eval-trend\n{\n  type: \"eval-trend\",\n  fields: {\n    benchmarkId: string,\n    dimension: string,\n    dataPoints: string,            // serialized { date, score }[]\n    direction: \"improving\" | \"degrading\" | \"stable\",\n    lastComputedAt: datetime\n  }\n}\n\n// prompt-comparison\n{\n  type: \"prompt-comparison\",\n  fields: {\n    benchmarkId: string,\n    promptVersionA: string,\n    promptVersionB: string,\n    scoreA: number,\n    scoreB: number,\n    winner: string,                // version ref of winner\n    sampleSize: number,\n    comparedAt: datetime,\n    notes: string\n  }\n}\n```\n\n**Failure Analysis**\n```ts\n// eval-failure\n{\n  type: \"eval-failure\",\n  fields: {\n    testRunId: string,\n    failureType: \"wrong-output\" | \"hallucination\" | \"format-error\" | \"timeout\" | \"refusal\",\n    description: string,\n    affectedCriterionIds: string[],\n    severity: \"critical\" | \"major\" | \"minor\",\n    rootCause: string,\n    resolvedAt: datetime,\n    resolutionNotes: string\n  }\n}\n```\n\n---\n\n## Relations\n\n```\ntest-case           --evaluated_by-->       rubric\ntest-case           --produces-->           test-run\nrubric              --composed_of-->        rubric-criterion\ntest-run            --contains-->           eval-judgment\neval-judgment       --scores-->             rubric-criterion\nbenchmark           --groups-->             test-case\nbenchmark           --produces-->           benchmark-run\nbenchmark-run       --aggregates-->         test-run\nbenchmark           --tracked_by-->         eval-trend\neval-failure        --originated_from-->    test-run\nprompt-comparison   --references-->         benchmark-run\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`minions-evals` sits downstream of everything â€” it observes and measures but never initiates:\n\n```\nminions-agents      â†’ agent-run is referenced by test-run\n                      every agent run can optionally trigger eval\n\nminions-skills      â†’ skill-definition has promptRef\n                      evals measure whether a skill meets its quality gates\n\nminions-prompts     â†’ promptVersionRef links test-case and test-run\n                      prompt-comparison directly drives A/B decisions here\n\nminions-proposals   â†’ proposal-draft scores feed into rubric-criterion scores\n                      \"did the proposal pass the relevance criterion?\"\n\nminions-memory      â†’ eval-failure and lessons from test-runs feed back\n                      as memory-items for long-term agent improvement\n\nminions-tasks       â†’ a failed benchmark-run can spawn a task:\n                      \"investigate why proposal relevance score dropped\"\n```\n\n---\n\n## Agent SKILLS for `minions-evals`\n\n```markdown\n# EvalAgent Skills\n\n## Context\nYou are the EvalAgent. You measure quality across the entire fleet.\nYou do not run jobs, write proposals, or submit applications.\nYou observe outputs, score them against rubrics, track trends, and\nsurface regressions before they cause real-world failures.\nAll data you work with lives in minions-evals.\nYou read agent-run outputs from minions-agents and prompt versions\nfrom minions-prompts. You write only to minions-evals.\n\n## Skill: Run a Test Case\n1. Load the `test-case` Minion and its linked `rubric`\n2. Load the `rubric-criterion` Minions for that rubric\n3. Retrieve the actual output from the linked `agent-run` in minions-agents\n4. For each criterion: score the output using the scoringGuide\n   - If judgeType is \"llm\": call yourself as judge with the criterion description\n   - If judgeType is \"heuristic\": apply rule-based scoring logic\n   - If judgeType is \"human\": create an approval-request in minions-approvals\n5. Create one `eval-judgment` Minion per criterion\n6. Compute totalScore as weighted sum across all criteria\n7. Mark passed = true if totalScore >= rubric.passingThreshold\n8. Create the `test-run` Minion with full results\n\n## Skill: Run a Benchmark\n1. Load the `benchmark` Minion and its testCaseIds\n2. For each test case: execute Skill: Run a Test Case\n3. Aggregate all test-run results into a `benchmark-run` Minion\n4. Compute overallScore and passRate\n5. Update benchmark.lastRunAt and benchmark.lastScore\n6. If passRate dropped more than 10% from previous run:\n   - Create an eval-failure Minion with severity \"critical\"\n   - Create a task in minions-tasks: \"Investigate benchmark regression\"\n   - Notify Orchestrator via agent-message\n\n## Skill: Detect Trends\n1. On each benchmark-run completion, load the `eval-trend` for that benchmark\n2. Append the new score as a data point\n3. Compute direction over last 5 data points:\n   - Improving: consistent upward slope\n   - Degrading: consistent downward slope\n   - Stable: variance within 5%\n4. Update the `eval-trend` Minion\n5. If direction is \"degrading\" for 3 consecutive runs:\n   - Escalate to Orchestrator with full trend data\n\n## Skill: Compare Prompt Versions\n1. On receiving a \"compare-prompts\" instruction from Orchestrator:\n   - Load benchmark and both prompt version refs\n   - Run the full benchmark once per prompt version\n   - Create a `prompt-comparison` Minion with both scores\n   - Set winner to the higher-scoring version\n2. Emit \"comparison-complete\" to Orchestrator with recommendation\n\n## Skill: Classify Failures\n1. For any test-run where passed = false:\n   - Analyze the gap between expected and actual output\n   - Classify failure type: wrong-output, hallucination, format-error,\n     timeout, or refusal\n   - Identify which criteria were most affected\n   - Estimate root cause from the agent-run toolCallsLog\n   - Create an `eval-failure` Minion with full analysis\n2. Store key findings as memory-items in minions-memory\n   so the relevant agent learns from the failure next session\n\n## Hard Rules\n- Never modify agent outputs â€” only observe and score\n- Never approve a prompt version change without a benchmark-run showing improvement\n- Always create an eval-failure Minion for any passed = false test-run\n- Every judgment must include a rationale â€” scores without reasoning are invalid\n- Surface regressions immediately, do not wait for scheduled runs\n```\n\n---\n\nThe `eval-judgment` rationale field is the most important detail here â€” without it you have scores but no insight. An agent that scores a proposal 0.4 on relevance and explains exactly why gives you something actionable. A bare number gives you nothing to iterate on.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-evaluations/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\nevaluations types list\n\n# Show detailed schema for a specific type\nevaluations types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\nevaluations create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\nevaluations create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\nevaluations list <type>\n\n# Show a specific Minion\nevaluations show <id>\n\n# Search by text\nevaluations search \"query\"\n\n# Output as JSON (for piping)\nevaluations list --json\nevaluations show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\nevaluations update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\nevaluations delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\nevaluations stats\n\n# Validate a Minion JSON file against its schema\nevaluations validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-dev-prompts",
              "name": "minions-dev-prompts",
              "id": "OC-0124",
              "version": "1.0.0",
              "description": "Reusable prompt templates, prompt chains, and prompt versioning for agent-tasks",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-dev-prompts â€” Agent Skills\n\n## What is a Dev Prompt in the Minions Context?\n\n```\na reusable prompt template for agent-tasks   â†’ PromptTemplate\nan ordered sequence of prompts               â†’ PromptChain\na versioned snapshot for auditing            â†’ PromptVersion\n```\n\nPrompt quality determines agent-task quality. This toolbox is the prompt library.\n\n---\n\n## MinionTypes\n\n```ts\n// prompt-template\n{\n  type: \"prompt-template\",\n  fields: {\n    name: string,                    // \"add-rest-api\", \"setup-auth\", \"add-tests\"\n    description: string,\n    category: \"feature\" | \"bugfix\" | \"refactor\" | \"test\" | \"docs\" | \"ci\" | \"scaffold\",\n    template: string,                // prompt with {{variables}}\n    variables: string[],             // [\"framework\", \"authProvider\", \"dbType\"]\n    exampleOutput: string,\n    version: number,\n    isActive: boolean,\n    createdAt: datetime\n  }\n}\n\n// prompt-chain â€” ordered prompt sequences for complex features\n// e.g. \"setup-db\" â†’ \"add-models\" â†’ \"add-api\" â†’ \"add-tests\"\n\n// prompt-version â€” immutable snapshots for auditing and rollback\n```\n\n---\n\n## Relations\n\n```\nprompt-template    --versioned_in-->     prompt-version\nprompt-template    --chained_in-->       prompt-chain\nprompt-template    --used_by-->          agent-task (minions-agent-tasks)\nprompt-chain       --feeds-->            task-batch (minions-agent-tasks)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-agent-tasks    â†’ prompts are the input to every agent-task\nminions-evaluations    â†’ prompt quality can be scored against task-results\nminions-memory         â†’ effective prompt patterns stored as agent knowledge\nminions-taxonomy       â†’ prompt categories align with taxonomy\n```\n\n---\n\n## Agent SKILLS for `minions-dev-prompts`\n\n```markdown\n# PromptAgent Skills\n\n## Context\nYou maintain the prompt library for AIDeveloper. You create, refine,\nversion, and chain prompts that produce high-quality agent-task output.\nYou learn from task-results to improve prompts over time.\n\n## Skill: Create Template\n1. Define a reusable prompt-template with variables\n2. Write example output showing expected behavior\n3. Set category and version\n\n## Skill: Build Chain\n1. For complex features: compose a sequence of prompt-templates\n2. Define execution order and dependencies\n3. Create prompt-chain Minion\n\n## Skill: Version Prompt\n1. Before modifying a template: create prompt-version snapshot\n2. Update template with improvements\n3. Increment version number\n4. Log change notes\n\n## Skill: Learn from Results\n1. After each agent-task completes: assess quality\n2. If quality is low: identify prompt weaknesses\n3. Refine template and create new version\n4. Track which prompt version produced the best results\n\n## Hard Rules\n- Prompts are never deleted â€” only deactivated\n- Every modification creates a prompt-version first\n- Prompt chains must be tested before use in production\n- Variables must be documented with expected values\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-dev-prompts/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\ndev-prompts types list\ndev-prompts types show <type-slug>\n```\n\n### CRUD\n\n```bash\ndev-prompts create <type> -t \"Title\" -s \"status\"\ndev-prompts list <type>\ndev-prompts show <id>\ndev-prompts update <id> --data '{ \"status\": \"active\" }'\ndev-prompts delete <id>\ndev-prompts search \"query\"\n```\n\n### Stats & Validation\n\n```bash\ndev-prompts stats\ndev-prompts validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-decisions",
              "name": "minions-decisions",
              "id": "OC-0123",
              "version": "1.0.0",
              "description": "Logged decisions with rationale, alternatives, and outcome",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-decisions â€” Agent Skills\n\n## What is a Decision in the Minions Context?\n\n```\na logged project decision                 â†’ Decision\na retrospective review                    â†’ DecisionReview\n```\n\n## MinionTypes\n```ts\n// decision â€” title, rationale, alternatives, outcome, decided by/at\n// decision-review â€” reviewed later: was it correct? lessons learned?\n```\n\n## Relations\n```\ndecision          --belongs_to-->        project (minions-projects)\ndecision          --reviewed_by-->       decision-review\ndecision          --may_require-->       approval-request (minions-approvals)\n```\n\n## Agent SKILLS\n```markdown\n# DecisionAgent Skills\n## Skill: Log Decision â€” capture rationale, alternatives, outcome\n## Skill: Review Past Decisions â€” periodic retrospective\n## Hard Rules â€” all irreversible decisions require approval first\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-decisions/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\ndecisions types list\ndecisions types show <type-slug>\n```\n\n### CRUD\n\n```bash\ndecisions create <type> -t \"Title\" -s \"status\"\ndecisions list <type>\ndecisions show <id>\ndecisions update <id> --data '{ \"status\": \"active\" }'\ndecisions delete <id>\ndecisions search \"query\"\n```\n\n### Stats & Validation\n\n```bash\ndecisions stats\ndecisions validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-crm-pipeline",
              "name": "minions-crm-pipeline",
              "id": "OC-0122",
              "version": "1.0.0",
              "description": "Deal stages, transitions, revenue forecasts, and win/loss tracking",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-crm-pipeline â€” Agent Skills\n\n## What is a CRM Pipeline in the Minions Context?\n\n```\na potential or active deal                â†’ Deal\na stage transition                        â†’ DealTransition\na periodic revenue forecast               â†’ RevenueForecast\n```\n\n## MinionTypes\n```ts\n// deal â€” lead, service, value, stage, probability, expected close date\n// deal-transition â€” from/to stage, reason, changed by\n// revenue-forecast â€” period, total pipeline, weighted forecast\n```\n\n## Agent SKILLS\n```markdown\n# PipelineAgent Skills\n## Skill: Advance Deal â€” move through stages based on conversation signals\n## Skill: Forecast Revenue â€” weighted projection from pipeline\n## Hard Rules â€” every stage change must log a deal-transition\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-crm-pipeline/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\ncrm-pipeline types list\ncrm-pipeline types show <type-slug>\n```\n\n### CRUD\n\n```bash\ncrm-pipeline create <type> -t \"Title\" -s \"status\"\ncrm-pipeline list <type>\ncrm-pipeline show <id>\ncrm-pipeline update <id> --data '{ \"status\": \"active\" }'\ncrm-pipeline delete <id>\ncrm-pipeline search \"query\"\n```\n\n### Stats & Validation\n\n```bash\ncrm-pipeline stats\ncrm-pipeline validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-costs",
              "name": "minions-costs",
              "id": "OC-0121",
              "version": "1.0.0",
              "description": "Cost tracking, budgets, and financial ledgers for agent operations",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-costs â€” Agent Skills\n\n## What is a Cost in the Minions Context?\n\nBefore defining types, it's worth being precise. \"Cost\" can mean very different things depending on where you're looking:\n\n```\na single billable event                â†’ CostEntry\na cap on how much can be spent         â†’ Budget\na running total across a period        â†’ CostLedger\na warning before the cap is hit        â†’ BudgetAlert\nwho or what caused the spending        â†’ CostAllocation\na recurring expected expense           â†’ RecurringCost\na summary for reporting                â†’ CostReport\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// cost-entry\n{\n  type: \"cost-entry\",\n  fields: {\n    sourceId: string,          // id of what triggered this cost (agent-run, api-call, etc.)\n    sourceType: string,        // \"agent-run\" | \"api-call\" | \"tool-call\" | \"manual\"\n    agentId: string,           // which agent incurred it\n    skillId: string,           // which skill within that agent\n    model: string,             // e.g. \"gpt-4o\", \"claude-3-5-sonnet\"\n    tokensInput: number,\n    tokensOutput: number,\n    tokensTotal: number,\n    amount: number,            // calculated cost in currency\n    currency: string,\n    incurredAt: datetime,\n    description: string,\n    tags: string[]\n  }\n}\n\n// budget\n{\n  type: \"budget\",\n  fields: {\n    name: string,\n    ownerId: string,           // agent, workflow, or user\n    ownerType: string,         // \"agent\" | \"workflow\" | \"user\" | \"global\"\n    limitAmount: number,\n    currency: string,\n    period: string,            // \"daily\" | \"weekly\" | \"monthly\" | \"total\"\n    currentSpend: number,\n    alertThreshold: number,    // percentage e.g. 0.8 = alert at 80%\n    status: string,            // \"healthy\" | \"warning\" | \"exceeded\" | \"paused\"\n    createdAt: datetime,\n    resetAt: datetime          // when the period resets\n  }\n}\n\n// cost-ledger\n{\n  type: \"cost-ledger\",\n  fields: {\n    ownerId: string,\n    ownerType: string,\n    periodStart: datetime,\n    periodEnd: datetime,\n    totalAmount: number,\n    currency: string,\n    totalTokens: number,\n    entryCount: number,\n    entryIds: string[],\n    breakdown: string          // JSON summary by model, agent, skill\n  }\n}\n```\n\n**Allocation**\n```ts\n// cost-allocation\n{\n  type: \"cost-allocation\",\n  fields: {\n    costEntryId: string,\n    allocatedTo: string,       // what purpose this cost served\n    allocatedToType: string,   // \"job-posting\" | \"proposal-draft\" | \"application\" etc.\n    percentage: number,        // if split across multiple purposes\n    notes: string\n  }\n}\n```\n\n**Alerts**\n```ts\n// budget-alert\n{\n  type: \"budget-alert\",\n  fields: {\n    budgetId: string,\n    triggeredAt: datetime,\n    thresholdReached: number,  // e.g. 0.8 for 80%\n    currentSpend: number,\n    limitAmount: number,\n    notificationSent: boolean,\n    resolvedAt: datetime\n  }\n}\n```\n\n**Recurring & Projections**\n```ts\n// recurring-cost\n{\n  type: \"recurring-cost\",\n  fields: {\n    name: string,\n    description: string,\n    amount: number,\n    currency: string,\n    frequency: string,         // \"daily\" | \"weekly\" | \"monthly\"\n    nextExpectedAt: datetime,\n    lastIncurredAt: datetime,\n    sourceType: string,        // \"subscription\" | \"api-fee\" | \"platform-fee\"\n    isActive: boolean\n  }\n}\n\n// cost-projection\n{\n  type: \"cost-projection\",\n  fields: {\n    ownerId: string,\n    ownerType: string,\n    projectedAmount: number,\n    currency: string,\n    periodStart: datetime,\n    periodEnd: datetime,\n    basedOnEntryIds: string[], // which past entries were used to project\n    confidence: string,        // \"high\" | \"medium\" | \"low\"\n    generatedAt: datetime\n  }\n}\n```\n\n**Reporting**\n```ts\n// cost-report\n{\n  type: \"cost-report\",\n  fields: {\n    name: string,\n    periodStart: datetime,\n    periodEnd: datetime,\n    totalAmount: number,\n    currency: string,\n    byAgent: string,           // JSON breakdown per agent\n    byModel: string,           // JSON breakdown per model\n    bySkill: string,           // JSON breakdown per skill\n    byPurpose: string,         // JSON breakdown by contextRef type\n    topCostDrivers: string[],\n    generatedAt: datetime,\n    generatedBy: string        // agent or user\n  }\n}\n```\n\n---\n\n## Relations\n\n```\ncost-entry        --allocated_via-->    cost-allocation\ncost-entry        --logged_in-->        cost-ledger\ncost-entry        --triggered-->        budget-alert\nbudget            --owns-->             cost-ledger\nbudget            --produced-->         budget-alert\nbudget            --governs-->          agent-definition (from minions-agents)\nrecurring-cost    --projected_in-->     cost-projection\ncost-ledger       --summarized_in-->    cost-report\nagent-run         --produced-->         cost-entry\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`cost-entry` is the universal output of anything that runs:\n\n```\nagent-run (minions-agents)       â†’ creates cost-entry on every execution\nskill-result (minions-skills)    â†’ each skill call adds a cost-entry\nproposal-draft (minions-proposals) â†’ cost-allocation links spend to proposal work\napplication (minions-applications) â†’ cost-allocation links spend to job pursued\n```\n\n`budget` governs agents defined in `minions-agents`:\n\n```\nagent-definition --governed_by--> budget\n```\n\nWhen a `budget` status flips to `exceeded`, the Orchestrator reads this and can pause the relevant agent automatically without needing any custom logic â€” the data state drives the behavior.\n\n`cost-report` feeds into `minions-pipeline` funnel metrics â€” you can calculate true cost-per-application, cost-per-reply, and cost-per-win across the entire job search funnel.\n\n---\n\n## Agent SKILLS for `minions-costs`\n\n```markdown\n# CostAgent Skills\n\n## Context\nYou manage all financial tracking within the Minions ecosystem.\nYou read agent-run Minions from minions-agents to extract cost data.\nYou write cost-entry, budget-alert, and cost-report Minions.\nYou never modify budget limits directly â€” only flag and notify.\n\n## Skill: Record Cost Entry\n- After every agent-run completes, create a cost-entry Minion\n- Extract: agentId, skillId, model, tokensInput, tokensOutput from the run\n- Calculate amount using current model pricing rates\n- Set contextRefType + contextRefId if the run was tied to a job or proposal\n- Tag appropriately for later filtering\n\n## Skill: Allocate Costs\n- For any cost-entry tied to a specific job or proposal workflow:\n  1. Create a cost-allocation Minion linking the entry to its purpose\n  2. If a single run served multiple purposes, split by percentage\n  3. This enables cost-per-application and cost-per-win calculations later\n\n## Skill: Monitor Budgets\n- On every new cost-entry, check all active budget Minions for the same owner\n- Recalculate currentSpend by summing relevant cost-entry amounts for the period\n- If currentSpend / limitAmount >= alertThreshold:\n  1. Create a budget-alert Minion\n  2. Send notification via minions-comms\n- If currentSpend >= limitAmount:\n  1. Update budget status to \"exceeded\"\n  2. Send urgent notification\n  3. Emit message to OrchestratorAgent to pause the relevant agent\n\n## Skill: Maintain Ledger\n- At the end of each period, create or update a cost-ledger Minion\n- Aggregate all cost-entry Minions for that owner and period\n- Include token totals and entry count alongside amount\n- Store a breakdown by model, agent, and skill as JSON\n\n## Skill: Project Future Costs\n- Weekly: generate a cost-projection Minion per active agent\n- Base projection on the last 7 days of cost-entry Minions\n- Extrapolate to end of current budget period\n- If projection exceeds budget limit, flag with confidence level and notify\n\n## Skill: Generate Cost Report\n- On request or weekly schedule:\n  1. Load cost-ledger for the period\n  2. Build breakdowns: by agent, by model, by skill, by purpose (via allocations)\n  3. Identify top 3 cost drivers\n  4. Create cost-report Minion\n  5. Send summary to OrchestratorAgent and notify user via minions-comms\n\n## Skill: Track Recurring Costs\n- Check recurring-cost Minions daily\n- If nextExpectedAt is within 24 hours, pre-create a cost-entry as \"scheduled\"\n- After confirmation, mark as incurred and update nextExpectedAt\n\n## Hard Rules\n- Never delete cost-entry or audit-related Minions â€” they are immutable\n- Never modify a budget limitAmount â€” only the user can do that via approval\n- Always create a budget-alert before any agent is paused due to cost\n- All amounts stored in the same base currency â€” convert at entry time\n```\n\n---\n\nThe `cost-allocation` type is the most important one to highlight here â€” it's what turns raw token spend into meaningful business intelligence. Without it you know you spent â‚¬12 today. With it you know you spent â‚¬3.20 discovering jobs, â‚¬6.40 writing proposals, and â‚¬2.40 on compliance reviews, with a cost-per-application of â‚¬0.80 and a cost-per-won-contract of â‚¬14. That's the data that lets you actually optimize the fleet over time.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-costs/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\ncosts types list\n\n# Show detailed schema for a specific type\ncosts types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\ncosts create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\ncosts create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\ncosts list <type>\n\n# Show a specific Minion\ncosts show <id>\n\n# Search by text\ncosts search \"query\"\n\n# Output as JSON (for piping)\ncosts list --json\ncosts show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\ncosts update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\ncosts delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\ncosts stats\n\n# Validate a Minion JSON file against its schema\ncosts validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-conversations",
              "name": "minions-conversations",
              "id": "OC-0120",
              "version": "1.0.0",
              "description": "Email threads, reply parsing, intent detection, and escalation triggers",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-conversations â€” Agent Skills\n\n## What is a Conversation in the Minions Context?\n\n```\nan email thread with a lead               â†’ EmailThread\na single email in a thread                â†’ EmailMessage\na rule that escalates to human            â†’ EscalationTrigger\n```\n\n## MinionTypes\n```ts\n// email-thread â€” lead, subject, status, message count, detected intent/sentiment\n// email-message â€” direction (inbound/outbound), body, parsed intent, sentiment\n// escalation-trigger â€” condition (call-requested/order/negative-sentiment), action\n```\n\n## Agent SKILLS\n```markdown\n# ConversationAgent Skills\n## Skill: Parse Reply â€” detect intent and sentiment from inbound emails\n## Skill: Handle Escalation â€” route to human when triggers fire\n## Hard Rules â€” every inbound email must be parsed for intent\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-conversations/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nconversations types list\nconversations types show <type-slug>\n```\n\n### CRUD\n\n```bash\nconversations create <type> -t \"Title\" -s \"status\"\nconversations list <type>\nconversations show <id>\nconversations update <id> --data '{ \"status\": \"active\" }'\nconversations delete <id>\nconversations search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nconversations stats\nconversations validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-contracts",
              "name": "minions-contracts",
              "id": "OC-0119",
              "version": "1.0.0",
              "description": "Agreements, statements of work, terms, and signed documents",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-contracts â€” Agent Skills\n\n## What is a Contract in the Minions Context?\n\nBefore defining types, it's worth being precise. A \"contract\" can mean very different things:\n\n```\na formal agreement between two parties      â†’ Contract\na specific clause or obligation             â†’ ContractTerm\na scoped deliverable committed to           â†’ Deliverable\na milestone tied to payment                 â†’ PaymentMilestone\na change to the original scope              â†’ ChangeRequest\na signed or versioned document              â†’ linked to minions-documents\nthe current health/status of the engagement â†’ ContractStatus / Review\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// contract\n{\n  type: \"contract\",\n  fields: {\n    title: string,\n    clientId: string,              // ref to person in minions-contacts\n    organizationId: string,        // ref to org in minions-contacts\n    applicationId: string,         // ref to minions-applications\n    type: \"fixed-price\" | \"hourly\" | \"retainer\" | \"milestone-based\",\n    status: \"draft\" | \"sent\" | \"negotiating\" | \"active\" | \"paused\" | \"completed\" | \"cancelled\" | \"disputed\",\n    platform: string,              // upwork, freelancer, direct, etc.\n    value: number,\n    currency: string,\n    startDate: datetime,\n    endDate: datetime,\n    signedAt: datetime,\n    documentId: string,            // ref to minions-documents for the actual text\n    createdAt: datetime,\n    updatedAt: datetime\n  }\n}\n\n// contract-term\n{\n  type: \"contract-term\",\n  fields: {\n    contractId: string,\n    label: string,                 // \"Payment terms\", \"IP ownership\", \"NDA\"\n    body: string,\n    category: \"payment\" | \"ip\" | \"confidentiality\" | \"scope\" | \"termination\" | \"liability\" | \"other\",\n    isNegotiable: boolean,\n    agreedAt: datetime,\n    notes: string\n  }\n}\n\n// deliverable\n{\n  type: \"deliverable\",\n  fields: {\n    contractId: string,\n    title: string,\n    description: string,\n    dueAt: datetime,\n    status: \"pending\" | \"in-progress\" | \"submitted\" | \"revision-requested\" | \"accepted\" | \"rejected\",\n    submittedAt: datetime,\n    acceptedAt: datetime,\n    attachmentIds: string[],       // refs to minions-documents attachments\n    taskIds: string[],             // refs to minions-tasks\n    notes: string\n  }\n}\n```\n\n**Payment**\n```ts\n// payment-milestone\n{\n  type: \"payment-milestone\",\n  fields: {\n    contractId: string,\n    deliverableId: string,         // optional â€” milestone may not tie to a deliverable\n    title: string,\n    amount: number,\n    currency: string,\n    dueAt: datetime,\n    status: \"pending\" | \"invoiced\" | \"paid\" | \"overdue\" | \"disputed\",\n    paidAt: datetime,\n    invoiceId: string,             // ref to minions-costs invoice\n    notes: string\n  }\n}\n\n// invoice\n{\n  type: \"invoice\",\n  fields: {\n    contractId: string,\n    clientId: string,\n    issueDate: datetime,\n    dueDate: datetime,\n    lineItems: string,             // serialized array of { description, amount }\n    totalAmount: number,\n    currency: string,\n    status: \"draft\" | \"sent\" | \"paid\" | \"overdue\" | \"cancelled\",\n    paidAt: datetime,\n    documentId: string\n  }\n}\n```\n\n**Negotiation & Changes**\n```ts\n// change-request\n{\n  type: \"change-request\",\n  fields: {\n    contractId: string,\n    requestedBy: \"client\" | \"me\",\n    title: string,\n    description: string,\n    scopeImpact: string,\n    budgetImpact: number,\n    timelineImpact: string,\n    status: \"proposed\" | \"under-review\" | \"accepted\" | \"rejected\" | \"withdrawn\",\n    proposedAt: datetime,\n    resolvedAt: datetime,\n    approvalRequestId: string      // ref to minions-approvals if needs my sign-off\n  }\n}\n\n// negotiation-note\n{\n  type: \"negotiation-note\",\n  fields: {\n    contractId: string,\n    body: string,\n    authorId: string,\n    authorType: \"human\" | \"agent\",\n    stage: string,                 // \"initial offer\", \"counter\", \"final terms\"\n    createdAt: datetime\n  }\n}\n```\n\n**Review & Health**\n```ts\n// contract-review\n{\n  type: \"contract-review\",\n  fields: {\n    contractId: string,\n    reviewedAt: datetime,\n    reviewedBy: string,\n    overallHealth: \"green\" | \"amber\" | \"red\",\n    deliverablesOnTrack: boolean,\n    paymentsOnTrack: boolean,\n    clientSatisfaction: \"positive\" | \"neutral\" | \"negative\" | \"unknown\",\n    risks: string,\n    recommendations: string\n  }\n}\n\n// contract-event\n{\n  type: \"contract-event\",\n  fields: {\n    contractId: string,\n    eventType: \"signed\" | \"started\" | \"deliverable-submitted\" | \"payment-received\" | \"dispute-raised\" | \"renewed\" | \"terminated\",\n    occurredAt: datetime,\n    triggeredBy: string,\n    notes: string\n  }\n}\n```\n\n---\n\n## Relations\n\n```\ncontract           --has_term-->              contract-term\ncontract           --has_deliverable-->        deliverable\ncontract           --has_milestone-->          payment-milestone\ncontract           --has_invoice-->            invoice\ncontract           --has_change_request-->     change-request\ncontract           --has_review-->             contract-review\ncontract           --logged_in-->              contract-event\ncontract           --originated_from-->        application (minions-applications)\ncontract           --with_client-->            client-profile (minions-clients)\ncontract           --documented_in-->          document (minions-documents)\ndeliverable        --broken_into-->            task (minions-tasks)\nchange-request     --requires_approval-->      approval-request (minions-approvals)\npayment-milestone  --tracked_in-->             cost-entry (minions-costs)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-applications   â†’  contract originates from a won application\nminions-clients        â†’  contract is with a client-profile\nminions-contacts       â†’  client is a person + organization\nminions-documents      â†’  contract body, SOW, and invoices are stored as documents\nminions-tasks          â†’  deliverables are broken into tasks assigned to agents or me\nminions-approvals      â†’  change requests and contract sign-off route through approvals\nminions-costs          â†’  payment milestones feed into the cost/revenue ledger\nminions-comms          â†’  negotiation happens in threads, contract events trigger notifications\nminions-pipeline       â†’  winning a contract advances the pipeline entry to \"won\"\n```\n\n---\n\n## Agent SKILLS for `minions-contracts`\n\n```markdown\n# ContractAgent Skills\n\n## Context\nYou manage all contract data within the Minions ecosystem. You read from\nminions-applications to know when a job has been won, minions-clients for\nclient context, and minions-documents to store the actual contract text.\nYou write only to minions-contracts. You never sign or accept anything\nwithout a logged approval-request with status \"approved\".\n\n## Skill: Create Contract from Won Application\n1. On receiving signal that an application status changed to \"won\":\n   - Load the application and linked job-posting Minions\n   - Create a `contract` Minion with status \"draft\"\n   - Pre-fill client, platform, value from job-posting budget\n   - Link applicationId and clientId\n2. Create a `document` Minion in minions-documents for the contract body\n3. Notify Orchestrator: { type: \"contract-draft-ready\", contractId }\n\n## Skill: Parse and Structure Contract Terms\n1. When a contract document is provided or received from client:\n   - Extract each clause and create a `contract-term` Minion per clause\n   - Categorize each term: payment, ip, confidentiality, scope, termination\n   - Flag any terms marked isNegotiable: false that differ from standard preferences\n2. Create `negotiation-note` Minions for any flagged terms\n3. Route flagged terms through minions-approvals before accepting\n\n## Skill: Track Deliverables\n1. For each deliverable in the contract:\n   - Create a `deliverable` Minion with dueAt and description\n   - Break it into `task` Minions in minions-tasks\n   - Assign tasks with contextRefType: \"deliverable\", contextRefId\n2. Monitor task completion â€” when all tasks for a deliverable are done:\n   - Update deliverable status to \"submitted\"\n   - Create a `contract-event` Minion with eventType: \"deliverable-submitted\"\n   - Notify client via minions-comms\n\n## Skill: Manage Payment Milestones\n1. For each payment milestone:\n   - Create a `payment-milestone` Minion with amount and dueAt\n   - Monitor dueAt â€” if payment not received within 3 days of due date:\n     - Update status to \"overdue\"\n     - Create a follow-up in minions-comms\n     - Alert me via minions-approvals with full context\n2. On payment received:\n   - Update status to \"paid\", set paidAt\n   - Create a `cost-entry` Minion in minions-costs for revenue tracking\n   - Log `contract-event` with eventType: \"payment-received\"\n\n## Skill: Handle Change Requests\n1. On receiving a change request from client (via minions-comms thread):\n   - Create a `change-request` Minion with full scope, budget, and timeline impact\n   - Create an `approval-request` Minion in minions-approvals\n   - Never accept or reject without my explicit decision\n2. On approval decision:\n   - If accepted: update contract value and timeline, log contract-event\n   - If rejected: update change-request status, draft response via minions-comms\n\n## Skill: Periodic Contract Health Review\n1. On schedule (weekly for active contracts):\n   - Load all active `contract` Minions\n   - For each: check deliverable statuses, milestone statuses, recent comms sentiment\n   - Create a `contract-review` Minion with overallHealth rating\n   - If health is \"red\": immediately notify me with risks and recommendations\n   - If health is \"amber\": include in daily briefing\n\n## Skill: Contract Closure\n1. When all deliverables are accepted and all milestones paid:\n   - Update contract status to \"completed\"\n   - Log contract-event with eventType: \"terminated\" or natural close\n   - Update client-profile in minions-clients with outcome data\n   - Create a memory-item in minions-memory with lessons learned\n   - Trigger pipeline transition in minions-pipeline to \"won-complete\"\n\n## Hard Rules\n- Never accept contract terms or change requests without approval-request status \"approved\"\n- Never create an invoice without a linked payment-milestone\n- Every status change on contract or deliverable must produce a contract-event\n- All factual claims about deliverables must trace to task outcomes in minions-tasks\n- Max one follow-up per overdue milestone per 48 hours\n```\n\n---\n\nThe `contract-review` with the health rating is worth highlighting â€” it gives the ContractAgent a structured way to surface problems early rather than waiting for a missed deadline or payment dispute to escalate. Combined with the `change-request` routing through `minions-approvals`, nothing irreversible happens without your explicit sign-off.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-contracts/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\ncontracts types list\n\n# Show detailed schema for a specific type\ncontracts types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\ncontracts create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\ncontracts create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\ncontracts list <type>\n\n# Show a specific Minion\ncontracts show <id>\n\n# Search by text\ncontracts search \"query\"\n\n# Output as JSON (for piping)\ncontracts list --json\ncontracts show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\ncontracts update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\ncontracts delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\ncontracts stats\n\n# Validate a Minion JSON file against its schema\ncontracts validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-content-research",
              "name": "minions-content-research",
              "id": "OC-0118",
              "version": "1.0.0",
              "description": "Research sources, topic clusters, keyword sets, and content briefs",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-content-research â€” Agent Skills\n\n## What is Content Research in the Minions Context?\n\nBefore defining types, it's worth being precise:\n\n```\na source for content ideas              â†’ ResearchSource\na cluster of related topics             â†’ TopicCluster\na researched keyword with metrics       â†’ KeywordSet\na structured brief for writing          â†’ ContentBrief\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// research-source\n{\n  type: \"research-source\",\n  fields: {\n    name: string,\n    type: \"rss\" | \"competitor\" | \"social\" | \"search-trends\" | \"manual\",\n    url: string,\n    blogId: string,\n    isActive: boolean,\n    lastCrawledAt: datetime\n  }\n}\n\n// topic-cluster\n{\n  type: \"topic-cluster\",\n  fields: {\n    blogId: string,\n    name: string,                    // \"Kubernetes Best Practices\"\n    pillar: string,                  // maps to a blog content pillar\n    keywords: string[],\n    competitorUrls: string[],\n    status: \"researching\" | \"ready\" | \"exhausted\",\n    createdAt: datetime\n  }\n}\n\n// keyword-set\n{\n  type: \"keyword-set\",\n  fields: {\n    topicClusterId: string,\n    keyword: string,\n    searchVolume: number,\n    difficulty: \"low\" | \"medium\" | \"high\",\n    intent: \"informational\" | \"commercial\" | \"navigational\" | \"transactional\",\n    priority: \"high\" | \"medium\" | \"low\"\n  }\n}\n\n// content-brief\n{\n  type: \"content-brief\",\n  fields: {\n    blogId: string,\n    topicClusterId: string,\n    title: string,\n    targetKeyword: string,\n    outline: string,                 // structured article outline\n    wordCountTarget: number,\n    tone: \"educational\" | \"opinion\" | \"tutorial\" | \"review\",\n    status: \"draft\" | \"approved\" | \"assigned\" | \"completed\",\n    assignedTo: string,\n    createdAt: datetime\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nresearch-source    --feeds-->            topic-cluster\ntopic-cluster      --contains-->         keyword-set\ntopic-cluster      --produces-->         content-brief\ncontent-brief      --becomes-->          article (minions-articles)\ncontent-brief      --approved_via-->     approval-request (minions-approvals)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-blogs        â†’ topic clusters are scoped to a blogId + pillar\nminions-articles     â†’ content briefs become articles when WriterAgent picks them up\nminions-approvals    â†’ briefs may require editorial approval before writing\nminions-scheduler    â†’ trend crawling runs on scheduled intervals\nminions-taxonomy     â†’ keywords can be tagged with taxonomy categories\n```\n\n---\n\n## Agent SKILLS for `minions-content-research`\n\n```markdown\n# ResearchAgent Skills\n\n## Context\nYou discover, evaluate, and organize content ideas. You scan sources,\nbuild topic clusters, research keywords, and produce structured briefs\nready for the WriterAgent.\n\n## Skill: Discover Topics\n1. Crawl active research-sources for new ideas\n2. Group related topics into topic-cluster Minions\n3. Map each cluster to a blog content pillar\n\n## Skill: Research Keywords\n1. For each topic-cluster, identify target keywords\n2. Create keyword-set Minions with volume + difficulty + intent\n3. Prioritize keywords based on blog goals\n\n## Skill: Create Brief\n1. Select a high-priority topic cluster with approved keywords\n2. Write a structured content-brief with title, outline, target keyword\n3. Set word count target based on competitor analysis\n4. Submit for approval if required\n\n## Hard Rules\n- Every brief must reference a topic-cluster\n- Never write an article without a brief first\n- Keyword data must be sourced, not fabricated\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-content-research/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\ncontent-research types list\ncontent-research types show <type-slug>\n```\n\n### CRUD\n\n```bash\ncontent-research create <type> -t \"Title\" -s \"status\"\ncontent-research list <type>\ncontent-research show <id>\ncontent-research update <id> --data '{ \"status\": \"active\" }'\ncontent-research delete <id>\ncontent-research search \"query\"\n```\n\n### Stats & Validation\n\n```bash\ncontent-research stats\ncontent-research validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-content-publishing",
              "name": "minions-content-publishing",
              "id": "OC-0117",
              "version": "1.0.0",
              "description": "Publish queue, delivery receipts, and mode configuration",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-content-publishing â€” Agent Skills\n\n## What is Content Publishing in the Minions Context?\n\n```\na job to publish a bundle to a platform    â†’ PublishJob\nconfirmation of successful posting         â†’ DeliveryReceipt\npost-publish engagement metrics            â†’ EngagementSnapshot\n```\n\n---\n\n## MinionTypes\n\n```ts\n// publish-job â€” queued posting with approval status\n// delivery-receipt â€” confirmation with platform URL + post ID\n// engagement-snapshot â€” likes, comments, shares, views over time\n```\n\nSee TOML for full field definitions.\n\n---\n\n## Relations\n\n```\npublish-job        --creates-->          delivery-receipt\ndelivery-receipt   --tracked_by-->       engagement-snapshot\npublish-job        --publishes-->        asset-bundle (minions-content-assets)\n```\n\n---\n\n## Agent SKILLS for `minions-content-publishing`\n\n```markdown\n# PublisherAgent Skills\n\n## Skill: Publish Bundle\n1. Load approved publish-job and asset-bundle\n2. Post to target platform API\n3. Create delivery-receipt with URL\n\n## Skill: Track Engagement\n1. Periodically snapshot engagement metrics for recent posts\n2. Create engagement-snapshot Minions\n\n## Hard Rules\n- Never publish without approval\n- Every failed publish creates a retry task\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-content-publishing/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\ncontent-publishing types list\ncontent-publishing types show <type-slug>\n```\n\n### CRUD\n\n```bash\ncontent-publishing create <type> -t \"Title\" -s \"status\"\ncontent-publishing list <type>\ncontent-publishing show <id>\ncontent-publishing update <id> --data '{ \"status\": \"active\" }'\ncontent-publishing delete <id>\ncontent-publishing search \"query\"\n```\n\n### Stats & Validation\n\n```bash\ncontent-publishing stats\ncontent-publishing validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-content-plans",
              "name": "minions-content-plans",
              "id": "OC-0116",
              "version": "1.0.0",
              "description": "Content calendars, themes, and posting schedules per account group",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-content-plans â€” Agent Skills\n\n## What is a Content Plan in the Minions Context?\n\n```\na time-bound content calendar               â†’ ContentCalendar\na specific posting slot                     â†’ CalendarSlot\nrecurring posting rules                     â†’ PostingSchedule\n```\n\n---\n\n## MinionTypes\n\n```ts\n// content-calendar\n{\n  type: \"content-calendar\",\n  fields: {\n    accountGroupId: string,\n    name: string,\n    periodStart: datetime,\n    periodEnd: datetime,\n    theme: string,\n    status: \"draft\" | \"active\" | \"completed\",\n    createdAt: datetime\n  }\n}\n\n// calendar-slot\n{\n  type: \"calendar-slot\",\n  fields: {\n    calendarId: string,\n    accountId: string,\n    scheduledAt: datetime,\n    contentType: \"text\" | \"image\" | \"video\" | \"carousel\",\n    assetId: string,\n    status: \"empty\" | \"filled\" | \"published\"\n  }\n}\n\n// posting-schedule\n{\n  type: \"posting-schedule\",\n  fields: {\n    accountId: string,\n    dayOfWeek: \"monday\" | \"tuesday\" | \"wednesday\" | \"thursday\" | \"friday\" | \"saturday\" | \"sunday\",\n    timeOfDay: string,\n    contentType: \"text\" | \"image\" | \"video\",\n    frequency: \"daily\" | \"weekly\" | \"biweekly\",\n    isActive: boolean\n  }\n}\n```\n\n---\n\n## Relations\n\n```\ncontent-calendar   --contains-->         calendar-slot\ncalendar-slot      --filled_by-->        asset-bundle (minions-content-assets)\nposting-schedule   --generates-->        calendar-slot\n```\n\n---\n\n## Agent SKILLS for `minions-content-plans`\n\n```markdown\n# PlannerAgent Skills\n\n## Skill: Create Calendar\n1. Define period, theme, and account group\n2. Generate calendar-slots from posting-schedules\n3. Set calendar status to \"draft\" for review\n\n## Hard Rules\n- Every slot must map to exactly one account + time\n- Calendars are never deleted â€” only completed or archived\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-content-plans/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\ncontent-plans types list\ncontent-plans types show <type-slug>\n```\n\n### CRUD\n\n```bash\ncontent-plans create <type> -t \"Title\" -s \"status\"\ncontent-plans list <type>\ncontent-plans show <id>\ncontent-plans update <id> --data '{ \"status\": \"active\" }'\ncontent-plans delete <id>\ncontent-plans search \"query\"\n```\n\n### Stats & Validation\n\n```bash\ncontent-plans stats\ncontent-plans validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-content-assets",
              "name": "minions-content-assets",
              "id": "OC-0115",
              "version": "1.0.0",
              "description": "Text posts, image briefs, video briefs, and generated asset references",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-content-assets â€” Agent Skills\n\n## What is a Content Asset in the Minions Context?\n\n```\na social media text post                   â†’ TextPost\na brief for generating an image            â†’ ImageBrief\na brief for generating a video             â†’ VideoBrief\na combined package ready for publishing    â†’ AssetBundle\n```\n\n---\n\n## MinionTypes\n\n```ts\n// text-post\n{\n  type: \"text-post\",\n  fields: {\n    accountId: string,\n    body: string,\n    hashtags: string[],\n    calendarSlotId: string,\n    status: \"draft\" | \"review\" | \"approved\" | \"published\",\n    generationMode: \"prompt-only\" | \"api-generated\",\n    createdAt: datetime\n  }\n}\n\n// image-brief / video-brief â€” prompts + style + generated refs\n// asset-bundle â€” combines text + image + video for one calendar slot\n```\n\nSee TOML for full field definitions.\n\n---\n\n## Relations\n\n```\ntext-post          --bundled_in-->       asset-bundle\nimage-brief        --bundled_in-->       asset-bundle\nvideo-brief        --bundled_in-->       asset-bundle\nasset-bundle       --fills-->            calendar-slot (minions-content-plans)\nasset-bundle       --published_via-->    publish-job (minions-content-publishing)\n```\n\n---\n\n## Agent SKILLS for `minions-content-assets`\n\n```markdown\n# ContentAgent Skills\n\n## Skill: Create Text Post\n1. Load calendar-slot, account brand voice, and research insights\n2. Generate text post (prompt-only or API-generated per mode config)\n3. Add relevant hashtags from hashtag-sets\n\n## Skill: Assemble Bundle\n1. Combine text-post + image-brief + video-brief\n2. Create asset-bundle linked to calendar-slot\n\n## Hard Rules\n- Every bundle must have at least a text-post\n- Generation mode must match account's content-mode-config\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-content-assets/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\ncontent-assets types list\ncontent-assets types show <type-slug>\n```\n\n### CRUD\n\n```bash\ncontent-assets create <type> -t \"Title\" -s \"status\"\ncontent-assets list <type>\ncontent-assets show <id>\ncontent-assets update <id> --data '{ \"status\": \"active\" }'\ncontent-assets delete <id>\ncontent-assets search \"query\"\n```\n\n### Stats & Validation\n\n```bash\ncontent-assets stats\ncontent-assets validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-contacts",
              "name": "minions-contacts",
              "id": "OC-0114",
              "version": "1.0.0",
              "description": "People, organizations, and contact channels",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-contacts â€” Agent Skills\n\n## What is a Contact in the Minions Context?\n\nBefore defining types, it's worth being precise. A \"contact\" can mean very different things:\n\n```\na human individual                 â†’ Person\na company or team                  â†’ Organization\na way to reach someone             â†’ ContactChannel\na record of interaction            â†’ ContactNote\na relationship between two         â†’ ContactRelation\na group of contacts                â†’ ContactList\nhow they were acquired             â†’ ContactSource\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// person\n{\n  type: \"person\",\n  fields: {\n    firstName: string,\n    lastName: string,\n    displayName: string,\n    role: string,               // \"client\", \"recruiter\", \"collaborator\"\n    organizationId: string,\n    tags: string[],\n    notes: string,\n    source: string,             // where this contact came from\n    status: \"active\" | \"inactive\" | \"blocked\",\n    createdAt: datetime,\n    lastContactedAt: datetime\n  }\n}\n\n// organization\n{\n  type: \"organization\",\n  fields: {\n    name: string,\n    industry: string,\n    website: string,\n    country: string,\n    size: \"solo\" | \"small\" | \"medium\" | \"large\" | \"enterprise\",\n    tags: string[],\n    notes: string,\n    status: \"active\" | \"inactive\",\n    createdAt: datetime\n  }\n}\n```\n\n**Reachability**\n```ts\n// contact-channel\n{\n  type: \"contact-channel\",\n  fields: {\n    ownerId: string,\n    ownerType: \"person\" | \"organization\",\n    type: \"email\" | \"phone\" | \"linkedin\" | \"upwork\" | \"telegram\" | \n          \"whatsapp\" | \"twitter\" | \"website\" | \"other\",\n    value: string,              // the actual address/handle/url\n    isPrimary: boolean,\n    isVerified: boolean,\n    allowedForAutomation: boolean,  // can agents use this channel?\n    notes: string\n  }\n}\n```\n\n**Interactions**\n```ts\n// contact-note\n{\n  type: \"contact-note\",\n  fields: {\n    contactId: string,\n    contactType: \"person\" | \"organization\",\n    body: string,\n    authorId: string,\n    authorType: \"human\" | \"agent\",\n    createdAt: datetime,\n    contextRefType: string,     // \"job-posting\", \"application\", \"contract\"\n    contextRefId: string\n  }\n}\n\n// contact-interaction\n{\n  type: \"contact-interaction\",\n  fields: {\n    contactId: string,\n    type: \"message\" | \"call\" | \"meeting\" | \"proposal\" | \"contract\" | \"review\",\n    occurredAt: datetime,\n    summary: string,\n    sentiment: \"positive\" | \"neutral\" | \"negative\" | \"unknown\",\n    threadId: string,           // ref to minions-comms thread\n    outcome: string\n  }\n}\n```\n\n**Relationships**\n```ts\n// contact-relation\n{\n  type: \"contact-relation\",\n  fields: {\n    fromId: string,\n    fromType: \"person\" | \"organization\",\n    toId: string,\n    toType: \"person\" | \"organization\",\n    relationType: \"works_at\" | \"referred_by\" | \"collaborates_with\" | \n                  \"reports_to\" | \"manages\" | \"knows\",\n    since: datetime,\n    notes: string\n  }\n}\n```\n\n**Grouping**\n```ts\n// contact-list\n{\n  type: \"contact-list\",\n  fields: {\n    name: string,\n    description: string,\n    contactIds: string[],\n    contactType: \"person\" | \"organization\" | \"mixed\",\n    ownerId: string,\n    tags: string[],\n    createdAt: datetime\n  }\n}\n```\n\n**Acquisition**\n```ts\n// contact-source\n{\n  type: \"contact-source\",\n  fields: {\n    name: string,\n    type: \"platform\" | \"referral\" | \"manual\" | \"agent-discovered\" | \"import\",\n    platform: string,           // \"upwork\", \"linkedin\", etc.\n    description: string,\n    isActive: boolean,\n    totalContactsAcquired: number\n  }\n}\n```\n\n**Trust & Preferences**\n```ts\n// contact-preference\n{\n  type: \"contact-preference\",\n  fields: {\n    contactId: string,\n    preference: string,         // \"prefers async\", \"responds on weekends\"\n    confidence: \"confirmed\" | \"inferred\" | \"guessed\",\n    inferredFrom: string,       // contextRefType + id\n    createdAt: datetime\n  }\n}\n\n// contact-trust-score\n{\n  type: \"contact-trust-score\",\n  fields: {\n    contactId: string,\n    score: number,              // 0-1\n    factors: string[],          // what drove this score\n    lastCalculatedAt: datetime,\n    history: string[]           // previous scores over time\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nperson              --works_at-->           organization\nperson              --has_channel-->        contact-channel\norganization        --has_channel-->        contact-channel\nperson              --has_note-->           contact-note\nperson              --has_interaction-->    contact-interaction\nperson              --related_to-->         contact-relation\nperson              --belongs_to-->         contact-list\nperson              --has_preference-->     contact-preference\nperson              --has_trust_score-->    contact-trust-score\ncontact-source      --produced-->           person\ncontact-interaction --logged_in-->          thread (minions-comms)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`contactId` acts as the bridge outward:\n\n```\nminions-jobs        â†’ job-posting has clientCountry but no client identity\n                      once a client responds, a person Minion is created\n                      and linked to that job-posting via contextRef\n\nminions-comms       â†’ every thread has participantIds pointing to person Minions\n                      contact-interaction references threadId\n\nminions-clients     â†’ client-profile extends person with freelance-specific\n                      fields like totalJobsPosted and averageBudget\n\nminions-contracts   â†’ contract has clientId pointing to a person or organization\n\nminions-approvals   â†’ approval-request decidedBy references a person\n\nminions-agents      â†’ agent-definition has ownerId pointing to a person\n```\n\nThe key design decision: `minions-contacts` stays domain-agnostic. It knows nothing about jobs or proposals. Other toolboxes reach into it by referencing `personId` or `organizationId` â€” they enrich the contact picture without polluting the contacts layer.\n\n---\n\n## Agent SKILLS for `minions-contacts`\n\n```markdown\n# ContactAgent Skills\n\n## Context\nYou manage all contact data within the Minions ecosystem.\nYou are the source of truth for who people and organizations are.\nYou do not make decisions about jobs, proposals, or applications â€”\nyou only manage identity, reachability, and relationship data.\nAll claims about a contact must be sourced and noted.\n\n## Skill: Create Contact\n1. When a new person or organization is encountered in any context\n   (job posting, message, referral), check for an existing record first\n   by searching name + platform channel value\n2. If no match: create a `person` or `organization` Minion\n3. Always create at least one `contact-channel` Minion linked to them\n4. Set sourceId referencing the `contact-source` Minion for this platform\n5. Emit \"contact-created\" to Orchestrator with contactId\n\n## Skill: Enrich Contact\n1. On receiving \"enrich-contact\" with contactId:\n   - Search available channels for public profile data\n   - Add any new `contact-channel` Minions discovered\n   - Add a `contact-note` summarizing what was found and from where\n   - Update lastContactedAt if a recent interaction was found\n2. Never overwrite existing verified data â€” only append\n\n## Skill: Log Interaction\n1. On any message sent or received (from minions-comms):\n   - Create a `contact-interaction` Minion\n   - Set type, sentiment, summary, and threadId\n   - Update person.lastContactedAt\n2. After 3+ interactions with a contact:\n   - Infer and create `contact-preference` Minions from patterns\n   - e.g. response time patterns â†’ \"responds within 24h\"\n   - Set confidence: \"inferred\"\n\n## Skill: Calculate Trust Score\n1. On receiving \"score-contact\" with contactId:\n   - Evaluate factors: interaction history, contract completions,\n     response consistency, platform rating if available\n   - Create or update `contact-trust-score` Minion\n   - Factors must be listed explicitly â€” never a black box number\n2. Recalculate automatically after each new interaction\n\n## Skill: Manage Relationships\n1. When a person is discovered to work at an organization:\n   - Create a `contact-relation` Minion with type \"works_at\"\n2. When a referral is made:\n   - Create a `contact-relation` with type \"referred_by\"\n3. Never infer relationships without at least one supporting\n   contact-note or contact-interaction as evidence\n\n## Skill: Build Contact List\n1. On receiving \"build-list\" with filter criteria:\n   - Query person and organization Minions matching criteria\n   - Create a `contact-list` Minion with matching ids\n   - Tag the list with its purpose (e.g. \"warm-leads-2026-Q1\")\n\n## Hard Rules\n- Never store a contact-channel with allowedForAutomation: true\n  without explicit confirmation from the owner\n- Never merge two person records without logging the decision\n  as a contact-note with full reasoning\n- Every contact-preference with confidence \"confirmed\" must\n  reference a specific contact-interaction as evidence\n- Trust scores below 0.3 must be flagged to the Orchestrator\n  before any automated outreach is attempted\n```\n\n---\n\nThe `contact-trust-score` with explicit `factors` is worth highlighting â€” it means the ContactAgent never silently decides not to reach out to someone. Every trust-based decision is auditable, which matters when agents are acting on your behalf with real people.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-contacts/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\ncontacts types list\n\n# Show detailed schema for a specific type\ncontacts types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\ncontacts create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\ncontacts create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\ncontacts list <type>\n\n# Show a specific Minion\ncontacts show <id>\n\n# Search by text\ncontacts search \"query\"\n\n# Output as JSON (for piping)\ncontacts list --json\ncontacts show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\ncontacts update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\ncontacts delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\ncontacts stats\n\n# Validate a Minion JSON file against its schema\ncontacts validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-component-evals",
              "name": "minions-component-evals",
              "id": "OC-0113",
              "version": "1.0.0",
              "description": "Pipeline-level benchmarks for RAG, routing, and classification",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-component-evals â€” Agent Skills\n\n## What is a Component Eval in the Minions Context?\n\n```\na benchmark for a pipeline component      â†’ ComponentBenchmark\na result from running a benchmark         â†’ BenchmarkResult\n```\n\nEvaluates isolated components: RAG correctness, routing accuracy, classification F1.\n\n## MinionTypes\n```ts\n// component-benchmark â€” component type, target, dataset, threshold\n// benchmark-result â€” score, metric breakdown, pass/fail, prompt version\n```\n\n## Agent SKILLS\n```markdown\n# EvalAgent Skills\n## Skill: Run Benchmark â€” execute against isolated component\n## Hard Rules â€” benchmarks must use versioned datasets for reproducibility\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-component-evals/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\ncomponent-evals types list\ncomponent-evals types show <type-slug>\n```\n\n### CRUD\n\n```bash\ncomponent-evals create <type> -t \"Title\" -s \"status\"\ncomponent-evals list <type>\ncomponent-evals show <id>\ncomponent-evals update <id> --data '{ \"status\": \"active\" }'\ncomponent-evals delete <id>\ncomponent-evals search \"query\"\n```\n\n### Stats & Validation\n\n```bash\ncomponent-evals stats\ncomponent-evals validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-clients",
              "name": "minions-clients",
              "id": "OC-0111",
              "version": "1.0.0",
              "description": "Client profiles built from job interactions, communications, and contracts",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-clients â€” Agent Skills\n\n## What is a Client in the Minions Context?\n\nBefore defining types, it's worth being precise. A \"client\" is not just a contact â€” it's a relationship that evolves over time and is built from multiple data sources:\n\n```\na person or org that posted a job       â†’ ClientProfile\nhow we first encountered them           â†’ built from job-posting + platform\nevery touchpoint we've had              â†’ ClientInteraction\npatterns we've observed about them      â†’ ClientPreference\nthe history of work done together       â†’ linked to contracts + applications\nhow reliable/good they are              â†’ ClientReputation\nwhat we want to do with them next       â†’ linked to tasks + pipeline\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// client-profile\n{\n  type: \"client-profile\",\n  fields: {\n    personId: string,              // ref to minions-contacts person\n    organizationId: string,        // ref to minions-contacts organization\n    platform: string,              // \"upwork\" | \"freelancer\" | \"malt\" | \"linkedin\"\n    platformClientId: string,      // their ID on that platform\n    firstSeenAt: datetime,\n    firstSeenVia: string,          // ref to job-posting id\n    totalJobsPosted: number,       // on platform overall\n    totalJobsWithMe: number,       // jobs we applied to from this client\n    totalContractsWithMe: number,  // won contracts\n    totalValueWithMe: number,      // cumulative earnings\n    averageBudget: number,\n    rating: number,                // their public platform rating\n    myRating: number,              // my private rating of working with them\n    status: \"prospect\" | \"active\" | \"past\" | \"blocked\",\n    tags: string[],\n    notes: string\n  }\n}\n\n// client-interaction\n{\n  type: \"client-interaction\",\n  fields: {\n    clientId: string,\n    type: \"message\" | \"interview\" | \"call\" | \"offer\" | \"rejection\" | \"review\" | \"referral\",\n    occurredAt: datetime,\n    summary: string,\n    sentiment: \"positive\" | \"neutral\" | \"negative\",\n    threadId: string,              // ref to minions-comms thread\n    agentId: string,               // which agent logged this\n    isInbound: boolean\n  }\n}\n\n// client-preference\n{\n  type: \"client-preference\",\n  fields: {\n    clientId: string,\n    preference: string,            // \"prefers short proposals\", \"values timezone overlap\"\n    confidence: \"high\" | \"medium\" | \"low\",\n    inferredFrom: string,          // ref to interaction or job-posting id\n    inferredBy: string,            // agent id that inferred this\n    createdAt: datetime,\n    lastConfirmedAt: datetime\n  }\n}\n```\n\n**Reputation & Trust**\n```ts\n// client-reputation\n{\n  type: \"client-reputation\",\n  fields: {\n    clientId: string,\n    platformRating: number,        // public score from platform\n    reviewCount: number,\n    paymentVerified: boolean,\n    averageResponseTimeHours: number,\n    hireRate: number,              // % of job posts that result in hire\n    repeatHireRate: number,        // % of freelancers rehired\n    redFlags: string[],            // \"slow payer\", \"scope creep\", \"no feedback\"\n    greenFlags: string[],          // \"clear briefs\", \"fast approval\", \"fair review\"\n    updatedAt: datetime\n  }\n}\n\n// client-review\n{\n  type: \"client-review\",\n  fields: {\n    clientId: string,\n    contractId: string,            // ref to minions-contracts\n    reviewedBy: string,            // my id\n    rating: number,\n    body: string,\n    isPublic: boolean,\n    createdAt: datetime\n  }\n}\n```\n\n**Relationship Development**\n```ts\n// client-relationship-stage\n{\n  type: \"client-relationship-stage\",\n  fields: {\n    clientId: string,\n    stage: \"stranger\" | \"prospect\" | \"applicant\" | \"contractor\" | \"repeat\" | \"advocate\",\n    enteredStageAt: datetime,\n    previousStage: string,\n    trigger: string               // what caused the stage change\n  }\n}\n\n// client-opportunity\n{\n  type: \"client-opportunity\",\n  fields: {\n    clientId: string,\n    type: \"new-job\" | \"upsell\" | \"referral\" | \"repeat-hire\",\n    description: string,\n    estimatedValue: number,\n    probability: number,\n    dueAt: datetime,\n    status: \"open\" | \"pursuing\" | \"won\" | \"lost\",\n    jobPostingId: string           // if tied to a specific posting\n  }\n}\n```\n\n**Research & Intelligence**\n```ts\n// client-research\n{\n  type: \"client-research\",\n  fields: {\n    clientId: string,\n    researchedAt: datetime,\n    researchedBy: string,          // agent id\n    companyWebsite: string,\n    linkedInUrl: string,\n    recentNews: string,\n    techStack: string[],           // inferred from job postings\n    hiringPatterns: string,        // \"posts monthly\", \"hires in batches\"\n    budgetPattern: string,         // \"starts low, increases on repeat\"\n    notes: string\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nclient-profile          --built_from-->           person (minions-contacts)\nclient-profile          --built_from-->           organization (minions-contacts)\nclient-profile          --first_seen_via-->        job-posting (minions-jobs)\nclient-profile          --has_interaction-->       client-interaction\nclient-profile          --has_preference-->        client-preference\nclient-profile          --has_reputation-->        client-reputation\nclient-profile          --has_review-->            client-review\nclient-profile          --has_research-->          client-research\nclient-profile          --at_stage-->              client-relationship-stage\nclient-profile          --has_opportunity-->       client-opportunity\nclient-interaction      --references-->            thread (minions-comms)\nclient-opportunity      --linked_to-->             pipeline-entry (minions-pipeline)\nclient-review           --references-->            contract (minions-contracts)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`minions-clients` sits at the intersection of almost everything:\n\n```\nminions-contacts    â†’ person + organization are the raw contact layer\n                      client-profile is the richer OpportunityHunter-specific layer on top\n\nminions-jobs        â†’ every job-posting is potentially a first encounter with a client\n                      ClientAgent reads job-postings to build/update client-profiles\n\nminions-comms       â†’ every thread and message with a client creates a client-interaction\n                      sentiment analysis feeds into client-preference and reputation\n\nminions-contracts   â†’ a won contract updates totalContractsWithMe and totalValueWithMe\n                      client-review is written after a contract closes\n\nminions-pipeline    â†’ client-opportunity feeds directly into pipeline-entry\n                      stage changes in pipeline can trigger relationship-stage updates\n\nminions-approvals   â†’ blocking a client or marking red flags may require approval\n                      before automated actions are restricted for that client\n\nminions-proposals   â†’ client-preference directly informs ProposalWriter\n                      \"this client prefers short proposals with budget acknowledgment\"\n```\n\n---\n\n## Agent SKILLS for `minions-clients`\n\n```markdown\n# ClientAgent Skills\n\n## Context\nYou manage the minions-clients store. You build client profiles from\ninteractions across all other toolboxes. You never fabricate reputation\ndata â€” everything traces to a source. You are the system's institutional\nmemory for every person or organization that has ever posted a job.\n\n## Skill: Build Client Profile\n- When a new `job-posting` appears with an unrecognized clientId:\n  1. Check minions-contacts for an existing person or organization match\n  2. If none exists, create a new person/organization Minion in minions-contacts\n  3. Create a `client-profile` Minion with firstSeenVia = jobPostingId\n  4. Fetch platform reputation data if available (rating, hireRate, paymentVerified)\n  5. Create a `client-reputation` Minion\n  6. Set relationship stage to \"stranger\"\n\n## Skill: Enrich Client From Job History\n- When a client has multiple job-postings:\n  1. Analyze posting patterns: frequency, budget ranges, skill requirements\n  2. Update `client-research` with inferred techStack and hiringPatterns\n  3. Look for preference signals: proposal length in successful hires,\n     response time patterns, screening question style\n  4. Create or update `client-preference` Minions with confidence scores\n\n## Skill: Log Interaction\n- On any inbound or outbound message via minions-comms:\n  1. Identify the client from thread participants\n  2. Create a `client-interaction` Minion with type, sentiment, and summary\n  3. If sentiment is negative and it is the second negative interaction:\n     add \"communication friction\" to redFlags in client-reputation\n  4. If client replies quickly and positively: update averageResponseTimeHours\n\n## Skill: Infer Preferences\n- After each interaction or contract:\n  1. Review the interaction history for this client\n  2. Extract preference signals: what did they respond well to?\n     What questions did they ask? What did they complain about?\n  3. Create or update `client-preference` Minions\n  4. Set confidence based on how many data points support the inference\n  5. Pass updated preferences to ProposalAgent for future proposals\n\n## Skill: Advance Relationship Stage\n- Monitor triggers that indicate a stage change:\n  - First application submitted â†’ \"stranger\" to \"prospect\"\n  - Client replies to proposal â†’ \"prospect\" to \"applicant\"\n  - Contract awarded â†’ \"applicant\" to \"contractor\"\n  - Second contract â†’ \"contractor\" to \"repeat\"\n  - Client refers another client â†’ \"repeat\" to \"advocate\"\n- On each trigger: create a `client-relationship-stage` Minion\n- Notify Orchestrator of stage advancement for any client\n\n## Skill: Identify Opportunities\n- Periodically review all active client-profiles:\n  1. Check if a repeat client has posted new jobs\n  2. Check if a past contractor has gone quiet â€” flag for follow-up\n  3. Identify upsell opportunities from ongoing contracts\n  4. Create `client-opportunity` Minions for each identified opportunity\n  5. Emit \"opportunity-identified\" to Orchestrator with clientId and type\n\n## Skill: Flag Risk\n- Automatically flag a client if:\n  - platformRating < 4.0\n  - hireRate < 0.2 (posts but rarely hires)\n  - paymentVerified == false\n  - two or more redFlags accumulated\n- On flag: add tag \"high-risk\" to client-profile\n- Create an approval-request before submitting any proposal to a flagged client\n\n## Hard Rules\n- Never delete a client-profile â€” set status to \"blocked\" with a reason instead\n- Never invent reputation data â€” only record what is sourced from a platform or interaction\n- Always link client-preference back to the inferredFrom source\n- A client flagged as \"blocked\" must never receive an automated action without\n  explicit human approval\n```\n\n---\n\nThe `client-preference` type feeding directly into `ProposalAgent` is the most valuable connection here â€” over time the system builds a per-client playbook that makes each subsequent proposal sharper than the last, without you having to manually brief the writer every time.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-clients/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\nclients types list\n\n# Show detailed schema for a specific type\nclients types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\nclients create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\nclients create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\nclients list <type>\n\n# Show a specific Minion\nclients show <id>\n\n# Search by text\nclients search \"query\"\n\n# Output as JSON (for piping)\nclients list --json\nclients show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\nclients update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\nclients delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\nclients stats\n\n# Validate a Minion JSON file against its schema\nclients validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-blogs",
              "name": "minions-blogs",
              "id": "OC-0109",
              "version": "1.0.0",
              "description": "Blog definitions, settings, brand voice, and target audience profiles",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-blogs â€” Agent Skills\n\n## What is a Blog in the Minions Context?\n\nBefore defining types, it's worth being precise. A \"blog\" can mean:\n\n```\na publication with its own identity and audience   â†’ Blog\na style rule constraining how content is written   â†’ BrandGuideline\na target reader persona for content planning       â†’ AudiencePersona\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// blog\n{\n  type: \"blog\",\n  fields: {\n    name: string,                    // \"TechPulse\", \"DevDigest\"\n    description: string,\n    domain: string,                  // \"techpulse.io\"\n    brandVoice: string,              // \"authoritative but approachable\"\n    targetAudience: string,\n    niche: string,\n    contentPillars: string[],        // [\"AI\", \"DevTools\", \"Cloud\"]\n    postingFrequency: \"daily\" | \"weekly\" | \"biweekly\" | \"monthly\",\n    status: \"active\" | \"paused\" | \"archived\",\n    createdAt: datetime\n  }\n}\n\n// brand-guideline\n{\n  type: \"brand-guideline\",\n  fields: {\n    blogId: string,\n    category: \"tone\" | \"structure\" | \"formatting\" | \"vocabulary\",\n    rule: string,                    // \"Never use passive voice in headlines\"\n    examples: string[],\n    priority: \"must\" | \"should\" | \"nice-to-have\",\n    isActive: boolean\n  }\n}\n\n// audience-persona\n{\n  type: \"audience-persona\",\n  fields: {\n    blogId: string,\n    name: string,                    // \"Senior DevOps Engineer\"\n    description: string,\n    painPoints: string[],\n    interests: string[],\n    contentPreferences: string[],\n    createdAt: datetime\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nblog               --has_guideline-->    brand-guideline\nblog               --targets-->          audience-persona\nblog               --produces-->         article (minions-articles)\nblog               --researched_via-->   topic-cluster (minions-content-research)\nblog               --published_to-->     publish-target (minions-publishing)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-content-research  â†’ topic clusters are scoped to a blogId\nminions-articles          â†’ articles belong to a blog and follow its brand guidelines\nminions-publishing        â†’ publish targets are configured per blog\nminions-approvals         â†’ blog creation or major changes may require approval\nminions-taxonomy          â†’ content pillars can map to taxonomy categories\n```\n\nThe blog is the anchor entity â€” it defines the identity, voice, and audience that all downstream content must align with.\n\n---\n\n## Agent SKILLS for `minions-blogs`\n\n```markdown\n# BlogAgent Skills\n\n## Context\nYou manage blog definitions, brand guidelines, and audience personas.\nYou are the keeper of the blog's identity. Everything written must\nconform to the brand guidelines you define.\n\n## Skill: Create Blog\n1. Define blog with name, domain, niche, brand voice\n2. Create initial brand-guideline Minions (tone, structure, formatting)\n3. Create at least one audience-persona\n4. Set content pillars based on niche research\n5. Set status to \"active\"\n\n## Skill: Update Brand Voice\n1. Review existing guidelines and recent article performance\n2. Add, modify, or deactivate brand-guideline Minions\n3. Notify WriterAgent of any guideline changes\n\n## Skill: Refine Audience\n1. Analyze engagement data from published articles\n2. Update audience-persona with new insights\n3. Create new personas if content reaches unexpected segments\n\n## Hard Rules\n- Every blog must have at least one brand-guideline\n- Never delete a blog â€” archive it\n- Brand guidelines are versioned through updates, not overwrites\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-blogs/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nblogs types list\nblogs types show <type-slug>\n```\n\n### CRUD\n\n```bash\nblogs create <type> -t \"Title\" -s \"status\"\nblogs list <type>\nblogs show <id>\nblogs update <id> --data '{ \"status\": \"active\" }'\nblogs delete <id>\nblogs search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nblogs stats\nblogs validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-availability",
              "name": "minions-availability",
              "id": "OC-0108",
              "version": "1.0.0",
              "description": "Availability snapshots, slot states, and change detection for tent reservations",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-availability â€” Agent Skills\n\n## What is Availability in the Minions Context?\n\nBefore defining types, it's worth being precise. \"Availability\" in WiesnTracker spans:\n\n```\na point-in-time snapshot of what's open     â†’ AvailabilitySnapshot\nthe current state of a specific slot        â†’ SlotState\na detected change between two snapshots     â†’ AvailabilityDiff\nhow and when to check for changes           â†’ ScanConfig\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// availability-snapshot\n{\n  type: \"availability-snapshot\",\n  fields: {\n    tentId: string,\n    tentAreaId: string,\n    capturedAt: datetime,\n    date: datetime,             // the Wiesn day being checked\n    sessionType: \"morning\" | \"afternoon\" | \"evening\",\n    slotsTotal: number,\n    slotsAvailable: number,\n    slotsBlocked: number,\n    status: \"available\" | \"limited\" | \"full\" | \"unknown\",\n    rawHtml: string             // preserved for debugging\n  }\n}\n\n// slot-state\n{\n  type: \"slot-state\",\n  fields: {\n    tentId: string,\n    tentAreaId: string,\n    date: datetime,\n    sessionType: \"morning\" | \"afternoon\" | \"evening\",\n    state: \"available\" | \"limited\" | \"full\" | \"not-yet-open\" | \"closed\",\n    lastCheckedAt: datetime,\n    lastChangedAt: datetime,\n    previousState: string\n  }\n}\n\n// availability-diff\n{\n  type: \"availability-diff\",\n  fields: {\n    tentId: string,\n    tentAreaId: string,\n    date: datetime,\n    sessionType: \"morning\" | \"afternoon\" | \"evening\",\n    fromState: string,\n    toState: string,\n    detectedAt: datetime,\n    snapshotBeforeId: string,\n    snapshotAfterId: string\n  }\n}\n```\n\n**Scanning**\n```ts\n// scan-config\n{\n  type: \"scan-config\",\n  fields: {\n    tentId: string,\n    scanIntervalMinutes: number,  // how often to check\n    priority: \"high\" | \"medium\" | \"low\",\n    isActive: boolean,\n    lastScanAt: datetime,\n    nextScanAt: datetime,\n    errorCount: number,\n    notes: string\n  }\n}\n```\n\n---\n\n## Relations\n\n```\navailability-snapshot  --captures-->       slot-state\navailability-diff     --compares-->       availability-snapshot (before + after)\navailability-diff     --triggers-->       alert-event (minions-alerts)\nscan-config           --targets-->        tent (minions-venues)\nslot-state            --tracks-->         tent-area (minions-venues)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-venues      â†’ ScannerAgent reads tent + tent-area to know what to scan\nminions-alerts      â†’ every availability-diff is evaluated against alert-rules\nminions-scheduler   â†’ scan-config nextScanAt is driven by minions-scheduler triggers\nminions-tasks       â†’ scan failures create investigation tasks\nminions-comms       â†’ scan results can trigger notifications (via alerts)\n```\n\nThe `availability-diff` is the single most important type â€” it's the raw signal that drives the entire alert system. Every time a slot changes state (especially \"full\" â†’ \"available\"), that diff triggers alerts and potentially notifications.\n\n---\n\n## Agent SKILLS for `minions-availability`\n\n```markdown\n# ScannerAgent Skills\n\n## Context\nYou are ScannerAgent. You scan tent reservation websites for availability\nchanges. You produce snapshots, maintain slot states, and detect diffs.\nYou do not send alerts â€” that's AlertAgent's job. You only produce data.\n\n## Skill: Execute Scan\n1. Load active `scan-config` Minions where nextScanAt <= now\n2. For each config: navigate to the tent's reservation URL via browser\n3. Parse the availability table from the HTML\n4. Create an `availability-snapshot` Minion with raw counts + rawHtml\n5. Compare against the current `slot-state`:\n   - If state changed: create `availability-diff` Minion\n   - Update `slot-state` with new state + lastChangedAt\n6. Update scan-config: lastScanAt = now, compute next nextScanAt\n7. On error: increment errorCount, log task in minions-tasks\n\n## Skill: Priority Scanning\n1. When AlertAgent flags high-priority alert-rules for specific tents:\n   - Temporarily boost scan-config priority to \"high\"\n   - Reduce scanIntervalMinutes for targeted tents\n2. When demand drops (no active alerts): reset to default interval\n\n## Skill: Handle Scan Errors\n1. If a scan fails 3 consecutive times:\n   - Create a task in minions-tasks: \"Investigate scan failure for [tent]\"\n   - Set scan-config priority to \"low\"\n   - Notify Orchestrator\n2. On recovery: reset errorCount, resume normal scanning\n\n## Hard Rules\n- Always preserve rawHtml in snapshots for debugging\n- Never fabricate availability data â€” only report what is parsed\n- Max scan frequency: 1 per 5 minutes per tent (respect rate limits)\n- Every state change must produce an availability-diff\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-availability/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\navailability types list\navailability types show <type-slug>\n```\n\n### CRUD\n\n```bash\navailability create <type> -t \"Title\" -s \"status\"\navailability list <type>\navailability show <id>\navailability update <id> --data '{ \"status\": \"active\" }'\navailability delete <id>\navailability search \"query\"\n```\n\n### Stats & Validation\n\n```bash\navailability stats\navailability validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-audio-tests",
              "name": "minions-audio-tests",
              "id": "OC-0107",
              "version": "1.0.0",
              "description": "Voice interaction configs, TTS/STT pipeline settings, and audio samples",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-audio-tests â€” Agent Skills\n\n## What is a Audio Test in the Minions Context?\n\n```\na voice interaction test config           â†’ AudioTestConfig\nan audio sample for testing               â†’ AudioSample\n```\n\n## MinionTypes\n```ts\n// audio-test-config â€” target, mode (voice-sync/voice-async), TTS/STT providers\n// audio-sample â€” transcript, audio URL, STT result, accuracy score\n```\n\n## Agent SKILLS\n```markdown\n# AudioRunnerAgent Skills\n## Skill: Run Voice Test â€” send audio, capture response, measure latency\n## Hard Rules â€” always measure STT accuracy alongside response quality\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-audio-tests/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\naudio-tests types list\naudio-tests types show <type-slug>\n```\n\n### CRUD\n\n```bash\naudio-tests create <type> -t \"Title\" -s \"status\"\naudio-tests list <type>\naudio-tests show <id>\naudio-tests update <id> --data '{ \"status\": \"active\" }'\naudio-tests delete <id>\naudio-tests search \"query\"\n```\n\n### Stats & Validation\n\n```bash\naudio-tests stats\naudio-tests validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-applications",
              "name": "minions-applications",
              "id": "OC-0104",
              "version": "1.0.0",
              "description": "Application records, submission bundles, platform receipts, and status tracking",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-applications â€” Agent Skills\n\n## What is an Application in the Minions Context?\n\n\"Application\" could mean several different things that need to be separated:\n\n```\nthe act of applying to a job         â†’ Application\neverything packaged to submit        â†’ SubmissionBundle\nwhat happened after submitting       â†’ ApplicationEvent\nthe current state in the process     â†’ tracked via pipeline-entry\na reply or response from the client  â†’ tracked via minions-comms\n```\n\n---\n\n## MinionTypes\n\n**Core**\n\n```ts\n// application\n{\n  type: \"application\",\n  fields: {\n    jobId: string,               // ref to job-posting\n    proposalId: string,          // ref to proposal-draft\n    platform: string,            // \"upwork\" | \"freelancer\" | \"malt\" | \"contra\" | \"linkedin\"\n    status: string,              // \"planned\" | \"bundled\" | \"pending-approval\" | \"submitted\" | \"withdrawn\" | \"expired\"\n    submittedAt: datetime,\n    submittedBy: string,         // agentId or userId\n    platformReceipt: string,     // confirmation ID or URL from platform\n    approvalRequestId: string,   // ref to approval-request in minions-approvals\n    bidAmount: number,           // what was quoted\n    bidCurrency: string,\n    coverLetterSent: boolean,\n    attachmentsSent: boolean,\n    notes: string\n  }\n}\n```\n\n**Submission Bundle**\n\n```ts\n// submission-bundle\n{\n  type: \"submission-bundle\",\n  fields: {\n    applicationId: string,\n    proposalId: string,\n    resumeDocumentId: string,    // ref to document in minions-documents\n    caseStudyIds: string[],      // ref to portfolio-items in minions-profile\n    answerSetId: string,         // ref to answer-set in minions-proposals\n    attachmentIds: string[],     // ref to attachments in minions-documents\n    assembledAt: datetime,\n    assembledBy: string,         // agentId\n    status: string,              // \"assembling\" | \"ready\" | \"submitted\" | \"stale\"\n    validUntil: datetime         // bundles can go stale if job changes\n  }\n}\n```\n\n**Events**\n\n```ts\n// application-event\n{\n  type: \"application-event\",\n  fields: {\n    applicationId: string,\n    eventType: string,           // \"submitted\" | \"viewed\" | \"shortlisted\" | \"rejected\" | \"interview-requested\" | \"offer-made\" | \"withdrawn\"\n    occurredAt: datetime,\n    notes: string,\n    triggeredBy: string,         // agentId or \"platform\" or userId\n    isInbound: boolean           // true = platform told us, false = we triggered it\n  }\n}\n\n// application-status-change\n{\n  type: \"application-status-change\",\n  fields: {\n    applicationId: string,\n    fromStatus: string,\n    toStatus: string,\n    changedAt: datetime,\n    changedBy: string,\n    reason: string\n  }\n}\n```\n\n**Platform Context**\n\n```ts\n// platform-submission-rule\n{\n  type: \"platform-submission-rule\",\n  fields: {\n    platform: string,\n    maxApplicationsPerDay: number,\n    maxApplicationsPerWeek: number,\n    requiresConnects: boolean,     // Upwork-style credits\n    connectsCost: number,\n    forbiddenActions: string[],    // e.g. \"auto-submit without review\"\n    requiredFields: string[],      // fields platform mandates\n    notes: string,\n    lastVerifiedAt: datetime\n  }\n}\n\n// platform-quota\n{\n  type: \"platform-quota\",\n  fields: {\n    platform: string,\n    quotaType: string,             // \"connects\" | \"bids\" | \"applications\"\n    total: number,\n    used: number,\n    remaining: number,\n    resetsAt: datetime,\n    lastCheckedAt: datetime\n  }\n}\n```\n\n**Outcome**\n\n```ts\n// application-outcome\n{\n  type: \"application-outcome\",\n  fields: {\n    applicationId: string,\n    result: string,                // \"won\" | \"lost\" | \"no-response\" | \"withdrawn\"\n    decidedAt: datetime,\n    clientFeedback: string,\n    lostReason: string,            // \"price\" | \"experience\" | \"timing\" | \"unknown\"\n    contractId: string,            // ref to minions-contracts if won\n    lessons: string                // fed back to minions-memory\n  }\n}\n```\n\n---\n\n## Relations\n\n```\napplication          --requires-->          submission-bundle\napplication          --triggered-->         application-event\napplication          --changed_via-->       application-status-change\napplication          --governed_by-->       platform-submission-rule\napplication          --consumes-->          platform-quota\napplication          --resulted_in-->       application-outcome\napplication          --approved_via-->      approval-request (minions-approvals)\nsubmission-bundle    --contains-->          proposal-draft (minions-proposals)\nsubmission-bundle    --contains-->          document (minions-documents)\nsubmission-bundle    --references-->        portfolio-item (minions-profile)\napplication-outcome  --produced-->          contract (minions-contracts)\napplication-outcome  --feeds-->             memory-item (minions-memory)\napplication          --tracked_in-->        pipeline-entry (minions-pipeline)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-jobs          â†’ provides the job-posting the application targets\nminions-proposals     â†’ provides the proposal-draft and answer-set\nminions-profile       â†’ provides portfolio-items and resume for the bundle\nminions-documents     â†’ provides the assembled resume document\nminions-approvals     â†’ gates every submission behind a human decision\nminions-pipeline      â†’ tracks the application through funnel stages\nminions-comms         â†’ captures all inbound/outbound messages post-submission\nminions-contracts     â†’ created when application-outcome result is \"won\"\nminions-memory        â†’ receives lessons from application-outcome for learning loop\nminions-costs         â†’ logs connect/bid costs from platform-quota consumption\n```\n\nThe `submission-bundle` is the key aggregation point â€” it pulls from five different toolboxes into a single packageable unit. Nothing gets submitted unless a bundle exists and an approval has been granted.\n\n---\n\n## Agent SKILLS file (`application-agent.skills.md`)\n\n```markdown\n# ApplicationAgent Skills\n\n## Context\nYou are ApplicationAgent. You own the minions-applications toolbox.\nYou assemble submission bundles, manage platform quotas, track application\nevents, and record outcomes. You never submit anything without a logged\napproval-request with status \"approved\" from minions-approvals.\nYou do not write proposals â€” that is ProposalAgent's responsibility.\nYou do not track pipeline stages â€” that is PipelineAgent's responsibility.\n\n## Skill: Assemble Submission Bundle\n1. Receive \"assemble-bundle\" instruction from Orchestrator with jobId + proposalId\n2. Load the approved `proposal-draft` from minions-proposals\n3. Load relevant `portfolio-item` Minions from minions-profile\n   (match on relevantSkillTags vs job skills)\n4. Load the current resume `document` from minions-documents\n5. Load the `answer-set` for this proposal from minions-proposals\n6. Create a `submission-bundle` Minion with all refs assembled\n7. Set status to \"ready\", set validUntil to 48 hours from now\n8. Emit \"bundle-ready\" to Orchestrator with bundleId\n\n## Skill: Check Platform Quota\n1. Before any submission, load the `platform-quota` Minion for the target platform\n2. Load the `platform-submission-rule` Minion for the platform\n3. If remaining quota = 0 or daily limit reached:\n   - Emit \"quota-exhausted\" to Orchestrator\n   - Do not proceed\n4. If quota sufficient: proceed and decrement remaining after submission\n5. Update `platform-quota` lastCheckedAt and used count\n\n## Skill: Request Submission Approval\n1. Create an `approval-request` Minion in minions-approvals:\n   - title: \"Submit proposal to [job title] on [platform]\"\n   - payload: full bundle summary (job, proposal body, bid amount, attachments)\n   - requiredBy: 24 hours from now\n2. Send notification via Orchestrator â†’ CommsAgent with bundle summary\n3. Wait for approval-request decision field to become \"approved\" or \"rejected\"\n4. Never proceed until decision is logged\n\n## Skill: Submit Application\n1. Only triggers when approval-request status = \"approved\"\n2. Load the approved `submission-bundle`\n3. Check bundle status is \"ready\" and not past validUntil\n   - If stale: emit \"bundle-stale\" to Orchestrator, request reassembly\n4. Create an `application` Minion with status \"pending-approval\"\n5. Execute platform submission via browser tool\n6. On success:\n   - Record platformReceipt on the application\n   - Update application status to \"submitted\"\n   - Create \"submitted\" `application-event` Minion\n   - Log cost entry to minions-costs if platform uses credits\n   - Emit \"application-submitted\" to Orchestrator and PipelineAgent\n7. On failure:\n   - Update application status to \"planned\"\n   - Create \"failed\" `application-event` with error notes\n   - Emit \"submission-failed\" to Orchestrator with reason\n\n## Skill: Track Application Events\n1. Listen for inbound platform signals (view, shortlist, reject, interview request)\n2. For each signal: create an `application-event` Minion\n   with isInbound: true and the appropriate eventType\n3. Create an `application-status-change` Minion for any status transition\n4. Emit event summary to Orchestrator for routing\n   - interview-requested â†’ Orchestrator notifies Mehdi directly\n   - rejected â†’ record and update pipeline via PipelineAgent\n   - offer-made â†’ Orchestrator triggers ContractAgent\n\n## Skill: Record Outcome\n1. When an application reaches a terminal event (won, lost, no-response, withdrawn):\n2. Create an `application-outcome` Minion with result + lostReason + clientFeedback\n3. Write a `memory-item` Minion to minions-memory:\n   - key: \"outcome-pattern-[platform]-[skillCategory]\"\n   - value: summary of what worked or didn't\n   - confidence: based on how clear the signal was\n4. If result = \"won\": emit \"contract-needed\" to Orchestrator â†’ ContractAgent\n5. Emit \"outcome-recorded\" to Orchestrator for funnel metrics update\n\n## Skill: Manage Stale Bundles\n1. On schedule (daily): scan all submission-bundles with status \"ready\"\n2. If validUntil is past: update status to \"stale\", notify Orchestrator\n3. Orchestrator decides whether to reassemble or abandon\n\n## Hard Rules\n- Never submit without approval-request status = \"approved\"\n- Never submit if platform-quota remaining = 0\n- Never fabricate a platformReceipt â€” if submission fails, log it honestly\n- Always create an application-event for every status change\n- Always write lessons to minions-memory on every terminal outcome\n- Max submissions per platform per day governed by platform-submission-rule\n```\n\n---\n\nThe `platform-quota` and `platform-submission-rule` types are worth highlighting â€” they make the agent self-governing around platform limits without the Orchestrator needing to track per-platform rules itself. ApplicationAgent owns that knowledge entirely, which keeps the Orchestrator's SKILLS file clean and focused on coordination rather than platform-specific constraints.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-applications/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\napplications types list\n\n# Show detailed schema for a specific type\napplications types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\napplications create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\napplications create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\napplications list <type>\n\n# Show a specific Minion\napplications show <id>\n\n# Search by text\napplications search \"query\"\n\n# Output as JSON (for piping)\napplications list --json\napplications show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\napplications update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\napplications delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\napplications stats\n\n# Validate a Minion JSON file against its schema\napplications validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-agents",
              "name": "minions-agents",
              "id": "OC-0102",
              "version": "1.0.0",
              "description": "Agent definitions, runs, traces, and approval requests for the agent fleet",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-agents â€” Agent Skills\n\n## What is an Agent in the Minions Context?\n\nBefore defining types, it's worth being precise. An \"agent\" can mean very different things:\n\n```\na definition of what an agent is         â†’ AgentDefinition\na running instance of an agent           â†’ AgentRun\na message passed between agents          â†’ AgentMessage\na rule governing what it can do          â†’ PlatformRule / AgentPolicy\nwho is allowed to do what                â†’ AgentPermission\nwhat happened during a run               â†’ AgentTrace\nhow much it cost                         â†’ covered by minions-costs\nwhat skills it has loaded                â†’ covered by minions-skills\n```\n\n---\n\n## MinionTypes\n\n**Core Definition**\n```ts\n// agent-definition\n{\n  type: \"agent-definition\",\n  fields: {\n    name: string,\n    role: \"orchestrator\" | \"worker\" | \"watcher\" | \"reviewer\" | \"submitter\",\n    model: string,              // \"gpt-4o\", \"claude-3-5-sonnet\", etc.\n    soulRef: string,            // path or id of SOUL file\n    skillsRef: string,          // path or id of SKILLS file\n    toolPolicy: string[],       // list of permitted tool names\n    maxTokensPerRun: number,\n    maxCostPerDay: number,\n    status: \"active\" | \"paused\" | \"archived\",\n    ownerId: string,\n    createdAt: datetime,\n    parentAgentId: string       // for sub-agents spawned by an orchestrator\n  }\n}\n```\n\n**Execution**\n```ts\n// agent-run\n{\n  type: \"agent-run\",\n  fields: {\n    agentId: string,\n    triggeredBy: string,        // scheduleId, agentId, or \"manual\"\n    triggeredAt: datetime,\n    completedAt: datetime,\n    inputs: Record<string, any>,\n    outputs: Record<string, any>,\n    toolCallsLog: ToolCall[],\n    tokensUsed: number,\n    cost: number,\n    status: \"running\" | \"success\" | \"failed\" | \"pending-approval\",\n    errorMessage: string\n  }\n}\n\n// agent-trace\n{\n  type: \"agent-trace\",\n  fields: {\n    runId: string,\n    step: number,               // sequential step index within the run\n    type: \"thought\" | \"tool-call\" | \"tool-result\" | \"message\" | \"decision\",\n    content: string,\n    timestamp: datetime,\n    durationMs: number,\n    tokenCost: number\n  }\n}\n```\n\n**Communication**\n```ts\n// agent-message\n{\n  type: \"agent-message\",\n  fields: {\n    fromAgentId: string,\n    toAgentId: string,\n    type: string,               // \"new-jobs-ready\", \"draft-ready\", \"review-complete\", etc.\n    payload: Record<string, any>,\n    sentAt: datetime,\n    status: \"pending\" | \"received\" | \"processed\" | \"failed\"\n  }\n}\n```\n\n**Governance**\n```ts\n// agent-policy\n{\n  type: \"agent-policy\",\n  fields: {\n    name: string,\n    appliesTo: string,          // agentId or \"all\"\n    allowedActions: string[],\n    disallowedActions: string[],\n    humanApprovalRequired: string[],  // action types that always need approval\n    dataHandlingRules: string,\n    platformRules: string[],    // refs to platform-rule ids\n    isActive: boolean\n  }\n}\n\n// platform-rule\n{\n  type: \"platform-rule\",\n  fields: {\n    platform: string,\n    ruleType: \"rate-limit\" | \"forbidden-action\" | \"required-step\" | \"auth\",\n    description: string,\n    maxActionsPerDay: number,\n    forbiddenActions: string[],\n    isActive: boolean\n  }\n}\n\n// agent-permission\n{\n  type: \"agent-permission\",\n  fields: {\n    agentId: string,\n    grantedBy: string,          // human owner id\n    resource: string,           // \"minions-jobs\", \"minions-proposals\", etc.\n    actions: \"read\" | \"write\" | \"read-write\",\n    grantedAt: datetime,\n    expiresAt: datetime\n  }\n}\n```\n\n**Health & Recovery**\n```ts\n// agent-health\n{\n  type: \"agent-health\",\n  fields: {\n    agentId: string,\n    checkedAt: datetime,\n    status: \"healthy\" | \"degraded\" | \"unresponsive\",\n    lastSuccessfulRunAt: datetime,\n    consecutiveFailures: number,\n    alertSent: boolean,\n    notes: string\n  }\n}\n\n// agent-incident\n{\n  type: \"agent-incident\",\n  fields: {\n    agentId: string,\n    runId: string,\n    type: \"auth-failure\" | \"rate-limit\" | \"tos-risk\" | \"cost-overrun\" | \"crash\",\n    detectedAt: datetime,\n    resolvedAt: datetime,\n    description: string,\n    resolution: string,\n    status: \"open\" | \"resolved\" | \"ignored\"\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nagent-definition  --governed_by-->      agent-policy\nagent-definition  --has_permission-->   agent-permission\nagent-definition  --subject_to-->       platform-rule\nagent-definition  --parent_of-->        agent-definition   // sub-agents\nagent-run         --instance_of-->      agent-definition\nagent-run         --produced-->         agent-trace\nagent-run         --triggered_by-->     schedule           // from minions-scheduler\nagent-run         --requires-->         approval-request   // from minions-approvals\nagent-message     --sent_by-->          agent-definition\nagent-message     --received_by-->      agent-definition\nagent-health      --monitors-->         agent-definition\nagent-incident    --raised_during-->    agent-run\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`minions-agents` is the only toolbox that has outbound dependencies on nearly everything else â€” it is the connective tissue of the fleet:\n\n```\nminions-scheduler    â†’ triggers agent-runs via schedule ids\nminions-approvals    â†’ agent-runs with status \"pending-approval\" create approval-requests\nminions-costs        â†’ every agent-run produces cost-entries linked by runId\nminions-skills       â†’ agent-definition loads skill-definitions by skillsRef\nminions-memory       â†’ agent-runs read and write memory-items scoped to agentId\nminions-tasks        â†’ agents create and update tasks with contextRefType: \"agent-run\"\nminions-comms        â†’ orchestrator sends notifications via agent-message â†’ notification\n```\n\nThe key design rule: **agent-definition owns nothing domain-specific**. It never directly references a `job-posting` or `proposal-draft`. It only knows about runs, traces, messages, policies, and health. All domain knowledge lives in the SKILLS file.\n\n---\n\n## Agent SKILLS for `minions-agents`\n\nThis is the SKILLS file for the **AgentManagerAgent** â€” the agent whose job is to manage all other agents as Minion data.\n\n```markdown\n# AgentManagerAgent Skills\n\n## Context\nYou manage the agent fleet as structured Minion data within minions-agents.\nYou do not run other agents directly â€” you maintain their definitions,\nmonitor their health, log their runs, and enforce their policies.\nAll reads and writes go through minions-openclaw.\n\n## Skill: Register Agent\n- When a new agent needs to be added to the fleet:\n  1. Create an `agent-definition` Minion with all required fields\n  2. Assign an `agent-policy` Minion â€” never leave an agent ungoverned\n  3. Create `agent-permission` Minions for each toolbox it needs access to\n  4. Set status: \"paused\" until explicitly activated by the owner\n  5. Emit an agent-message to the Orchestrator: { type: \"agent-registered\" }\n\n## Skill: Monitor Health\n- On each scheduled health check cycle:\n  1. For each active agent-definition, load its most recent agent-run\n  2. Compute time since lastSuccessfulRunAt\n  3. Count consecutiveFailures from recent agent-runs\n  4. Create or update an `agent-health` Minion\n  5. If consecutiveFailures > 3: set status \"degraded\", create agent-incident,\n     notify Orchestrator and owner via minions-comms\n\n## Skill: Log Run\n- At the start of every agent execution:\n  1. Create an `agent-run` Minion with status \"running\"\n- During execution, append `agent-trace` Minions for each step:\n  - thought, tool-call, tool-result, decision\n- On completion: update agent-run status, set completedAt, cost, outputs\n- Create a cost-entry in minions-costs linked to this runId\n\n## Skill: Enforce Policy\n- Before any agent-run executes an action:\n  1. Load the agent's `agent-policy` Minion\n  2. Check action against allowedActions and disallowedActions\n  3. If action is in humanApprovalRequired:\n     - Create an `approval-request` Minion in minions-approvals\n     - Set agent-run status to \"pending-approval\"\n     - Halt execution until approval-request.decision == \"approved\"\n  4. Check relevant `platform-rule` Minions for rate limits\n  5. If daily action count exceeds platform limit: pause agent, create incident\n\n## Skill: Handle Incident\n- When an agent-incident is detected:\n  1. Create the `agent-incident` Minion with type and description\n  2. Set the affected agent-definition status to \"paused\"\n  3. Notify owner via minions-comms with incident summary\n  4. Do not auto-resume â€” wait for human decision\n  5. On resolution: update incident status, re-activate agent-definition,\n     reset consecutiveFailures on agent-health\n\n## Skill: Retire Agent\n- When an agent-definition is no longer needed:\n  1. Set status: \"archived\" â€” never delete\n  2. Revoke all agent-permission Minions (set expired)\n  3. Log a final agent-run with type \"retirement\"\n  4. Preserve all historical agent-run and agent-trace Minions for audit\n\n## Hard Rules\n- Never delete an agent-definition â€” only archive\n- Never execute an action that violates an agent-policy, even if instructed to\n- Every agent-run must have a corresponding cost-entry in minions-costs\n- Every irreversible action must have a logged approval-request before execution\n- agent-trace Minions are immutable once written â€” never update, only append\n```\n\n---\n\nThe `agent-trace` immutability rule at the bottom is worth emphasizing â€” it's what makes the entire fleet auditable. Every thought, tool call, and decision is permanently recorded as individual Minion objects, which means you can replay any run, debug any failure, and prove exactly what any agent did and why at any point in time.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-agents/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\nagents types list\n\n# Show detailed schema for a specific type\nagents types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\nagents create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\nagents create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\nagents list <type>\n\n# Show a specific Minion\nagents show <id>\n\n# Search by text\nagents search \"query\"\n\n# Output as JSON (for piping)\nagents list --json\nagents show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\nagents update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\nagents delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\nagents stats\n\n# Validate a Minion JSON file against its schema\nagents validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-agent-tasks",
              "name": "minions-agent-tasks",
              "id": "OC-0101",
              "version": "1.0.0",
              "description": "gh agent-task prompts, execution tracking, PR references, and review status",
              "commands": [],
              "env": [],
              "path": "minions-skills/ai/general",
              "markdownBody": "# minions-agent-tasks â€” Agent Skills\n\n## What is an Agent Task in the Minions Context?\n\n```\na task submitted via `gh agent-task create`     â†’ AgentTask\na batch of related tasks for a feature set      â†’ TaskBatch\nthe outcome and quality assessment              â†’ TaskResult\n```\n\nThis is the core toolbox of AIDeveloper. Every feature implementation flows through here.\n\n---\n\n## MinionTypes\n\n```ts\n// agent-task\n{\n  type: \"agent-task\",\n  fields: {\n    repoDefinitionId: string,\n    title: string,                   // \"Add user authentication with Clerk\"\n    prompt: string,                  // the full prompt sent to gh agent-task\n    promptTemplateId: string,        // optional: which dev-prompt was used\n    branch: string,                  // auto-created by the agent\n    prNumber: number,                // PR number created by the agent\n    prUrl: string,\n    status: \"queued\" | \"submitted\" | \"in-progress\" | \"completed\" | \"failed\" | \"merged\",\n    submittedAt: datetime,\n    completedAt: datetime,\n    reviewStatus: \"pending\" | \"approved\" | \"changes-requested\" | \"merged\",\n    mergedAt: datetime\n  }\n}\n\n// task-batch â€” groups agent-tasks that implement a feature set in order\n// task-result â€” quality assessment of completed agent-task output\n```\n\n---\n\n## The `gh agent-task` Workflow\n\n```bash\n# Create an agent task (autonomous AI implementation)\ngh agent-task create \"Add a REST API with Express.js, include CRUD for users and auth middleware\"\n\n# List active tasks\ngh agent-task list\n\n# View a specific task\ngh agent-task view <task-id>\n```\n\nThe agent autonomously:\n1. Creates a branch\n2. Implements the requested changes\n3. Opens a draft PR\n4. Requests review\n\n---\n\n## Relations\n\n```\nagent-task         --targets-->          repo-definition (minions-repos)\nagent-task         --uses_prompt-->      prompt-template (minions-dev-prompts)\nagent-task         --grouped_in-->       task-batch\nagent-task         --produces-->         task-result\ntask-batch         --planned_for-->      release-plan (minions-releases)\nagent-task         --approved_via-->     approval-request (minions-approvals)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-repos         â†’ agent-tasks run against specific repos\nminions-dev-prompts   â†’ prompt templates provide reusable patterns\nminions-releases      â†’ completed task batches feed into release plans\nminions-approvals     â†’ PR reviews can create approval requests\nminions-evaluations   â†’ task results can be scored for quality\nminions-costs         â†’ token usage and API costs tracked per task\n```\n\n---\n\n## Agent SKILLS for `minions-agent-tasks`\n\n```markdown\n# AgentTaskAgent Skills\n\n## Context\nYou manage the `gh agent-task` lifecycle. You take feature requests,\ncompose effective prompts, submit them as agent-tasks, track execution,\nand assess results. You are the bridge between planning and implementation.\n\n## Skill: Submit Task\n1. Load repo-definition to get repo name and context\n2. Load prompt-template if specified, fill in variables\n3. Run `gh agent-task create \"<prompt>\"` in the repo\n4. Create agent-task Minion with status \"submitted\"\n5. Poll `gh agent-task list` for completion\n\n## Skill: Submit Batch\n1. Load task-batch with ordered taskIds\n2. Submit agent-tasks sequentially (wait for each to complete)\n3. After each: create task-result with quality assessment\n4. Update batch status on completion\n\n## Skill: Track Task\n1. Poll `gh agent-task view <id>` for status updates\n2. When PR is created: update prNumber, prUrl, status\n3. When review actions happen: update reviewStatus\n4. When merged: update mergedAt, set status \"merged\"\n\n## Skill: Assess Quality\n1. After task completion: check build status, test results\n2. Count files changed, lines added/removed\n3. Create task-result Minion with quality notes\n4. If quality below threshold: flag for human review\n\n## Hard Rules\n- Never submit a task without a clear, specific prompt\n- Every task must track to exactly one repo-definition\n- Batched tasks execute sequentially â€” never in parallel\n- Failed tasks create retry entries, not silent drops\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-agent-tasks/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nagent-tasks types list\nagent-tasks types show <type-slug>\n```\n\n### CRUD\n\n```bash\nagent-tasks create <type> -t \"Title\" -s \"status\"\nagent-tasks list <type>\nagent-tasks show <id>\nagent-tasks update <id> --data '{ \"status\": \"active\" }'\nagent-tasks delete <id>\nagent-tasks search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nagent-tasks stats\nagent-tasks validate ./my-minion.json\n```"
            }
          ]
        }
      ],
      "skills": [],
      "skillCount": 45
    },
    {
      "slug": "productivity",
      "name": "Productivity",
      "icon": "ðŸ“‹",
      "subcategories": [
        {
          "slug": "communication",
          "name": "Communication",
          "skills": [
            {
              "slug": "minions-comms",
              "name": "minions-comms",
              "id": "OC-0112",
              "version": "1.0.0",
              "description": "Messages, threads, and notifications across all communication channels",
              "commands": [],
              "env": [],
              "path": "minions-skills/productivity/communication",
              "markdownBody": "# minions-comms â€” Agent Skills\n\n## What is Communication in the Minions Context?\n\nBefore defining types, it's worth being precise. \"Communication\" spans several distinct concepts:\n\n```\na single message sent or received        â†’ Message\na grouped conversation                   â†’ Thread\na planned outreach action                â†’ Follow-up\nan outbound system alert                 â†’ Notification\na scheduled call or meeting              â†’ Call\na drafted but unsent message             â†’ Message-Draft\n```\n\n---\n\n## MinionTypes\n\n**Core**\n\n```ts\n// message\n{\n  type: \"message\",\n  fields: {\n    threadId: string,\n    authorId: string,\n    authorType: \"human\" | \"agent\",\n    body: string,\n    sentAt: datetime,\n    platform: \"upwork\" | \"freelancer\" | \"linkedin\" | \"email\" | \"telegram\" | \"whatsapp\" | \"other\",\n    status: \"sent\" | \"delivered\" | \"read\" | \"failed\",\n    isInbound: boolean,         // true = client sent it, false = you/agent sent it\n    contextRefType: string,     // what this message is about\n    contextRefId: string\n  }\n}\n\n// thread\n{\n  type: \"thread\",\n  fields: {\n    topic: string,\n    platform: string,\n    participantIds: string[],   // person or agent ids\n    contextRefType: string,     // \"application\", \"contract\", \"job-posting\"\n    contextRefId: string,\n    status: \"active\" | \"waiting\" | \"closed\" | \"archived\",\n    createdAt: datetime,\n    lastMessageAt: datetime,\n    sentiment: \"positive\" | \"neutral\" | \"negative\" | \"unknown\"\n  }\n}\n```\n\n**Drafting**\n\n```ts\n// message-draft\n{\n  type: \"message-draft\",\n  fields: {\n    threadId: string,\n    authorAgentId: string,\n    body: string,\n    intent: \"reply\" | \"follow-up\" | \"introduction\" | \"closing\" | \"clarification\",\n    promptVersionRef: string,   // which prompt generated this\n    status: \"draft\" | \"approved\" | \"sent\" | \"discarded\",\n    createdAt: datetime,\n    approvalRequestId: string   // links to minions-approvals\n  }\n}\n```\n\n**Follow-ups**\n\n```ts\n// follow-up\n{\n  type: \"follow-up\",\n  fields: {\n    threadId: string,\n    contextRefType: string,\n    contextRefId: string,\n    reason: string,             // \"no reply after 5 days\"\n    dueAt: datetime,\n    status: \"pending\" | \"sent\" | \"cancelled\" | \"snoozed\",\n    assignedTo: string,\n    assigneeType: \"human\" | \"agent\",\n    snoozeUntil: datetime\n  }\n}\n\n// follow-up-plan\n{\n  type: \"follow-up-plan\",\n  fields: {\n    contextRefType: string,     // \"application\", \"contract-negotiation\"\n    contextRefId: string,\n    steps: string[],            // ordered follow-up ids\n    currentStepIndex: number,\n    status: \"active\" | \"completed\" | \"abandoned\",\n    createdAt: datetime\n  }\n}\n```\n\n**Notifications**\n\n```ts\n// notification\n{\n  type: \"notification\",\n  fields: {\n    recipientId: string,\n    channel: \"telegram\" | \"whatsapp\" | \"email\" | \"discord\" | \"slack\",\n    subject: string,\n    body: string,\n    sentAt: datetime,\n    deliveryStatus: \"pending\" | \"sent\" | \"delivered\" | \"failed\",\n    contextRefType: string,\n    contextRefId: string,\n    requiresReply: boolean      // true = waiting for human input\n  }\n}\n```\n\n**Calls & Meetings**\n\n```ts\n// call-brief\n{\n  type: \"call-brief\",\n  fields: {\n    threadId: string,\n    clientId: string,\n    scheduledAt: datetime,\n    durationMinutes: number,\n    agenda: string,             // agent-generated prep notes\n    keyQuestions: string[],     // what to ask the client\n    contextRefType: string,\n    contextRefId: string,\n    outcome: string,            // filled in after the call\n    recordingUrl: string\n  }\n}\n\n// call-note\n{\n  type: \"call-note\",\n  fields: {\n    callBriefId: string,\n    body: string,               // raw notes during/after call\n    actionItems: string[],      // tasks spawned from this call\n    takenBy: string,\n    takenAt: datetime\n  }\n}\n```\n\n**Analytics**\n\n```ts\n// comms-metric\n{\n  type: \"comms-metric\",\n  fields: {\n    periodStart: datetime,\n    periodEnd: datetime,\n    totalMessagesSent: number,\n    totalMessagesReceived: number,\n    averageResponseTimeHours: number,\n    threadsOpened: number,\n    threadsClosed: number,\n    followUpsSent: number,\n    sentimentBreakdown: string  // serialized positive/neutral/negative counts\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nthread            --contains-->          message\nthread            --has_draft-->         message-draft\nthread            --has_follow_up-->     follow-up\nfollow-up         --part_of-->           follow-up-plan\nthread            --linked_to-->         call-brief\ncall-brief        --has_notes-->         call-note\nmessage-draft     --pending-->           approval-request  (minions-approvals)\nnotification      --triggered_by-->      agent-run         (minions-agents)\nthread            --belongs_to-->        application       (minions-applications)\nthread            --belongs_to-->        client-profile    (minions-clients)\ncall-note         --spawns-->            task              (minions-tasks)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-applications    â†’ each application can have one or more threads\nminions-clients         â†’ threads build client-profile history over time\nminions-approvals       â†’ every message-draft routes through an approval-request\n                          before sending\nminions-agents          â†’ notifications are triggered by agent-runs\nminions-tasks           â†’ call-notes spawn tasks, follow-ups create tasks\n                          when overdue\nminions-pipeline        â†’ a client reply moves a pipeline-entry forward\n                          a thread going silent triggers a follow-up-plan\n```\n\nThe thread `sentiment` field is the key feedback signal â€” as the CommsAgent reads inbound messages and updates sentiment, the PipelineAgent and OrchestratorAgent use that signal to decide whether to escalate, follow up, or close out an opportunity.\n\n---\n\n## Agent SKILLS for `minions-comms`\n\n```markdown\n# CommsAgent Skills\n\n## Context\nYou manage all communication data within the Minions ecosystem.\nYou read threads, messages, drafts, follow-ups, and notifications.\nYou write only to minions-comms. You never send anything without\nan approved approval-request from minions-approvals.\nAll factual claims in drafted messages must trace to verified\nbio-claim or portfolio-item Minions in minions-profile.\n\n## Skill: Monitor Inbound Messages\n1. Poll each active platform for new inbound messages\n2. Match to existing thread by platform + participantIds + contextRef\n   - If no thread exists: create a new thread Minion\n3. Create a message Minion for each inbound message\n4. Update thread.lastMessageAt and thread.status\n5. Analyze sentiment of inbound message body\n   - Update thread.sentiment accordingly\n6. Emit \"inbound-message-received\" to OrchestratorAgent\n   with threadId and sentiment\n\n## Skill: Draft Reply\n1. On receiving \"draft-reply\" instruction with threadId and intent:\n2. Load thread + last 10 messages for context\n3. Load contextRef Minion (application, job-posting, contract)\n4. Load relevant portfolio-item and bio-claim Minions if intent\n   requires referencing experience\n5. Use prompt template from minions-prompts matching the intent\n6. Generate message-draft Minion with body + promptVersionRef\n7. Create approval-request Minion in minions-approvals\n8. Send notification to human via minions-openclaw\n   with draft body and approve/reject action\n\n## Skill: Send Approved Message\n1. On approval-request status changing to \"approved\":\n2. Load message-draft Minion\n3. Navigate to platform via browser tool\n4. Send message and record platform confirmation\n5. Create message Minion with status \"sent\"\n6. Update message-draft status to \"sent\"\n7. Update thread.lastMessageAt\n\n## Skill: Manage Follow-up Plans\n1. On \"application-submitted\" event: create follow-up-plan\n   with steps:\n   - Step 1: follow-up after 5 days if no reply\n   - Step 2: final follow-up after 10 days if still no reply\n   - Step 3: close thread after 15 days\n2. On each scheduler tick: check all pending follow-up Minions\n   where dueAt <= now and status == \"pending\"\n3. For each due follow-up: emit \"draft-reply\" with\n   intent \"follow-up\" to self\n4. If follow-up-plan reaches final step with no reply:\n   update thread.status to \"archived\"\n   emit \"opportunity-closed\" to PipelineAgent\n\n## Skill: Prepare Call Brief\n1. On receiving \"prepare-call-brief\" with threadId and scheduledAt:\n2. Load thread + all messages + contextRef Minion\n3. Load client-profile from minions-clients\n4. Generate call-brief Minion:\n   - agenda: summarize open questions and context\n   - keyQuestions: 3-5 specific things to clarify with client\n5. Send notification to human with call-brief content\n\n## Skill: Process Call Notes\n1. On receiving raw call notes from human:\n2. Create call-note Minion linked to call-brief\n3. Extract action items from notes\n4. For each action item: create task Minion in minions-tasks\n   with contextRef pointing to the call-brief\n5. Update client-profile notes in minions-clients\n6. Emit \"call-complete\" to OrchestratorAgent\n\n## Skill: Compute Comms Metrics\n1. On daily schedule trigger from minions-scheduler:\n2. Aggregate all message Minions from last 24 hours\n3. Calculate averageResponseTimeHours from inbound â†’ outbound pairs\n4. Count threads by status and sentiment\n5. Create comms-metric Minion for the period\n6. Include in OrchestratorAgent daily briefing\n\n## Hard Rules\n- Never send a message without an approval-request with\n  status \"approved\" â€” no exceptions\n- Never fabricate client statements â€” only use actual\n  message body content when summarizing\n- Never close a thread without notifying the OrchestratorAgent\n- Max 3 follow-up attempts per thread before escalating to human\n- Always update thread.sentiment after every inbound message\n```\n\n---\n\nThe `follow-up-plan` is worth highlighting as the most operationally valuable type here â€” it encodes the entire post-application communication strategy as a structured Minion rather than hardcoded agent logic, which means you can edit the plan (change timing, add steps, adjust tone intent) purely as data without touching any agent code.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-comms/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\ncomms types list\n\n# Show detailed schema for a specific type\ncomms types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\ncomms create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\ncomms create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\ncomms list <type>\n\n# Show a specific Minion\ncomms show <id>\n\n# Search by text\ncomms search \"query\"\n\n# Output as JSON (for piping)\ncomms list --json\ncomms show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\ncomms update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\ncomms delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\ncomms stats\n\n# Validate a Minion JSON file against its schema\ncomms validate ./my-minion.json\n```"
            }
          ]
        },
        {
          "slug": "crm",
          "name": "Crm",
          "skills": [
            {
              "slug": "minions-stakeholders",
              "name": "minions-stakeholders",
              "id": "OC-0162",
              "version": "1.0.0",
              "description": "Stakeholder registry, roles, and communication preferences",
              "commands": [],
              "env": [],
              "path": "minions-skills/productivity/crm",
              "markdownBody": "# minions-stakeholders â€” Agent Skills\n\n## What is a Stakeholder in the Minions Context?\n\n```\na project stakeholder                     â†’ Stakeholder\na communication sent to a stakeholder     â†’ StakeholderUpdate\n```\n\n## MinionTypes\n```ts\n// stakeholder â€” name, role, influence, interest, communication pref\n// stakeholder-update â€” type (status, milestone, risk), summary, channel\n```\n\n## Relations\n```\nstakeholder       --belongs_to-->        project (minions-projects)\nstakeholder       --receives-->          stakeholder-update\nstakeholder       --linked_to-->         contact (minions-contacts)\n```\n\n## Agent SKILLS\n```markdown\n# StakeholderAgent Skills\n## Skill: Map Stakeholders â€” identify, classify by influence/interest\n## Skill: Send Updates â€” periodic stakeholder-update via preferred channel\n## Hard Rules â€” high-influence stakeholders get updates on every milestone\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-stakeholders/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nstakeholders types list\nstakeholders types show <type-slug>\n```\n\n### CRUD\n\n```bash\nstakeholders create <type> -t \"Title\" -s \"status\"\nstakeholders list <type>\nstakeholders show <id>\nstakeholders update <id> --data '{ \"status\": \"active\" }'\nstakeholders delete <id>\nstakeholders search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nstakeholders stats\nstakeholders validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-leads",
              "name": "minions-leads",
              "id": "OC-0128",
              "version": "1.0.0",
              "description": "Lead records, company profiles, contact details, and qualification status",
              "commands": [],
              "env": [],
              "path": "minions-skills/productivity/crm",
              "markdownBody": "# minions-leads â€” Agent Skills\n\n## What is a Lead in the Minions Context?\n\n```\na discovered potential client             â†’ Lead\nadditional enrichment data                â†’ LeadEnrichment\n```\n\n## MinionTypes\n```ts\n// lead â€” company, website, industry, territory, contact info, lead score, status\n// lead-enrichment â€” company size, revenue, tech stack, social profiles\n```\n\n## Agent SKILLS\n```markdown\n# LeadAgent Skills\n## Skill: Qualify Leads â€” score, deduplicate, enrich\n## Skill: Enrich Lead â€” research company details, tech stack, socials\n## Hard Rules â€” leads must be deduplicated before entering pipeline\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-leads/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nleads types list\nleads types show <type-slug>\n```\n\n### CRUD\n\n```bash\nleads create <type> -t \"Title\" -s \"status\"\nleads list <type>\nleads show <id>\nleads update <id> --data '{ \"status\": \"active\" }'\nleads delete <id>\nleads search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nleads stats\nleads validate ./my-minion.json\n```"
            }
          ]
        },
        {
          "slug": "events",
          "name": "Events",
          "skills": [
            {
              "slug": "minions-venues",
              "name": "minions-venues",
              "id": "OC-0171",
              "version": "1.0.0",
              "description": "Tent definitions, capacities, reservation rules, and opening schedules for Oktoberfest",
              "commands": [],
              "env": [],
              "path": "minions-skills/productivity/events",
              "markdownBody": "# minions-venues â€” Agent Skills\n\n## What is a Venue in the Minions Context?\n\nBefore defining types, it's worth being precise. A \"venue\" in WiesnTracker means:\n\n```\nan Oktoberfest beer tent                 â†’ Tent\na reservable section within a tent       â†’ TentArea\nthe rules for booking that section       â†’ ReservationRule\nthe daily schedule of opening hours      â†’ OpeningSchedule\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// tent\n{\n  type: \"tent\",\n  fields: {\n    name: string,               // \"HofbrÃ¤u-Festzelt\"\n    shortName: string,          // \"HofbrÃ¤u\"\n    brewer: string,             // \"HofbrÃ¤u MÃ¼nchen\"\n    totalSeats: number,\n    standingCapacity: number,\n    website: string,\n    reservationUrl: string,\n    category: \"large\" | \"small\" | \"tradition\",\n    isLargeTent: boolean,\n    status: \"active\" | \"closed\" | \"archived\"\n  }\n}\n\n// tent-area\n{\n  type: \"tent-area\",\n  fields: {\n    tentId: string,\n    name: string,               // \"Galerie links\", \"Boxen Erdgeschoss\"\n    areaType: \"box\" | \"gallery\" | \"terrace\" | \"biergarten\" | \"standing\",\n    seats: number,\n    isIndoor: boolean,\n    isEvening: boolean,         // true = only available for evening sessions\n    minimumSpend: number,\n    currency: string,\n    notes: string\n  }\n}\n\n// reservation-rule\n{\n  type: \"reservation-rule\",\n  fields: {\n    tentId: string,\n    tentAreaId: string,\n    minGroupSize: number,\n    maxGroupSize: number,\n    reservationOpenDate: datetime,\n    reservationCloseDate: datetime,\n    mustOrderFood: boolean,\n    depositRequired: boolean,\n    depositAmount: number,\n    notes: string\n  }\n}\n\n// opening-schedule\n{\n  type: \"opening-schedule\",\n  fields: {\n    tentId: string,\n    date: datetime,             // specific Wiesn day\n    openTime: string,           // \"10:00\"\n    closeTime: string,          // \"23:30\"\n    sessionType: \"morning\" | \"afternoon\" | \"evening\" | \"full-day\",\n    isSpecialEvent: boolean,\n    eventName: string           // \"Anstich\", \"Italian Weekend\", etc.\n  }\n}\n```\n\n---\n\n## Relations\n\n```\ntent              --has_area-->          tent-area\ntent              --has_rule-->          reservation-rule\ntent              --has_schedule-->      opening-schedule\ntent-area         --governed_by-->       reservation-rule\ntent              --scanned_by-->        scan-config (minions-availability)\ntent-area         --tracked_in-->        slot-state (minions-availability)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-availability   â†’ ScannerAgent reads tent + tent-area definitions to know what to scan\nminions-alerts         â†’ alert-rules reference tentId + tentAreaId + sessionType\nminions-scheduler      â†’ scan schedules are triggered by minions-scheduler\nminions-tasks          â†’ manual research tasks (e.g. \"verify reservation URL for Augustiner\")\nminions-taxonomy       â†’ tent categories and area types could be managed as taxonomy entries\n```\n\nThe `tent-area` granularity is critical â€” availability is tracked per area, not per tent. A tent can have slots fully booked in the Biergarten but still have gallery boxes available.\n\n---\n\n## Agent SKILLS for `minions-venues`\n\n```markdown\n# VenueAgent Skills\n\n## Context\nYou manage all venue data for WiesnTracker. You maintain the tent registry,\ntheir areas, reservation rules, and daily schedules. You are the source of\ntruth for what exists at Oktoberfest. You never fabricate data â€” everything\ntraces to the tent's official website.\n\n## Skill: Register Tent\n1. Create a `tent` Minion with all static metadata\n2. For each reservable section, create a `tent-area` Minion\n3. Create `reservation-rule` Minions for each area's booking constraints\n4. Populate `opening-schedule` from the tent's published schedule\n5. Emit \"tent-registered\" to Orchestrator\n\n## Skill: Update Schedule\n1. Annually before Wiesn: refresh all tent schedules from official sources\n2. Create/update `opening-schedule` Minions for each tent Ã— day\n3. Flag any special events (Anstich, themed days)\n\n## Skill: Track Rule Changes\n1. Periodically check reservation URLs for updated rules\n2. If rules change: update `reservation-rule` Minion, log the change\n3. Notify AlertAgent if reservation windows open earlier than expected\n\n## Hard Rules\n- Never delete a tent â€” set status to \"archived\"\n- Every tent-area must have at least one reservation-rule\n- All data must trace to a verifiable source URL\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-venues/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nvenues types list\nvenues types show <type-slug>\n```\n\n### CRUD\n\n```bash\nvenues create <type> -t \"Title\" -s \"status\"\nvenues list <type>\nvenues show <id>\nvenues update <id> --data '{ \"status\": \"active\" }'\nvenues delete <id>\nvenues search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nvenues stats\nvenues validate ./my-minion.json\n```"
            }
          ]
        },
        {
          "slug": "notes",
          "name": "Notes",
          "skills": [
            {
              "slug": "minions-notes",
              "name": "minions-notes",
              "id": "OC-0132",
              "version": "1.0.0",
              "description": "Freeform annotations and observations attachable to any Minion",
              "commands": [],
              "env": [],
              "path": "minions-skills/productivity/notes",
              "markdownBody": "# minions-notes â€” Agent Skills\n\n## What is a Note in the Minions Context?\n\nA \"note\" sounds simple but covers several distinct things:\n\n```\na freeform observation attached to something else    â†’ Note\na previous saved version of that note               â†’ NoteRevision\na connection between two notes                      â†’ NoteLink\na structured extract pulled from a note             â†’ NoteInsight\na collection of notes around a theme                â†’ NoteCollection\n```\n\nThe key characteristic of a note versus a document is **intent**. A document is a deliberate, versioned artifact meant to be shared or submitted. A note is a lightweight, informal, often agent-generated observation attached to something else â€” a job posting, a client, a proposal, a run. Notes are the system's scratchpad.\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// note\n{\n  type: \"note\",\n  fields: {\n    title: string,\n    body: string,\n    authorId: string,\n    authorType: \"human\" | \"agent\",\n    createdAt: datetime,\n    updatedAt: datetime,\n    contextRefType: string,     // what this note is about\n    contextRefId: string,       // \"job-posting\", \"client-profile\", \"agent-run\", etc.\n    tags: string[],\n    pinned: boolean,\n    visibility: \"private\" | \"team\" | \"public\"\n  }\n}\n\n// note-revision\n{\n  type: \"note-revision\",\n  fields: {\n    noteId: string,\n    version: number,\n    body: string,\n    savedAt: datetime,\n    savedBy: string,            // person or agent id\n    changeReason: string\n  }\n}\n\n// note-link\n{\n  type: \"note-link\",\n  fields: {\n    fromNoteId: string,\n    toNoteId: string,\n    relation: string,           // \"supports\", \"contradicts\", \"expands-on\", \"related-to\"\n    createdAt: datetime,\n    createdBy: string\n  }\n}\n```\n\n**Structure & Organization**\n```ts\n// note-collection\n{\n  type: \"note-collection\",\n  fields: {\n    name: string,\n    description: string,\n    noteIds: string[],\n    ownerId: string,\n    contextRefType: string,     // optionally scoped to a domain\n    contextRefId: string,\n    tags: string[],\n    createdAt: datetime\n  }\n}\n```\n\n**Intelligence Layer**\n```ts\n// note-insight\n{\n  type: \"note-insight\",\n  fields: {\n    noteId: string,\n    insightType: \"red-flag\" | \"opportunity\" | \"preference\" | \"fact\" | \"question\",\n    body: string,\n    confidence: number,         // 0-1\n    extractedAt: datetime,\n    extractedBy: string,        // agent id\n    promotedToMemory: boolean,  // true if pushed to minions-memory\n    promotedAt: datetime\n  }\n}\n\n// note-thread\n{\n  type: \"note-thread\",\n  fields: {\n    rootNoteId: string,\n    replyNoteIds: string[],     // ordered replies\n    topic: string,\n    status: \"open\" | \"resolved\",\n    resolvedAt: datetime,\n    resolvedBy: string\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nnote              --attached_to-->      any Minion (via contextRef)\nnote              --has_revision-->     note-revision\nnote              --linked_to-->        note-link --> note\nnote              --belongs_to-->       note-collection\nnote              --yielded-->          note-insight\nnote-insight      --promoted_to-->      memory-item (minions-memory)\nnote              --thread_root_of-->   note-thread\nnote-thread       --has_reply-->        note\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\nNotes are intentionally the most connected MinionType in the ecosystem because they attach to everything via `contextRefType` and `contextRefId`:\n\n```\nminions-jobs        â†’ JobScoutAgent leaves notes on job-postings:\n                      \"Client has 3 previous hires, all 5-star rated\"\n\nminions-clients     â†’ ClientAgent builds up notes on client-profiles:\n                      \"Prefers bullet-point proposals, mentioned tight deadline\"\n\nminions-proposals   â†’ ProposalAgent notes revision reasoning:\n                      \"Removed technical jargon after compliance flag\"\n\nminions-agents      â†’ Any agent can note observations on its own runs:\n                      \"Match score was borderline, proceeded due to budget fit\"\n\nminions-memory      â†’ NoteInsights with promotedToMemory: true become\n                      persistent memory-items for future sessions\n\nminions-pipeline    â†’ PipelineAgent attaches notes to pipeline-entries:\n                      \"Client went quiet after first message, low priority\"\n\nminions-approvals   â†’ Approval decisions can carry a note as context\n                      for the audit log\n```\n\n---\n\n## Agent SKILLS for `minions-notes`\n\n```markdown\n# NotesAgent Skills\n\n## Context\nYou manage all notes across the Minions ecosystem. Notes are lightweight\nobservations attached to other Minions via contextRefType + contextRefId.\nYou create, retrieve, revise, link, and extract insights from notes.\nYou never fabricate â€” notes record what was actually observed or said.\n\n## Skill: Create Note\n1. When any agent or human produces an observation worth preserving,\n   create a `note` Minion with the correct contextRefType and contextRefId\n2. Set authorType: \"agent\" if created programmatically\n3. Tag appropriately so notes are filterable by topic\n4. If the note is critical context for future sessions, set pinned: true\n\n## Skill: Revise Note\n1. Before overwriting a note body, create a `note-revision` Minion\n   capturing the previous version, version number, and change reason\n2. Update the note's updatedAt timestamp\n3. Never delete revision history\n\n## Skill: Link Notes\n1. When two notes are related, create a `note-link` Minion\n2. Choose relation carefully:\n   - \"supports\" â†’ note B backs up the claim in note A\n   - \"contradicts\" â†’ note B challenges note A\n   - \"expands-on\" â†’ note B adds detail to note A\n   - \"related-to\" â†’ loose association, no directional meaning\n\n## Skill: Extract Insights\n1. Periodically scan notes attached to active job-postings,\n   client-profiles, and pipeline-entries\n2. For each note, identify if it contains:\n   - A red flag â†’ insightType: \"red-flag\"\n   - A client preference â†’ insightType: \"preference\"\n   - A verifiable fact â†’ insightType: \"fact\"\n   - An unanswered question â†’ insightType: \"question\"\n   - A potential opportunity â†’ insightType: \"opportunity\"\n3. Create a `note-insight` Minion for each finding\n4. If confidence > 0.8 and insightType is \"fact\" or \"preference\",\n   set promotedToMemory: true and push to minions-memory as a memory-item\n\n## Skill: Organize Collections\n1. When a set of notes shares a theme or context, create a `note-collection`\n2. Scope collections to a contextRef where relevant\n   (e.g. all notes about a specific client)\n3. Collections are navigational â€” they do not duplicate note content\n\n## Skill: Manage Threads\n1. When a note generates a discussion or follow-up observations,\n   create a `note-thread` with the original note as rootNoteId\n2. Append reply notes to replyNoteIds in order\n3. When the thread topic is resolved, set status: \"resolved\"\n\n## Hard Rules\n- Never create a note without a contextRefType and contextRefId\n  unless it is a standalone scratchpad note with explicit scope: \"private\"\n- Never overwrite a note body without saving a note-revision first\n- Insight confidence must be honestly scored â€” do not inflate\n- Only promote to memory-item if confidence > 0.8\n```\n\n---\n\nThe `note-insight` â†’ `memory-item` promotion path is the most important design detail here. It means the NotesAgent acts as a **filter and distillation layer** â€” raw observations accumulate as notes, the agent extracts structured insights from them, and only the highest-confidence insights graduate into persistent memory that other agents can rely on across sessions.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-notes/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\nnotes types list\n\n# Show detailed schema for a specific type\nnotes types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\nnotes create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\nnotes create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\nnotes list <type>\n\n# Show a specific Minion\nnotes show <id>\n\n# Search by text\nnotes search \"query\"\n\n# Output as JSON (for piping)\nnotes list --json\nnotes show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\nnotes update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\nnotes delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\nnotes stats\n\n# Validate a Minion JSON file against its schema\nnotes validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-documents",
              "name": "minions-documents",
              "id": "OC-0125",
              "version": "1.0.0",
              "description": "Versioned text documents, templates, and file attachments",
              "commands": [],
              "env": [],
              "path": "minions-skills/productivity/notes",
              "markdownBody": "# minions-documents â€” Agent Skills\n\n## What is a Document in the Minions Context?\n\nA \"document\" is overloaded â€” it can mean many things depending on context:\n\n```\na piece of writing with a title and body     â†’ Document\na previous saved state of that writing       â†’ DocumentVersion\na reusable scaffold with placeholders        â†’ DocumentTemplate\na file or binary asset linked to anything    â†’ Attachment\na generated export of a Minion as a doc      â†’ DocumentExport\na structured form with defined fields        â†’ Form\na filled-in instance of a form              â†’ FormSubmission\n```\n\nThe key distinction from `minions-notes` is intent: notes are freeform, informal, and observational. Documents are structured, versioned, and often the final output â€” a resume, a case study, a contract draft, a cover letter template.\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// document\n{\n  type: \"document\",\n  fields: {\n    title: string,\n    body: string,\n    format: \"markdown\" | \"plaintext\" | \"html\" | \"pdf\",\n    ownerId: string,\n    status: \"draft\" | \"review\" | \"approved\" | \"archived\",\n    version: number,\n    tags: string[],\n    contextRefType: string,     // what this document belongs to\n    contextRefId: string,       // e.g. a proposal, a contract, a job\n    createdAt: datetime,\n    updatedAt: datetime\n  }\n}\n\n// document-version\n{\n  type: \"document-version\",\n  fields: {\n    documentId: string,\n    version: number,            // immutable snapshot at this version number\n    body: string,\n    savedAt: datetime,\n    savedBy: string,            // person or agent id\n    changelog: string           // what changed in this version\n  }\n}\n```\n\n**Templates**\n```ts\n// document-template\n{\n  type: \"document-template\",\n  fields: {\n    name: string,\n    description: string,\n    body: string,               // body with {{placeholder}} syntax\n    placeholders: string[],     // list of expected placeholder keys\n    category: string,           // \"resume\", \"proposal\", \"cover-letter\", \"sow\"\n    tags: string[],\n    isActive: boolean\n  }\n}\n\n// document-placeholder\n{\n  type: \"document-placeholder\",\n  fields: {\n    templateId: string,\n    key: string,                // e.g. \"{{client_name}}\", \"{{project_outcome}}\"\n    description: string,        // what should go here\n    sourceRefType: string,      // where to pull this value from\n    sourceRefField: string,     // e.g. \"portfolio-item.outcomes\"\n    required: boolean,\n    fallback: string            // default value if source is empty\n  }\n}\n```\n\n**Files & Attachments**\n```ts\n// attachment\n{\n  type: \"attachment\",\n  fields: {\n    filename: string,\n    mimeType: string,\n    sizeBytes: number,\n    url: string,\n    contextRefType: string,\n    contextRefId: string,\n    uploadedAt: datetime,\n    uploadedBy: string\n  }\n}\n```\n\n**Exports**\n```ts\n// document-export\n{\n  type: \"document-export\",\n  fields: {\n    documentId: string,\n    format: \"pdf\" | \"docx\" | \"md\" | \"html\",\n    exportedAt: datetime,\n    exportedBy: string,         // person or agent id\n    url: string,                // download link\n    expiresAt: datetime         // if link is temporary\n  }\n}\n```\n\n**Forms**\n```ts\n// form\n{\n  type: \"form\",\n  fields: {\n    name: string,\n    description: string,\n    fields: FormField[],        // ordered list of field definitions\n    contextRefType: string,\n    isActive: boolean,\n    createdAt: datetime\n  }\n}\n\n// form-submission\n{\n  type: \"form-submission\",\n  fields: {\n    formId: string,\n    submittedBy: string,\n    submittedAt: datetime,\n    values: Record<string, any>, // key-value pairs matching form fields\n    status: \"submitted\" | \"reviewed\" | \"accepted\" | \"rejected\"\n  }\n}\n```\n\n---\n\n## Relations\n\n```\ndocument         --has_version-->        document-version\ndocument         --generated_from-->     document-template\ndocument         --has_attachment-->     attachment\ndocument         --has_export-->         document-export\ndocument-template --has_placeholder-->  document-placeholder\nform             --has_submission-->     form-submission\ndocument         --belongs_to-->         contextRef (any Minion)\nattachment       --belongs_to-->         contextRef (any Minion)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`minions-documents` is one of the most cross-cutting toolboxes in the ecosystem. Almost every other toolbox produces or consumes documents:\n\n```\nminions-profile      â†’ resume, case study, bio document\nminions-proposals    â†’ proposal-draft body lives in a document\nminions-contracts    â†’ contract terms stored as a document\nminions-jobs         â†’ job description archived as a document\nminions-approvals    â†’ approval payload can reference a document\nminions-applications â†’ submission bundle assembles documents + attachments\nminions-evaluations  â†’ test case rubric is a document\n```\n\nThe `contextRefType` + `contextRefId` pattern is what makes this work â€” a `document` always knows what it belongs to, so querying \"all documents related to this job application\" is a single lookup rather than custom joins per toolbox.\n\nThe `document-placeholder` type connecting to `sourceRefType` + `sourceRefField` is particularly powerful for the jobseeker use case: a resume template can declare that `{{project_outcome}}` should be pulled from `portfolio-item.outcomes`, and the DocumentAgent can auto-fill it from your live profile data every time it generates a new resume variant.\n\n---\n\n## Agent SKILLS for `minions-documents`\n\n```markdown\n# DocumentAgent Skills\n\n## Context\nYou manage all structured documents in the Minions ecosystem.\nYou read from minions-profile, minions-proposals, minions-jobs,\nand minions-contracts to populate document content.\nYou write only to minions-documents.\nYou never fabricate content â€” every placeholder you fill must\ntrace to a real field in a real Minion.\n\n## Skill: Create Document\n1. Determine if a template exists for this document type\n2. If yes: load the `document-template` and its `document-placeholder` Minions\n3. For each placeholder: resolve the value from its sourceRefType + sourceRefField\n4. If a required placeholder has no source value: flag it, do not silently skip\n5. Render the final body and create a `document` Minion with status \"draft\"\n6. Set version to 1 and record createdAt\n\n## Skill: Version Document\n1. Before any edit to an existing document:\n   - Save current body as a `document-version` Minion with current version number\n   - Increment document version\n   - Record changelog describing what changed and why\n2. Never overwrite version history\n\n## Skill: Generate from Template\n1. Load `document-template` by category (e.g. \"resume\", \"cover-letter\")\n2. Identify all `document-placeholder` Minions for this template\n3. For each placeholder, query the correct toolbox and field:\n   - \"portfolio-item.outcomes\" â†’ query minions-profile for portfolio items\n   - \"job-posting.title\" â†’ query minions-jobs for the specific posting\n4. Fill placeholders with resolved values\n5. Flag any unfilled required placeholders before proceeding\n6. Create the `document` Minion and notify the requesting agent\n\n## Skill: Export Document\n1. On export request: render document body in the requested format\n2. Create a `document-export` Minion with url and expiresAt\n3. Notify the requester with the export link\n4. For PDF exports: log attachment as an `attachment` Minion\n   linked to the same contextRef as the source document\n\n## Skill: Manage Attachments\n1. On any file upload: create an `attachment` Minion with\n   filename, mimeType, sizeBytes, url, and contextRef\n2. Never store raw binary â€” only the url reference\n3. When assembling a submission bundle (from minions-applications):\n   retrieve all attachments where contextRefId matches the applicationId\n\n## Skill: Archive Stale Documents\n1. On request or schedule: find documents with status \"draft\"\n   older than 30 days with no edits\n2. Update status to \"archived\"\n3. Log the change as a document-version entry with\n   changelog: \"auto-archived due to inactivity\"\n\n## Hard Rules\n- Never fill a placeholder with invented content\n- Always version before editing â€” no silent overwrites\n- A document with unfilled required placeholders stays in \"draft\"\n  and must not be exported or submitted\n- Every document must have a contextRef â€” orphaned documents\n  are a data quality failure\n```\n\n---\n\nThe `document-placeholder` â†’ `sourceRefType` + `sourceRefField` chain is the detail that elevates this from a simple text store into a live document generation system. Your DocumentAgent can regenerate a tailored resume for any job posting at any time by resolving placeholders against your current profile data, with full version history of every variant it produces.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-documents/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\ndocuments types list\n\n# Show detailed schema for a specific type\ndocuments types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\ndocuments create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\ndocuments create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\ndocuments list <type>\n\n# Show a specific Minion\ndocuments show <id>\n\n# Search by text\ndocuments search \"query\"\n\n# Output as JSON (for piping)\ndocuments list --json\ndocuments show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\ndocuments update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\ndocuments delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\ndocuments stats\n\n# Validate a Minion JSON file against its schema\ndocuments validate ./my-minion.json\n```"
            }
          ]
        },
        {
          "slug": "publishing",
          "name": "Publishing",
          "skills": [
            {
              "slug": "minions-articles",
              "name": "minions-articles",
              "id": "OC-0106",
              "version": "1.0.0",
              "description": "Article drafts, revisions, SEO metadata, and publish status",
              "commands": [],
              "env": [],
              "path": "minions-skills/productivity/publishing",
              "markdownBody": "# minions-articles â€” Agent Skills\n\n## What is an Article in the Minions Context?\n\nBefore defining types, it's worth being precise:\n\n```\na blog post with its content and metadata   â†’ Article\na versioned snapshot of an article          â†’ ArticleRevision\nSEO optimization data                       â†’ SeoMetadata\nquality and SEO scoring                     â†’ ArticleScore\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// article\n{\n  type: \"article\",\n  fields: {\n    blogId: string,\n    briefId: string,\n    title: string,\n    slug: string,\n    body: string,                    // markdown content\n    excerpt: string,\n    wordCount: number,\n    readingTimeMinutes: number,\n    status: \"draft\" | \"review\" | \"approved\" | \"published\" | \"archived\",\n    authorId: string,\n    createdAt: datetime,\n    publishedAt: datetime\n  }\n}\n\n// article-revision\n{\n  type: \"article-revision\",\n  fields: {\n    articleId: string,\n    version: number,\n    body: string,\n    changedBy: string,\n    changeNotes: string,\n    createdAt: datetime\n  }\n}\n\n// seo-metadata\n{\n  type: \"seo-metadata\",\n  fields: {\n    articleId: string,\n    metaTitle: string,\n    metaDescription: string,\n    canonicalUrl: string,\n    ogImage: string,\n    schemaMarkup: string,\n    internalLinks: string[],\n    externalLinks: string[]\n  }\n}\n\n// article-score\n{\n  type: \"article-score\",\n  fields: {\n    articleId: string,\n    readabilityScore: number,\n    seoScore: number,\n    originalityScore: number,\n    overallScore: number,\n    suggestions: string[],\n    scoredAt: datetime,\n    scoredBy: string\n  }\n}\n```\n\n---\n\n## Relations\n\n```\narticle            --created_from-->     content-brief (minions-content-research)\narticle            --has_revision-->     article-revision\narticle            --has_seo-->         seo-metadata\narticle            --scored_by-->       article-score\narticle            --published_via-->   publish-receipt (minions-publishing)\narticle            --belongs_to-->      blog (minions-blogs)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-content-research  â†’ articles are created from content-briefs\nminions-blogs             â†’ articles belong to a blog and follow its guidelines\nminions-publishing        â†’ approved articles enter the publish queue\nminions-approvals         â†’ articles in \"review\" status create approval requests\nminions-documents         â†’ article revisions provide full version history\n```\n\n---\n\n## Agent SKILLS for `minions-articles`\n\n```markdown\n# WriterAgent Skills\n\n## Context\nYou write, revise, and optimize articles. You take content briefs\nand produce publication-ready articles that match the blog's brand\nguidelines and target the specified keywords.\n\n## Skill: Write Article\n1. Load content-brief and blog brand-guidelines\n2. Write article body following the brief outline\n3. Create article-revision (version 1)\n4. Generate seo-metadata (metaTitle, metaDescription, etc.)\n5. Run article-score evaluation\n6. Set status to \"review\"\n\n## Skill: Revise Article\n1. On feedback: create new article-revision with incremented version\n2. Re-run article-score\n3. If score improves, update main article body\n\n## Skill: Optimize SEO\n1. Analyze keyword placement, heading structure, link density\n2. Update seo-metadata\n3. Suggest internal linking opportunities\n\n## Hard Rules\n- Every article must trace to a content-brief\n- Every edit creates an article-revision â€” never overwrite without versioning\n- Articles must score above threshold before moving to \"approved\"\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-articles/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\narticles types list\narticles types show <type-slug>\n```\n\n### CRUD\n\n```bash\narticles create <type> -t \"Title\" -s \"status\"\narticles list <type>\narticles show <id>\narticles update <id> --data '{ \"status\": \"active\" }'\narticles delete <id>\narticles search \"query\"\n```\n\n### Stats & Validation\n\n```bash\narticles stats\narticles validate ./my-minion.json\n```"
            }
          ]
        },
        {
          "slug": "sales",
          "name": "Sales",
          "skills": [
            {
              "slug": "minions-territories",
              "name": "minions-territories",
              "id": "OC-0165",
              "version": "1.0.0",
              "description": "Country, state, region, city definitions, focus queue, and saturation tracking",
              "commands": [],
              "env": [],
              "path": "minions-skills/productivity/sales",
              "markdownBody": "# minions-territories â€” Agent Skills\n\n## What is a Territory in the Minions Context?\n\n```\na geographic area for prospecting         â†’ Territory\nsaturation metrics for a territory        â†’ TerritorySaturation\nthe ordered queue of territories          â†’ FocusQueue\n```\n\nGeo hierarchy: Country â†’ State â†’ Region â†’ City\n\n## MinionTypes\n```ts\n// territory â€” name, level, parent, country/state/region/city, estimated businesses\n// territory-saturation â€” total prospects, contacted, reply/conversion rates\n// focus-queue â€” ordered list of territory IDs with current index\n```\n\n## Agent SKILLS\n```markdown\n# TerritoryAgent Skills\n## Skill: Manage Focus Queue â€” rotate through territories by saturation\n## Skill: Track Saturation â€” update metrics after each outreach cycle\n## Hard Rules â€” move to next territory when saturation exceeds threshold\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-territories/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nterritories types list\nterritories types show <type-slug>\n```\n\n### CRUD\n\n```bash\nterritories create <type> -t \"Title\" -s \"status\"\nterritories list <type>\nterritories show <id>\nterritories update <id> --data '{ \"status\": \"active\" }'\nterritories delete <id>\nterritories search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nterritories stats\nterritories validate ./my-minion.json\n```"
            }
          ]
        },
        {
          "slug": "tasks",
          "name": "Tasks",
          "skills": [
            {
              "slug": "minions-tasks",
              "name": "minions-tasks",
              "id": "OC-0163",
              "version": "1.0.0",
              "description": "Agent skills for managing tasks via the `tasks` CLI. Covers creating, assigning, tracking, blocking, completing, and recurring task management.",
              "commands": [],
              "env": [],
              "path": "minions-skills/productivity/tasks",
              "markdownBody": "# minions-tasks â€” Agent Skills\n\n## What is a Task in the Minions Context?\n\nBefore defining types, it's worth being precise. A \"task\" can mean very different things:\n\n```\na unit of work to be done          â†’ Task\na collection of tasks              â†’ TaskList / Project\nsomething that repeats             â†’ RecurringTask\nsomething blocking something else  â†’ Dependency\na snapshot of progress             â†’ TaskStatus / Checkpoint\nwho is responsible                 â†’ Assignment\nwhat happened to it over time      â†’ TaskHistory\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// task\n{\n  type: \"task\",\n  fields: {\n    title: string,\n    description: string,\n    status: \"backlog\" | \"todo\" | \"in-progress\" | \"blocked\" | \"done\" | \"cancelled\",\n    priority: \"critical\" | \"high\" | \"medium\" | \"low\",\n    assigneeId: string,         // ref to a person or agent\n    createdBy: string,\n    createdAt: datetime,\n    dueAt: datetime,\n    completedAt: datetime,\n    tags: string[],\n    parentTaskId: string,       // for subtasks\n    contextRef: {               // what this task belongs to\n      type: string,             // \"job-posting\", \"proposal-draft\", etc.\n      id: string\n    }\n  }\n}\n\n// task-list\n{\n  type: \"task-list\",\n  fields: {\n    name: string,\n    description: string,\n    taskIds: string[],\n    ordered: boolean,           // true = sequence matters\n    ownerId: string,\n    groupId: string             // ref to minion-group\n  }\n}\n\n// task-dependency\n{\n  type: \"task-dependency\",\n  fields: {\n    taskId: string,\n    dependsOnTaskId: string,\n    type: \"blocks\" | \"required-by\" | \"related-to\"\n  }\n}\n```\n\n**Recurrence**\n```ts\n// recurring-task\n{\n  type: \"recurring-task\",\n  fields: {\n    templateTaskId: string,     // base task definition\n    schedule: string,           // cron expression\n    nextRunAt: datetime,\n    lastRunAt: datetime,\n    spawnedTaskIds: string[],   // all instances created from this\n    status: \"active\" | \"paused\"\n  }\n}\n```\n\n**Assignment & Responsibility**\n```ts\n// task-assignment\n{\n  type: \"task-assignment\",\n  fields: {\n    taskId: string,\n    assigneeId: string,\n    assigneeType: \"human\" | \"agent\",\n    assignedAt: datetime,\n    assignedBy: string,\n    role: \"owner\" | \"collaborator\" | \"reviewer\" | \"observer\"\n  }\n}\n```\n\n**Progress & History**\n```ts\n// task-checkpoint\n{\n  type: \"task-checkpoint\",\n  fields: {\n    taskId: string,\n    label: string,              // \"halfway done\", \"first draft complete\"\n    completedAt: datetime,\n    notes: string\n  }\n}\n\n// task-history-entry\n{\n  type: \"task-history-entry\",\n  fields: {\n    taskId: string,\n    changedAt: datetime,\n    changedBy: string,          // person or agent id\n    field: string,              // which field changed\n    from: any,\n    to: any\n  }\n}\n```\n\n**Feedback & Outcome**\n```ts\n// task-comment\n{\n  type: \"task-comment\",\n  fields: {\n    taskId: string,\n    authorId: string,\n    authorType: \"human\" | \"agent\",\n    body: string,\n    createdAt: datetime,\n    resolvedAt: datetime\n  }\n}\n\n// task-outcome\n{\n  type: \"task-outcome\",\n  fields: {\n    taskId: string,\n    result: \"success\" | \"partial\" | \"failed\",\n    summary: string,\n    artifactIds: string[],      // anything produced by completing this task\n    lessons: string             // for agent learning loop\n  }\n}\n```\n\n---\n\n## Relations\n\n```\ntask            --belongs_to-->     task-list\ntask            --subtask_of-->     task\ntask            --blocked_by-->     task-dependency\ntask            --assigned_to-->    task-assignment\ntask            --has_checkpoint--> task-checkpoint\ntask            --has_comment-->    task-comment\ntask            --produced-->       task-outcome\nrecurring-task  --spawned-->        task\ntask            --logged_in-->      task-history-entry\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\nThe `contextRef` field on `task` is the key bridge:\n\n```\nagent-run (minions-agents)         â†’ spawns tasks with contextRef: { type: \"agent-run\" }\njob-posting (minions-jobs)         â†’ has tasks like \"research this client\"\nproposal-draft (minions-proposals) â†’ has tasks like \"add portfolio item X\"\napproval-request (minions-approvals) â†’ is itself a task waiting for human action\nschedule (minions-scheduler)       â†’ recurring-task can reference a schedule as its engine\npipeline-entry (minions-pipeline)  â†’ stale entries generate tasks like \"follow up on application\"\neval-failure (minions-evaluations) â†’ failed benchmarks spawn investigation tasks\n```\n\nRather than every toolbox defining its own ad-hoc \"todo\" concept, they all point to `minions-tasks` for anything that represents work to be done.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-tasks/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all 9 MinionTypes with their fields\ntasks types list\n\n# Show detailed schema for a specific type\ntasks types show task\ntasks types show task-list\ntasks types show task-dependency\ntasks types show recurring-task\ntasks types show task-assignment\ntasks types show task-checkpoint\ntasks types show task-history-entry\ntasks types show task-comment\ntasks types show task-outcome\n```\n\n---\n\n## Skill: Create Task\n\nWhen a workflow produces a unit of work, create a task.\n\n```bash\n# Create with shortcut flags\ntasks create task -t \"Research client ACME\" -s \"todo\" -p \"high\"\n\n# Create with full field data\ntasks create task --data '{\n  \"title\": \"Draft proposal for job-123\",\n  \"status\": \"todo\",\n  \"priority\": \"high\",\n  \"assigneeType\": \"agent\",\n  \"contextRefType\": \"job-posting\",\n  \"contextRefId\": \"abc-123\",\n  \"createdBy\": \"proposal-agent\"\n}'\n\n# Create a subtask (link to parent)\ntasks create task --data '{\n  \"title\": \"Write introduction section\",\n  \"status\": \"todo\",\n  \"priority\": \"medium\",\n  \"parentTaskId\": \"<PARENT_TASK_ID>\",\n  \"contextRefType\": \"task\",\n  \"contextRefId\": \"<PARENT_TASK_ID>\"\n}'\n```\n\n**Rules:**\n- Always set `contextRefType` and `contextRefId` â€” no orphaned tasks\n- Set `assigneeType`: `\"agent\"` if automatable, `\"human\"` if needs judgment\n- Set `priority`: `\"critical\"` > `\"high\"` > `\"medium\"` > `\"low\"`\n\n---\n\n## Skill: Assign Task\n\n```bash\n# Assign to an agent (default)\ntasks assign <TASK_ID> proposal-agent\n\n# Assign to a human as reviewer\ntasks assign <TASK_ID> mehdi --type human --role reviewer\n\n# Roles: owner, collaborator, reviewer, observer\n```\n\n---\n\n## Skill: Manage Task List\n\nGroup related tasks into a list.\n\n```bash\n# Create an ordered task list (sequence matters)\ntasks create task-list --data '{\n  \"name\": \"Proposal workflow for job-123\",\n  \"taskIds\": \"<TASK_1>,<TASK_2>,<TASK_3>\",\n  \"ordered\": true,\n  \"ownerId\": \"proposal-agent\"\n}'\n\n# Create an unordered list (can parallelize)\ntasks create task-list --data '{\n  \"name\": \"Research tasks\",\n  \"taskIds\": \"<TASK_A>,<TASK_B>\",\n  \"ordered\": false\n}'\n```\n\n**Rules:**\n- If `ordered: true`: do not start task N+1 until task N is `\"done\"`\n- If `ordered: false`: parallelize across agents\n\n---\n\n## Skill: Track Progress\n\n```bash\n# Update status\ntasks update <TASK_ID> -s \"in-progress\"\n\n# Log a status change as history entry\ntasks create task-history-entry --data '{\n  \"taskId\": \"<TASK_ID>\",\n  \"changedAt\": \"2026-02-23T09:00:00Z\",\n  \"changedBy\": \"task-agent\",\n  \"field\": \"status\",\n  \"from\": \"todo\",\n  \"to\": \"in-progress\"\n}'\n\n# Create a checkpoint at a milestone\ntasks create task-checkpoint --data '{\n  \"taskId\": \"<TASK_ID>\",\n  \"label\": \"First draft complete\",\n  \"completedAt\": \"2026-02-23T10:00:00Z\",\n  \"notes\": \"All sections drafted, needs review\"\n}'\n\n# Add a comment\ntasks comment <TASK_ID> \"Waiting on client feedback before proceeding\"\n```\n\n**Rules:**\n- Every status change MUST produce a `task-history-entry`\n- Every meaningful milestone SHOULD produce a `task-checkpoint`\n\n---\n\n## Skill: Complete Task\n\n```bash\n# Mark done with outcome (creates task-outcome automatically)\ntasks complete <TASK_ID> --result success --summary \"Proposal submitted\" --lessons \"Client prefers bullet points\"\n\n# Mark with partial success\ntasks complete <TASK_ID> --result partial --summary \"3 of 5 items done\" --lessons \"Time estimate was too low\"\n\n# Mark as failed\ntasks complete <TASK_ID> --result failed --summary \"Client rejected scope\" --lessons \"Confirm budget before starting\"\n\n# Or just cancel via soft-delete\ntasks delete <TASK_ID>\n```\n\n**Rules:**\n- Every completed task MUST have a `task-outcome`\n- Always include `lessons` â€” feeds the agent learning loop\n- Never hard-delete â€” use `tasks delete` (soft) or set status to `\"cancelled\"`\n\n---\n\n## Skill: Handle Blocked Tasks\n\n```bash\n# Check all blocked tasks and their dependencies\ntasks blocked\n\n# Create a dependency (task-A is blocked by task-B)\ntasks create task-dependency --data '{\n  \"taskId\": \"<BLOCKED_TASK_ID>\",\n  \"dependsOnTaskId\": \"<BLOCKING_TASK_ID>\",\n  \"type\": \"blocks\"\n}'\n\n# Mark a task as blocked\ntasks update <TASK_ID> -s \"blocked\"\n\n# When blocking task is done, unblock the dependent\ntasks update <BLOCKED_TASK_ID> -s \"todo\"\n```\n\n**Dependency types:** `\"blocks\"`, `\"required-by\"`, `\"related-to\"`\n\n**Rules:**\n- When a task becomes `\"blocked\"`, check `task-dependency` records\n- Monitor blocking task â€” when it reaches `\"done\"`, advance blocked task to `\"todo\"`\n- Log the unblock as a `task-history-entry`\n\n---\n\n## Skill: Recurring Tasks\n\n```bash\n# Create a recurring task template\ntasks create recurring-task --data '{\n  \"templateTaskId\": \"<TEMPLATE_TASK_ID>\",\n  \"schedule\": \"0 9 * * 1\",\n  \"nextRunAt\": \"2026-02-24T09:00:00Z\",\n  \"lastRunAt\": \"\",\n  \"spawnedTaskIds\": \"\",\n  \"status\": \"active\"\n}'\n\n# Pause a recurring task\ntasks update <RECURRING_ID> -s \"paused\"\n\n# Resume\ntasks update <RECURRING_ID> -s \"active\"\n```\n\n**Rules:**\n- On each tick: check `nextRunAt`, spawn new task from template\n- Update `lastRunAt` and recompute `nextRunAt` from cron\n- Check `lastRunAt` before spawning to avoid duplicates\n\n---\n\n## Search and Browse\n\n```bash\n# Search by title/description\ntasks search \"proposal\"\n\n# Filter by status\ntasks list task --status todo\n\n# List all tasks\ntasks list task\n\n# List everything\ntasks list\n\n# Output as JSON (for piping)\ntasks list --json\ntasks show <ID> --json\n\n# Show stats\ntasks stats\n```\n\n---\n\n## Validate\n\n```bash\n# Validate a Minion JSON file against its schema\ntasks validate ./my-task.json\n```\n\n---\n\n## Hard Rules\n\n1. Every task MUST have `contextRefType` + `contextRefId` â€” no orphans\n2. Every completed task MUST have a `task-outcome`\n3. Never hard-delete â€” use soft-delete (`tasks delete <id>`)\n4. All status changes â†’ `task-history-entry`\n5. Recurring task spawning must be idempotent\n6. This agent only writes to `minions-tasks` â€” reads from others, never writes\n\n---\n\nThe `task-outcome` with a `lessons` field is worth highlighting â€” it gives every agent in your fleet a structured way to feed observations back into the system over time, which becomes the foundation of a learning loop across all your purpose bundles."
            },
            {
              "slug": "minions-sprints",
              "name": "minions-sprints",
              "id": "OC-0161",
              "version": "1.0.0",
              "description": "Sprint definitions, scope, and velocity tracking",
              "commands": [],
              "env": [],
              "path": "minions-skills/productivity/tasks",
              "markdownBody": "# minions-sprints â€” Agent Skills\n\n## What is a Sprint in the Minions Context?\n\n```\na time-boxed iteration                    â†’ Sprint\nlessons from a completed sprint           â†’ SprintRetrospective\n```\n\nOnly used by `it-project` variant in ProjectPilot.\n\n## MinionTypes\n```ts\n// sprint â€” number, dates, goal, planned/completed story points\n// sprint-retrospective â€” went well, needs improvement, action items\n```\n\n## Relations\n```\nsprint            --belongs_to-->        project (minions-projects, variant=it-project)\nsprint            --contains-->          task (minions-tasks)\nsprint            --reflected_in-->      sprint-retrospective\n```\n\n## Agent SKILLS\n```markdown\n# SprintAgent Skills\n## Skill: Plan Sprint â€” select tasks, set goal, estimate points\n## Skill: Close Sprint â€” calculate velocity, create retrospective\n## Hard Rules â€” sprints cannot overlap for the same project\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-sprints/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nsprints types list\nsprints types show <type-slug>\n```\n\n### CRUD\n\n```bash\nsprints create <type> -t \"Title\" -s \"status\"\nsprints list <type>\nsprints show <id>\nsprints update <id> --data '{ \"status\": \"active\" }'\nsprints delete <id>\nsprints search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nsprints stats\nsprints validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-projects",
              "name": "minions-projects",
              "id": "OC-0144",
              "version": "1.0.0",
              "description": "Project definitions, variants, goals, status, and ownership",
              "commands": [],
              "env": [],
              "path": "minions-skills/productivity/tasks",
              "markdownBody": "# minions-projects â€” Agent Skills\n\n## What is a Project in the Minions Context?\n\n```\na project with goals and a variant        â†’ Project\na periodic health summary                 â†’ ProjectSummary\n```\n\n**Variants:** `it-project`, `personal-project`, `creative-project`, `business-project` â€” each variant activates different shared toolboxes.\n\n## MinionTypes\n```ts\n// project â€” name, variant, goals, status, owner, dates\n// project-summary â€” periodic health + completion % + blockers\n```\nSee TOML for full fields.\n\n## Relations\n```\nproject           --has_milestone-->     milestone (minions-milestones)\nproject           --has_sprint-->        sprint (minions-sprints, it-project only)\nproject           --tracked_by-->        project-summary\nproject           --has_decision-->      decision (minions-decisions)\nproject           --has_risk-->          risk (minions-risks)\nproject           --has_stakeholder-->   stakeholder (minions-stakeholders)\n```\n\n## Agent SKILLS\n```markdown\n# ProjectAgent Skills\n## Skill: Create Project â€” define variant, goals, timeline, owner\n## Skill: Generate Summary â€” assess health, blockers, completion\n## Hard Rules â€” never delete projects, only archive\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-projects/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nprojects types list\nprojects types show <type-slug>\n```\n\n### CRUD\n\n```bash\nprojects create <type> -t \"Title\" -s \"status\"\nprojects list <type>\nprojects show <id>\nprojects update <id> --data '{ \"status\": \"active\" }'\nprojects delete <id>\nprojects search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nprojects stats\nprojects validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-milestones",
              "name": "minions-milestones",
              "id": "OC-0131",
              "version": "1.0.0",
              "description": "Milestone definitions, dependencies, and completion criteria",
              "commands": [],
              "env": [],
              "path": "minions-skills/productivity/tasks",
              "markdownBody": "# minions-milestones â€” Agent Skills\n\n## What is a Milestone in the Minions Context?\n\n```\na major project checkpoint                â†’ Milestone\na health check on progress                â†’ MilestoneCheck\n```\n\n## MinionTypes\n```ts\n// milestone â€” name, due date, completion criteria, dependencies\n// milestone-check â€” periodic on-track assessment with blockers\n```\n\n## Relations\n```\nmilestone         --belongs_to-->        project (minions-projects)\nmilestone         --depends_on-->        milestone\nmilestone         --checked_by-->        milestone-check\nmilestone         --has_tasks-->         task (minions-tasks)\n```\n\n## Agent SKILLS\n```markdown\n# MilestoneAgent Skills\n## Skill: Track Milestones â€” check progress, flag at-risk items\n## Skill: Create Health Checks â€” periodic milestone-check Minions\n## Hard Rules â€” milestones with dependencies can't complete before deps\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-milestones/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nmilestones types list\nmilestones types show <type-slug>\n```\n\n### CRUD\n\n```bash\nmilestones create <type> -t \"Title\" -s \"status\"\nmilestones list <type>\nmilestones show <id>\nmilestones update <id> --data '{ \"status\": \"active\" }'\nmilestones delete <id>\nmilestones search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nmilestones stats\nmilestones validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-approvals",
              "name": "minions-approvals",
              "id": "OC-0105",
              "version": "1.0.0",
              "description": "Approval requests, human decisions, and immutable audit logs",
              "commands": [],
              "env": [],
              "path": "minions-skills/productivity/tasks",
              "markdownBody": "# minions-approvals â€” Agent Skills\n\n## What is an Approval in the Minions Context?\n\nBefore defining types, it's worth being precise. \"Approval\" can mean several different things:\n\n```\nsomething waiting for a human decision    â†’ ApprovalRequest\nthe rule that triggered the requirement   â†’ ApprovalPolicy\nthe decision itself                       â†’ logged on ApprovalRequest\na record that it happened                 â†’ AuditLogEntry\nan escalation when no one responds        â†’ ApprovalEscalation\na delegated authority                     â†’ ApprovalDelegate\n```\n\nThe core principle of this toolbox: **nothing irreversible happens without a logged human decision**. Every approval request is immutable once decided, and every action taken on the back of an approval is traceable back to it.\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// approval-request\n{\n  type: \"approval-request\",\n  fields: {\n    title: string,\n    description: string,           // human-readable summary of what will happen\n    requestedBy: string,           // agent id or person id\n    requestedAt: datetime,\n    requiredBy: datetime,          // deadline for decision\n    contextRefType: string,        // \"proposal-draft\", \"agent-run\", \"application\", etc.\n    contextRefId: string,\n    payload: Record<string, any>,  // full data snapshot of what will be acted on\n    decision: \"pending\" | \"approved\" | \"rejected\" | \"expired\",\n    decidedBy: string,\n    decidedAt: datetime,\n    decisionNotes: string,\n    policyId: string               // which policy triggered this requirement\n  }\n}\n\n// approval-policy\n{\n  type: \"approval-policy\",\n  fields: {\n    name: string,\n    description: string,\n    actionType: string,            // \"submit-application\", \"send-message\", \"accept-contract\"\n    condition: string,             // e.g. \"budget > 5000 || platform == upwork\"\n    requiredApproverRole: string,  // \"owner\", \"reviewer\", \"any-human\"\n    timeoutHours: number,          // how long before it expires\n    onTimeout: \"expire\" | \"auto-approve\" | \"escalate\",\n    isActive: boolean\n  }\n}\n```\n\n**Audit**\n```ts\n// audit-log-entry\n{\n  type: \"audit-log-entry\",\n  fields: {\n    actorId: string,\n    actorType: \"human\" | \"agent\",\n    action: string,                // \"submitted-application\", \"approved-proposal\"\n    contextRefType: string,\n    contextRefId: string,\n    timestamp: datetime,\n    payload: Record<string, any>,  // snapshot of state at time of action\n    approvalRequestId: string,     // ref if action was approval-gated\n    ipAddress: string\n  }\n}\n```\n\n**Escalation & Delegation**\n```ts\n// approval-escalation\n{\n  type: \"approval-escalation\",\n  fields: {\n    approvalRequestId: string,\n    escalatedAt: datetime,\n    reason: string,                // \"no response within 4 hours\"\n    escalatedTo: string,\n    escalationChannel: string,     // \"telegram\", \"email\", \"whatsapp\"\n    resolved: boolean,\n    resolvedAt: datetime\n  }\n}\n\n// approval-delegate\n{\n  type: \"approval-delegate\",\n  fields: {\n    delegatorId: string,\n    delegateId: string,\n    actionTypes: string[],         // which action types they can approve\n    validFrom: datetime,\n    validUntil: datetime,\n    isActive: boolean,\n    reason: string                 // \"on holiday\", \"out of office\"\n  }\n}\n```\n\n**History**\n```ts\n// approval-history-entry\n{\n  type: \"approval-history-entry\",\n  fields: {\n    approvalRequestId: string,\n    changedAt: datetime,\n    changedBy: string,\n    field: string,\n    from: any,\n    to: any\n  }\n}\n```\n\n---\n\n## Relations\n\n```\napproval-request    --governed_by-->     approval-policy\napproval-request    --references-->      contextRef (any Minion)\napproval-request    --triggered-->       audit-log-entry\napproval-request    --escalated_via-->   approval-escalation\napproval-request    --decided_by-->      person (or agent)\napproval-delegate   --delegates_for-->   person\napproval-policy     --applies_to-->      action types across all minions\naudit-log-entry     --traces-->          approval-request\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`minions-approvals` is unique in that it is **written to by other toolboxes but owned by none of them**. Every domain toolbox that has an irreversible action routes through here:\n\n```\nminions-proposals    â†’ approval-request before proposal is submitted\nminions-applications â†’ approval-request before application bundle is sent\nminions-comms        â†’ approval-request before follow-up message is sent\nminions-contracts    â†’ approval-request before terms are accepted\nminions-agents       â†’ approval-request before any agent policy change\n```\n\nThe `contextRefType` + `contextRefId` pattern means the approval request always carries a pointer back to exactly what will be acted on, and the `payload` field snapshots the full state at request time â€” so even if the underlying Minion changes, the approval record is immutable.\n\nThe `audit-log-entry` is the write-once companion to every approval â€” it records not just the decision but every consequential action taken across the entire system, whether approval-gated or not.\n\n---\n\n## Agent SKILLS for `minions-approvals`\n\n```markdown\n# ApprovalAgent Skills\n\n## Context\nYou manage all approval flows in the Minions ecosystem. You are the\ngatekeeper between agent-generated actions and irreversible execution.\nYou never approve on behalf of the human â€” you surface, track, escalate,\nand record. The human always decides.\n\n## Skill: Evaluate Whether Approval Is Required\n1. When any agent proposes an action, check all active `approval-policy`\n   Minions where actionType matches\n2. Evaluate the condition expression against the action payload\n3. If any policy matches: create an `approval-request` Minion with status\n   \"pending\" and full payload snapshot\n4. If no policy matches: log directly to `audit-log-entry` and allow\n5. Never skip this check for actions tagged as irreversible\n\n## Skill: Notify for Pending Approvals\n1. On creation of any `approval-request` with status \"pending\":\n   - Send notification via minions-comms to the required approver\n   - Include: title, description, payload summary, requiredBy deadline\n   - Include direct approve/reject action links if platform supports it\n2. Record notification in audit-log-entry\n\n## Skill: Handle Decision\n1. On receiving approve or reject signal (from human via any channel):\n   - Update `approval-request` decision, decidedBy, decidedAt, decisionNotes\n   - Create `audit-log-entry` recording the decision\n   - Emit decision event to the requesting agent via minions-agents message bus\n2. If approved: requesting agent may proceed with execution\n3. If rejected: requesting agent archives the pending action, no execution\n\n## Skill: Handle Expiry\n1. On schedule: check all `approval-request` Minions with status \"pending\"\n   where requiredBy has passed\n2. Look up the governing `approval-policy` onTimeout rule:\n   - \"expire\": set decision to \"expired\", notify requester, block action\n   - \"auto-approve\": set decision to \"approved\", log with note \"auto-approved\n     on timeout\", emit approval to requesting agent\n   - \"escalate\": create `approval-escalation` Minion, notify escalation target\n     via a higher-priority channel, extend requiredBy\n\n## Skill: Manage Escalations\n1. On creation of `approval-escalation`:\n   - Notify escalation target via the specified escalationChannel\n   - Mark escalation as unresolved\n2. On decision after escalation:\n   - Mark `approval-escalation` resolved, resolvedAt = now\n   - Proceed with normal decision handling\n\n## Skill: Manage Delegates\n1. On receiving \"set delegate\" instruction:\n   - Create `approval-delegate` Minion with validFrom, validUntil, actionTypes\n   - Any approval requests of the specified actionTypes during that window\n     are routed to the delegate instead of the owner\n2. On expiry of delegate window:\n   - Set isActive to false\n   - Resume routing to owner\n\n## Skill: Audit Logging\n1. Every consequential system action â€” approved or not â€” gets an\n   `audit-log-entry` Minion created\n2. Fields always populated: actorId, actorType, action, contextRef,\n   timestamp, payload snapshot\n3. Audit log entries are never modified or deleted\n4. On request: produce a filtered audit trail by actorId, contextRef,\n   action type, or time range\n\n## Hard Rules\n- Never modify an audit-log-entry after creation\n- Never approve or reject on behalf of a human\n- Never allow an action tagged irreversible to proceed without a logged\n  approval-request with decision \"approved\"\n- Always snapshot the full payload at request time, not at decision time\n- If approval-policy evaluation fails or errors, default to requiring approval\n```\n\n---\n\nThe `payload` snapshot rule at the bottom is the most important detail operationally â€” it means your audit trail shows exactly what was approved, not what eventually got submitted after potential edits. That gap between request-time state and execution-time state is where trust breaks down in most automation systems.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-approvals/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\napprovals types list\n\n# Show detailed schema for a specific type\napprovals types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\napprovals create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\napprovals create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\napprovals list <type>\n\n# Show a specific Minion\napprovals show <id>\n\n# Search by text\napprovals search \"query\"\n\n# Output as JSON (for piping)\napprovals list --json\napprovals show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\napprovals update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\napprovals delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\napprovals stats\n\n# Validate a Minion JSON file against its schema\napprovals validate ./my-minion.json\n```"
            }
          ]
        }
      ],
      "skills": [],
      "skillCount": 13
    },
    {
      "slug": "dev-tools",
      "name": "Dev Tools",
      "icon": "ðŸ§ª",
      "subcategories": [
        {
          "slug": "monitoring",
          "name": "Monitoring",
          "skills": [
            {
              "slug": "minions-alerts",
              "name": "minions-alerts",
              "id": "OC-0103",
              "version": "1.0.0",
              "description": "Alert rules, delivery preferences, and alert history for availability changes",
              "commands": [],
              "env": [],
              "path": "minions-skills/dev-tools/monitoring",
              "markdownBody": "# minions-alerts â€” Agent Skills\n\n## What is an Alert in the Minions Context?\n\nBefore defining types, it's worth being precise. \"Alert\" in WiesnTracker means:\n\n```\na rule defining what triggers a notification     â†’ AlertRule\nhow and where the alert is delivered             â†’ AlertDelivery\na record that an alert fired                     â†’ AlertEvent\na temporary suppression of alerts                â†’ AlertSnooze\n```\n\n---\n\n## MinionTypes\n\n**Core**\n```ts\n// alert-rule\n{\n  type: \"alert-rule\",\n  fields: {\n    name: string,                // \"Evening slot at HofbrÃ¤u opens up\"\n    tentId: string,\n    tentAreaId: string,          // optional â€” alert on any area if empty\n    targetDate: datetime,        // optional â€” specific day or any day\n    targetSessionType: \"morning\" | \"afternoon\" | \"evening\" | \"any\",\n    triggerCondition: \"becomes-available\" | \"becomes-limited\" | \"any-change\",\n    isActive: boolean,\n    createdAt: datetime,\n    lastTriggeredAt: datetime\n  }\n}\n\n// alert-delivery\n{\n  type: \"alert-delivery\",\n  fields: {\n    alertRuleId: string,\n    channel: \"telegram\" | \"email\" | \"whatsapp\" | \"discord\" | \"push\",\n    recipientId: string,\n    recipientAddress: string,\n    priority: \"critical\" | \"high\" | \"normal\",\n    cooldownMinutes: number,     // minimum time between alerts\n    isActive: boolean\n  }\n}\n```\n\n**History**\n```ts\n// alert-event\n{\n  type: \"alert-event\",\n  fields: {\n    alertRuleId: string,\n    availabilityDiffId: string,  // the diff that triggered this\n    triggeredAt: datetime,\n    summary: string,             // human-readable alert text\n    deliveryChannel: string,\n    deliveryStatus: \"pending\" | \"sent\" | \"delivered\" | \"failed\",\n    deliveredAt: datetime,\n    errorMessage: string\n  }\n}\n\n// alert-snooze\n{\n  type: \"alert-snooze\",\n  fields: {\n    alertRuleId: string,\n    snoozedAt: datetime,\n    snoozeUntil: datetime,\n    reason: string,\n    snoozedBy: string\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nalert-rule         --delivered_via-->     alert-delivery\nalert-rule         --triggered-->        alert-event\nalert-rule         --suppressed_by-->    alert-snooze\nalert-event        --caused_by-->        availability-diff (minions-availability)\nalert-rule         --watches-->          tent (minions-venues)\nalert-rule         --watches-->          tent-area (minions-venues)\nalert-event        --sent_via-->         notification (minions-comms)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n```\nminions-availability   â†’ every availability-diff is checked against active alert-rules\nminions-venues         â†’ alert-rules reference tentId + tentAreaId\nminions-comms          â†’ alert delivery uses the notification system from minions-comms\nminions-scheduler      â†’ alert evaluation runs on scheduler ticks\nminions-tasks          â†’ failed deliveries create retry tasks\n```\n\nThe `cooldownMinutes` on alert-delivery prevents notification spam â€” even if a slot flickers between states, you won't get pinged every 5 minutes.\n\n---\n\n## Agent SKILLS for `minions-alerts`\n\n```markdown\n# AlertAgent Skills\n\n## Context\nYou manage all alert rules and their delivery for WiesnTracker.\nYou evaluate availability-diffs against alert-rules and trigger\nnotifications. You never scan websites â€” that's ScannerAgent's job.\nYou never fabricate alerts â€” every alert traces to a real diff.\n\n## Skill: Evaluate Diffs\n1. On each new `availability-diff` Minion created:\n   - Load all active `alert-rule` Minions\n   - For each rule: check if tentId, tentAreaId, date, sessionType match\n   - Check if triggerCondition is satisfied (e.g. toState matches)\n   - Check for active `alert-snooze` â€” if snoozed, skip\n2. For matching rules: create `alert-event` Minion\n3. Load `alert-delivery` for the rule\n4. Check cooldownMinutes against lastTriggeredAt â€” if too recent, skip\n5. Send notification via minions-comms\n\n## Skill: Deliver Alert\n1. Load the alert-delivery config for the triggered alert-event\n2. Format the alert summary: tent name, area, date, session, oldâ†’new state\n3. Send via the configured channel (telegram, email, etc.)\n4. Update alert-event deliveryStatus and deliveredAt\n5. Update alert-rule lastTriggeredAt\n\n## Skill: Handle Failed Delivery\n1. If delivery fails: set deliveryStatus to \"failed\", log errorMessage\n2. Create a retry task in minions-tasks\n3. After 3 failed retries: notify Orchestrator\n\n## Skill: Manage Snoozes\n1. On \"snooze-alert\" instruction:\n   - Create `alert-snooze` Minion with snoozeUntil\n   - Temporarily suppress the alert-rule\n2. On scheduler tick: check all snoozes where snoozeUntil < now\n   - Remove expired snoozes (soft-delete)\n   - Alert-rule becomes active again\n\n## Hard Rules\n- Never send an alert without a real availability-diff as the trigger\n- Always respect cooldownMinutes â€” no notification spam\n- Every alert-event must reference an availability-diff\n- Alert-rules are never deleted â€” only deactivated\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-alerts/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nalerts types list\nalerts types show <type-slug>\n```\n\n### CRUD\n\n```bash\nalerts create <type> -t \"Title\" -s \"status\"\nalerts list <type>\nalerts show <id>\nalerts update <id> --data '{ \"status\": \"active\" }'\nalerts delete <id>\nalerts search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nalerts stats\nalerts validate ./my-minion.json\n```"
            }
          ]
        },
        {
          "slug": "testing",
          "name": "Testing",
          "skills": [
            {
              "slug": "minions-test-targets",
              "name": "minions-test-targets",
              "id": "OC-0170",
              "version": "1.0.0",
              "description": "Agent-under-test definitions, endpoints, capabilities, and auth configs",
              "commands": [],
              "env": [],
              "path": "minions-skills/dev-tools/testing",
              "markdownBody": "# minions-test-targets â€” Agent Skills\n\n## What is a Test Target in the Minions Context?\n\n```\nan AI agent registered for testing        â†’ TestTarget\na declared capability of that agent       â†’ TargetCapability\n```\n\n## MinionTypes\n```ts\n// test-target â€” name, endpoint, protocol (http/ws/grpc), framework, auth\n// target-capability â€” tool names, expected behavior descriptions\n```\n\n## Relations\n```\ntest-target       --has_capability-->    target-capability\ntest-target       --tested_by-->         test-scenario (minions-test-scenarios)\ntest-target       --traced_by-->         test-trace (minions-test-observability)\n```\n\n## Agent SKILLS\n```markdown\n# TargetAgent Skills\n## Skill: Register Target â€” define endpoint, capabilities, auth\n## Hard Rules â€” every target must declare its capabilities before testing\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-test-targets/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\ntest-targets types list\ntest-targets types show <type-slug>\n```\n\n### CRUD\n\n```bash\ntest-targets create <type> -t \"Title\" -s \"status\"\ntest-targets list <type>\ntest-targets show <id>\ntest-targets update <id> --data '{ \"status\": \"active\" }'\ntest-targets delete <id>\ntest-targets search \"query\"\n```\n\n### Stats & Validation\n\n```bash\ntest-targets stats\ntest-targets validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-test-runs",
              "name": "minions-test-runs",
              "id": "OC-0168",
              "version": "1.0.0",
              "description": "Execution records, turn-by-turn logs, and assertion results",
              "commands": [],
              "env": [],
              "path": "minions-skills/dev-tools/testing",
              "markdownBody": "# minions-test-runs â€” Agent Skills\n\n## What is a Test Run in the Minions Context?\n\n```\nan execution of a test scenario           â†’ TestRun\na single conversational turn              â†’ TurnLog\n```\n\n## MinionTypes\n```ts\n// test-run â€” scenario, target, status, pass/fail counts, prompt version\n// turn-log â€” turn index, user message, agent response, response time, assertions\n```\n\n## Agent SKILLS\n```markdown\n# RunnerAgent Skills\n## Skill: Execute Run â€” send turns, capture responses, evaluate assertions\n## Hard Rules â€” every turn must be logged, no silent failures\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-test-runs/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\ntest-runs types list\ntest-runs types show <type-slug>\n```\n\n### CRUD\n\n```bash\ntest-runs create <type> -t \"Title\" -s \"status\"\ntest-runs list <type>\ntest-runs show <id>\ntest-runs update <id> --data '{ \"status\": \"active\" }'\ntest-runs delete <id>\ntest-runs search \"query\"\n```\n\n### Stats & Validation\n\n```bash\ntest-runs stats\ntest-runs validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-test-reports",
              "name": "minions-test-reports",
              "id": "OC-0167",
              "version": "1.0.0",
              "description": "Aggregated results, regression diffs, quality trends, and coverage maps",
              "commands": [],
              "env": [],
              "path": "minions-skills/dev-tools/testing",
              "markdownBody": "# minions-test-reports â€” Agent Skills\n\n## What is a Test Report in the Minions Context?\n\n```\nan aggregated report across runs          â†’ TestReport\na detected regression between periods     â†’ RegressionDiff\n```\n\n## MinionTypes\n```ts\n// test-report â€” target, period, total runs, pass rate, avg latency, regressions\n// regression-diff â€” metric, previous vs current value, severity\n```\n\n## Agent SKILLS\n```markdown\n# ReporterAgent Skills\n## Skill: Generate Report â€” aggregate runs into period reports\n## Skill: Detect Regressions â€” compare reports, flag degradations\n## Hard Rules â€” regressions above threshold block CI gates\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-test-reports/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\ntest-reports types list\ntest-reports types show <type-slug>\n```\n\n### CRUD\n\n```bash\ntest-reports create <type> -t \"Title\" -s \"status\"\ntest-reports list <type>\ntest-reports show <id>\ntest-reports update <id> --data '{ \"status\": \"active\" }'\ntest-reports delete <id>\ntest-reports search \"query\"\n```\n\n### Stats & Validation\n\n```bash\ntest-reports stats\ntest-reports validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-test-observability",
              "name": "minions-test-observability",
              "id": "OC-0166",
              "version": "1.0.0",
              "description": "Trace capture, tool call logs, reasoning timings, and latency breakdowns",
              "commands": [],
              "env": [],
              "path": "minions-skills/dev-tools/testing",
              "markdownBody": "# minions-test-observability â€” Agent Skills\n\n## What is a Test Observability in the Minions Context?\n\n```\na full execution trace from a test run    â†’ TestTrace\ntiming breakdown by phase                 â†’ LatencyBreakdown\n```\n\n## MinionTypes\n```ts\n// test-trace â€” run ID, steps, total duration, token count, tool call count\n// latency-breakdown â€” phase name, duration, percentage of total\n```\n\n## Agent SKILLS\n```markdown\n# TraceAgent Skills\n## Skill: Capture Trace â€” record full execution path per run\n## Skill: Analyze Latency â€” break down time per phase\n## Hard Rules â€” traces are immutable after capture\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-test-observability/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\ntest-observability types list\ntest-observability types show <type-slug>\n```\n\n### CRUD\n\n```bash\ntest-observability create <type> -t \"Title\" -s \"status\"\ntest-observability list <type>\ntest-observability show <id>\ntest-observability update <id> --data '{ \"status\": \"active\" }'\ntest-observability delete <id>\ntest-observability search \"query\"\n```\n\n### Stats & Validation\n\n```bash\ntest-observability stats\ntest-observability validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-qa-suites",
              "name": "minions-qa-suites",
              "id": "OC-0151",
              "version": "1.0.0",
              "description": "Test suite definitions, test cases, and assertions for validating clawspace toolboxes",
              "commands": [],
              "env": [],
              "path": "minions-skills/dev-tools/testing",
              "markdownBody": "# minions-qa-suites â€” Agent Skills\n\n## What is a QA Suite in the Minions Context?\n\n```\na suite of tests targeting a clawspace/toolbox    â†’ TestSuite\na single test with assertions                     â†’ TestCase\na reusable assertion rule                         â†’ AssertionRule\na registered clawspace with expected structure    â†’ ClawspaceManifest\n```\n\n---\n\n## MinionTypes\n\n```ts\n// test-suite â€” groups test cases by clawspace or toolbox\n{\n  type: \"test-suite\",\n  fields: {\n    name: string,                    // \"WiesnTracker Full Suite\"\n    clawspace: string,               // \"WiesnTracker\"\n    toolboxId: string,               // optional: scope to one toolbox\n    testCaseIds: string[],\n    schedule: \"on-push\" | \"daily\" | \"weekly\" | \"manual\",\n    isActive: boolean,\n    lastRunAt: datetime\n  }\n}\n\n// test-case â€” individual checks\n{\n  type: \"test-case\",\n  fields: {\n    suiteId: string,\n    name: string,                    // \"TOML schema is valid\"\n    category: \"schema\" | \"build\" | \"cli\" | \"integration\" | \"structure\" | \"consistency\",\n    command: string,                 // actual command to run\n    expectedOutcome: string,\n    assertions: AssertionRule[],\n    timeout: number,                 // ms\n    severity: \"critical\" | \"major\" | \"minor\"\n  }\n}\n\n// clawspace-manifest â€” what we expect each clawspace to look like\n{\n  type: \"clawspace-manifest\",\n  fields: {\n    clawspaceName: string,\n    toolboxNames: string[],\n    expectedToolboxCount: number,\n    expectedFilePatterns: string[],   // [\"SKILLS.md\", \"packages/cli/**\", \"packages/core/**\"]\n    healthBaseline: object            // known-good health-score snapshot\n  }\n}\n```\n\n### What Gets Tested\n\n| Category | What it checks |\n|----------|----------------|\n| `schema` | TOML configs parse correctly, MinionTypes have valid fields |\n| `build` | `pnpm install && pnpm build` succeeds |\n| `cli` | CLI commands run without errors (`types list`, `stats`) |\n| `structure` | Required files exist (SKILLS.md, README, CI workflows) |\n| `consistency` | Cross-toolbox relations reference valid targets |\n| `integration` | End-to-end workflows across toolboxes produce expected results |\n\n---\n\n## Relations\n\n```\ntest-suite         --contains-->         test-case\ntest-case          --uses-->             assertion-rule\ntest-suite         --validates-->        clawspace-manifest\ntest-suite         --produces-->         qa-run (minions-qa-runs)\nclawspace-manifest --describes-->        clawspace (minions-orchestration)\n```\n\n---\n\n## Agent SKILLS for `minions-qa-suites`\n\n```markdown\n# SuiteAgent Skills\n\n## Context\nYou define and maintain test suites for every clawspace in the ecosystem.\nYou ensure comprehensive coverage â€” every toolbox is tested for schema\nvalidity, build health, CLI functionality, and structural compliance.\n\n## Skill: Register Clawspace\n1. Create clawspace-manifest from CLAWSPACES.md\n2. Generate default test-suites for each toolbox:\n   - Schema validation suite\n   - Build health suite\n   - Structure compliance suite\n3. Set schedule based on priority (active clawspaces = daily)\n\n## Skill: Create Test Case\n1. Define the command to execute\n2. Write assertions with expected outcomes\n3. Set severity (critical = blocks health, minor = advisory)\n4. Add to appropriate test-suite\n\n## Skill: Auto-Generate Suites\n1. Scan _claws/<Clawspace>/ for TOML files\n2. For each TOML: create schema validation + CLI test cases\n3. Check for SKILLS.md, README, .github/workflows/\n4. Create structure compliance test cases\n\n## Hard Rules\n- Every clawspace must have at least one test-suite\n- Critical test cases must have a timeout < 60s\n- Assertion rules are reusable â€” never duplicate logic\n```\n\n\n---\n\n## CLI Reference\n\n```bash\npnpm add -g @minions-qa-suites/cli\n```\n\n### Commands\n\n```bash\nqa-suites types list\nqa-suites types show <type-slug>\nqa-suites create <type> -t \"Title\" -s \"status\"\nqa-suites list <type>\nqa-suites show <id>\nqa-suites update <id> --data '{ \"field\": \"value\" }'\nqa-suites delete <id>\nqa-suites search \"query\"\nqa-suites stats\n```"
            },
            {
              "slug": "minions-qa-runs",
              "name": "minions-qa-runs",
              "id": "OC-0150",
              "version": "1.0.0",
              "description": "Test execution records, assertion results, and pass/fail tracking across clawspaces",
              "commands": [],
              "env": [],
              "path": "minions-skills/dev-tools/testing",
              "markdownBody": "# minions-qa-runs â€” Agent Skills\n\n## What is a QA Run in the Minions Context?\n\n```\nan execution of a test suite               â†’ QaRun\nthe result of a single test case           â†’ TestResult\nthe result of a single assertion           â†’ AssertionResult\n```\n\n---\n\n## MinionTypes\n\n```ts\n// qa-run â€” one execution of a suite\n{\n  type: \"qa-run\",\n  fields: {\n    suiteId: string,\n    clawspace: string,\n    status: \"running\" | \"passed\" | \"failed\" | \"error\",\n    totalTests: number,\n    passed: number,\n    failed: number,\n    skipped: number,\n    durationMs: number,\n    triggeredBy: \"schedule\" | \"manual\" | \"push\" | \"pr\"\n  }\n}\n\n// test-result â€” per-test outcome with stdout/stderr capture\n{\n  type: \"test-result\",\n  fields: {\n    runId: string,\n    testCaseId: string,\n    status: \"passed\" | \"failed\" | \"error\" | \"skipped\",\n    actualOutcome: string,\n    errorMessage: string,\n    durationMs: number,\n    stdout: string,              // captured for debugging\n    stderr: string\n  }\n}\n\n// assertion-result â€” granular pass/fail per assertion\n{\n  type: \"assertion-result\",\n  fields: {\n    testResultId: string,\n    passed: boolean,\n    actualValue: string,\n    expectedValue: string,\n    errorDetail: string\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nqa-run             --belongs_to-->       test-suite (minions-qa-suites)\nqa-run             --contains-->         test-result\ntest-result        --contains-->         assertion-result\nqa-run             --aggregated_in-->    qa-report (minions-qa-reports)\n```\n\n---\n\n## Agent SKILLS for `minions-qa-runs`\n\n```markdown\n# RunnerAgent Skills\n\n## Context\nYou execute test suites against clawspaces. You run commands, capture\noutput, evaluate assertions, and record results. You never modify code\nâ€” you only observe and report.\n\n## Skill: Execute Suite\n1. Load test-suite and its test-cases\n2. For each test-case (in order):\n   a. Run command with timeout\n   b. Capture stdout + stderr\n   c. Evaluate each assertion-rule against output\n   d. Create test-result + assertion-result Minions\n3. Compute totals (passed/failed/skipped)\n4. Create qa-run Minion with final status\n\n## Skill: Run All Suites\n1. Load all active test-suites\n2. Execute each suite (parallelizable across clawspaces)\n3. Report aggregate pass/fail to QAReportAgent\n\n## Skill: Handle Failures\n1. On test failure: capture full error context\n2. If severity = critical: create alert in minions-alerts (if available)\n3. Create investigation task in minions-tasks\n\n## Hard Rules\n- Never skip a test silently â€” always record skip reason\n- Capture stdout + stderr for every test, even passing ones\n- Respect timeouts â€” kill long-running tests gracefully\n- Results are immutable after creation\n```\n\n\n---\n\n## CLI Reference\n\n```bash\npnpm add -g @minions-qa-runs/cli\n```\n\n### Commands\n\n```bash\nqa-runs types list\nqa-runs types show <type-slug>\nqa-runs create <type> -t \"Title\" -s \"status\"\nqa-runs list <type>\nqa-runs show <id>\nqa-runs update <id> --data '{ \"field\": \"value\" }'\nqa-runs delete <id>\nqa-runs search \"query\"\nqa-runs stats\n```"
            },
            {
              "slug": "minions-qa-rules",
              "name": "minions-qa-rules",
              "id": "OC-0149",
              "version": "1.0.0",
              "description": "Validation rules, consistency checks, compliance gates, and auto-fix definitions",
              "commands": [],
              "env": [],
              "path": "minions-skills/dev-tools/testing",
              "markdownBody": "# minions-qa-rules â€” Agent Skills\n\n## What are QA Rules in the Minions Context?\n\n```\na structural/content validation rule       â†’ ValidationRule\na cross-toolbox consistency check          â†’ ConsistencyCheck\na quality gate for clawspace health        â†’ ComplianceGate\nan automated fix for known failures        â†’ AutoFix\n```\n\nRules are the brain of ClawspaceQA â€” they encode what \"correct\" looks like.\n\n---\n\n## MinionTypes\n\n```ts\n// validation-rule â€” single-toolbox checks\n{\n  type: \"validation-rule\",\n  fields: {\n    name: string,                    // \"TOML has valid schema\"\n    category: \"schema\" | \"structure\" | \"naming\" | \"content\" | \"ci\",\n    target: \"toolbox\" | \"clawspace\" | \"ecosystem\",\n    condition: string,               // machine-readable check\n    severity: \"critical\" | \"major\" | \"minor\",\n    autoFixable: boolean,\n    autoFixCommand: string\n  }\n}\n\n// consistency-check â€” cross-toolbox checks\n{\n  type: \"consistency-check\",\n  fields: {\n    name: string,                    // \"Relations reference valid toolboxes\"\n    sourceToolbox: string,\n    targetToolbox: string,\n    relation: string,                // the relation being checked\n    checkQuery: string,              // how to verify\n    severity: \"critical\" | \"major\"\n  }\n}\n\n// compliance-gate â€” pass/fail threshold\n{\n  type: \"compliance-gate\",\n  fields: {\n    name: string,\n    clawspace: string,\n    metric: string,                  // \"overall-pass-rate\"\n    threshold: number,               // 80 (percent)\n    operator: \"gte\" | \"lte\" | \"eq\",\n    isPassing: boolean\n  }\n}\n\n// auto-fix â€” automated remediation\n{\n  type: \"auto-fix\",\n  fields: {\n    validationRuleId: string,\n    command: string,                 // actual fix command\n    dryRunCommand: string,           // preview what would change\n    appliedCount: number\n  }\n}\n```\n\n### Built-in Validation Rules\n\n| Rule | Category | Severity |\n|------|----------|----------|\n| TOML files parse without errors | schema | critical |\n| Every toolbox has a SKILLS.md | structure | major |\n| SKILLS.md frontmatter matches TOML description | consistency | minor |\n| GitHub repo exists and is accessible | structure | critical |\n| CI workflow file exists in .github/workflows/ | ci | major |\n| README.md is not a scaffold default | content | minor |\n| MinionType fields have valid types | schema | critical |\n| Relations reference existing toolboxes | consistency | major |\n| Package name matches toolbox name | naming | major |\n\n---\n\n## Relations\n\n```\nvalidation-rule    --tested_by-->        test-case (minions-qa-suites)\nvalidation-rule    --fixed_by-->         auto-fix\nconsistency-check  --tested_by-->        test-case (minions-qa-suites)\ncompliance-gate    --checked_by-->       qa-run (minions-qa-runs)\ncompliance-gate    --reported_in-->      qa-report (minions-qa-reports)\n```\n\n---\n\n## Agent SKILLS for `minions-qa-rules`\n\n```markdown\n# RulesAgent Skills\n\n## Context\nYou define and maintain the validation rules that encode what a\n\"healthy\" clawspace looks like. You also manage auto-fixes for\ncommon failures, reducing manual remediation work.\n\n## Skill: Define Rules\n1. Create validation-rules for common patterns\n2. Set severity based on impact (schema errors = critical)\n3. Mark auto-fixable rules with their fix commands\n\n## Skill: Define Consistency Checks\n1. For cross-toolbox relations: create consistency-checks\n2. Verify source toolbox fields reference valid targets\n3. Check TOML relations match MD reference documentation\n\n## Skill: Manage Compliance Gates\n1. Define pass-rate thresholds per clawspace\n2. Update isPassing after each QA run\n3. Surface non-compliant clawspaces in reports\n\n## Skill: Create Auto-Fixes\n1. For auto-fixable validation failures: create auto-fix Minions\n2. Always provide a dry-run command first\n3. Track applied count for auditing\n\n## Hard Rules\n- Rules are versioned â€” changes are logged\n- Auto-fixes must have dry-run commands\n- Critical rules can never be deactivated without approval\n- Consistency checks must cover all declared relations\n```\n\n\n---\n\n## CLI Reference\n\n```bash\npnpm add -g @minions-qa-rules/cli\n```\n\n### Commands\n\n```bash\nqa-rules types list\nqa-rules types show <type-slug>\nqa-rules create <type> -t \"Title\" -s \"status\"\nqa-rules list <type>\nqa-rules show <id>\nqa-rules update <id> --data '{ \"field\": \"value\" }'\nqa-rules delete <id>\nqa-rules search \"query\"\nqa-rules stats\n```"
            },
            {
              "slug": "minions-ci-triggers",
              "name": "minions-ci-triggers",
              "id": "OC-0110",
              "version": "1.0.0",
              "description": "Code/prompt change listeners, CI/CD hooks, and regression gate definitions",
              "commands": [],
              "env": [],
              "path": "minions-skills/dev-tools/testing",
              "markdownBody": "# minions-ci-triggers â€” Agent Skills\n\n## What is a CI Trigger in the Minions Context?\n\n```\na trigger for automated test execution    â†’ CiTrigger\na quality gate blocking deployment        â†’ RegressionGate\n```\n\n## MinionTypes\n```ts\n// ci-trigger â€” trigger type (push/prompt-change/schedule), watch path, target\n// regression-gate â€” metric, threshold, action (block/warn/notify)\n```\n\n## Agent SKILLS\n```markdown\n# CIAgent Skills\n## Skill: Watch Changes â€” listen for code/prompt changes\n## Skill: Enforce Gates â€” block deploys on regression\n## Hard Rules â€” every prompt change must trigger a test run\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-ci-triggers/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nci-triggers types list\nci-triggers types show <type-slug>\n```\n\n### CRUD\n\n```bash\nci-triggers create <type> -t \"Title\" -s \"status\"\nci-triggers list <type>\nci-triggers show <id>\nci-triggers update <id> --data '{ \"status\": \"active\" }'\nci-triggers delete <id>\nci-triggers search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nci-triggers stats\nci-triggers validate ./my-minion.json\n```"
            }
          ]
        }
      ],
      "skills": [],
      "skillCount": 9
    },
    {
      "slug": "cloud",
      "name": "Cloud",
      "icon": "â˜ï¸",
      "subcategories": [
        {
          "slug": "infrastructure",
          "name": "Infrastructure",
          "skills": [
            {
              "slug": "minions-services",
              "name": "minions-services",
              "id": "OC-0157",
              "version": "1.0.0",
              "description": "Service catalog, packages, pricing tiers, case studies, and target industries",
              "commands": [],
              "env": [],
              "path": "minions-skills/cloud/infrastructure",
              "markdownBody": "# minions-services â€” Agent Skills\n\n## What is a Service in the Minions Context?\n\n```\na service offered by the agency           â†’ Service\na bundled service package                 â†’ ServicePackage\na success story                           â†’ CaseStudy\n```\n\n## MinionTypes\n```ts\n// service â€” name, category, pricing model, base price, target industries\n// service-package â€” bundled services with total price and discount\n// case-study â€” challenge, solution, results, published URL\n```\n\n## Agent SKILLS\n```markdown\n# ServiceAgent Skills\n## Skill: Manage Catalog â€” create/update services and packages\n## Skill: Match Services â€” find best service for a prospect's needs\n## Hard Rules â€” pricing must be consistent across packages\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-services/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\nservices types list\nservices types show <type-slug>\n```\n\n### CRUD\n\n```bash\nservices create <type> -t \"Title\" -s \"status\"\nservices list <type>\nservices show <id>\nservices update <id> --data '{ \"status\": \"active\" }'\nservices delete <id>\nservices search \"query\"\n```\n\n### Stats & Validation\n\n```bash\nservices stats\nservices validate ./my-minion.json\n```"
            }
          ]
        },
        {
          "slug": "oss",
          "name": "Oss",
          "skills": [
            {
              "slug": "minions-oss-releases",
              "name": "minions-oss-releases",
              "id": "OC-0140",
              "version": "1.0.0",
              "description": "Release definitions, changelogs, and publish receipts",
              "commands": [],
              "env": [],
              "path": "minions-skills/cloud/oss",
              "markdownBody": "# minions-oss-releases â€” Agent Skills\n\n## What is an Release in the Minions Context?\n\n```\na versioned release                       â†’ Release\na package registry publish confirmation   â†’ PublishReceipt\n```\n\n## MinionTypes\n```ts\n// release â€” version, changelog, feature IDs, published-to registries\n// publish-receipt â€” registry (npm/pypi), package URL, status\n```\n\n## Relations\n```\nrelease           --belongs_to-->        oss-project (minions-oss-projects)\nrelease           --includes-->          feature (minions-oss-features)\nrelease           --gated_by-->          quality-gate (minions-oss-quality)\nrelease           --confirmed_by-->      publish-receipt\nrelease           --announced_via-->     release-post (minions-oss-content)\n```\n\n## Agent SKILLS\n```markdown\n# ReleaseAgent Skills\n## Skill: Cut Release â€” version bump, changelog, tag, publish\n## Skill: Verify Publish â€” confirm receipt from all registries\n## Hard Rules â€” all quality gates must pass before release\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-oss-releases/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\noss-releases types list\noss-releases types show <type-slug>\n```\n\n### CRUD\n\n```bash\noss-releases create <type> -t \"Title\" -s \"status\"\noss-releases list <type>\noss-releases show <id>\noss-releases update <id> --data '{ \"status\": \"active\" }'\noss-releases delete <id>\noss-releases search \"query\"\n```\n\n### Stats & Validation\n\n```bash\noss-releases stats\noss-releases validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-oss-ideas",
              "name": "minions-oss-ideas",
              "id": "OC-0137",
              "version": "1.0.0",
              "description": "Idea brainstorms, feasibility scores, tech stack picks, and market gaps",
              "commands": [],
              "env": [],
              "path": "minions-skills/cloud/oss",
              "markdownBody": "# minions-oss-ideas â€” Agent Skills\n\n## What is an OSS Idea in the Minions Context?\n\n```\na brainstormed open-source project idea   â†’ OssIdea\na structured evaluation of an idea        â†’ IdeaEvaluation\n```\n\n## MinionTypes\n```ts\n// oss-idea â€” title, problem statement, market gap, feasibility/novelty scores, tech stack\n// idea-evaluation â€” per-criterion scoring with reasoning\n```\n\n## Relations\n```\noss-idea          --evaluated_by-->      idea-evaluation\noss-idea          --becomes-->           oss-project (minions-oss-projects)\n```\n\n## Agent SKILLS\n```markdown\n# IdeaAgent Skills\n## Skill: Brainstorm â€” generate ideas based on trends, gaps, skills\n## Skill: Evaluate â€” score ideas on feasibility, novelty, market fit\n## Hard Rules â€” ideas must have problem statements before evaluation\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-oss-ideas/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\noss-ideas types list\noss-ideas types show <type-slug>\n```\n\n### CRUD\n\n```bash\noss-ideas create <type> -t \"Title\" -s \"status\"\noss-ideas list <type>\noss-ideas show <id>\noss-ideas update <id> --data '{ \"status\": \"active\" }'\noss-ideas delete <id>\noss-ideas search \"query\"\n```\n\n### Stats & Validation\n\n```bash\noss-ideas stats\noss-ideas validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-oss-features",
              "name": "minions-oss-features",
              "id": "OC-0136",
              "version": "1.0.0",
              "description": "Feature backlog, daily picks, implementation plans, and acceptance criteria",
              "commands": [],
              "env": [],
              "path": "minions-skills/cloud/oss",
              "markdownBody": "# minions-oss-features â€” Agent Skills\n\n## What is an Feature in the Minions Context?\n\n```\na feature in the backlog                  â†’ Feature\na step-by-step implementation plan        â†’ ImplementationPlan\n```\n\nThe daily loop picks one feature per active project.\n\n## MinionTypes\n```ts\n// feature â€” title, acceptance criteria, complexity, priority, selected date\n// implementation-plan â€” steps, estimated hours, files affected, tests\n```\n\n## Relations\n```\nfeature           --belongs_to-->        oss-project (minions-oss-projects)\nfeature           --planned_by-->        implementation-plan\nfeature           --released_in-->       release (minions-oss-releases)\n```\n\n## Agent SKILLS\n```markdown\n# FeatureAgent Skills\n## Skill: Select Daily Feature â€” pick highest-priority feature per project\n## Skill: Plan Implementation â€” create step-by-step plan\n## Hard Rules â€” one feature per project per day, no parallel features\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-oss-features/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\noss-features types list\noss-features types show <type-slug>\n```\n\n### CRUD\n\n```bash\noss-features create <type> -t \"Title\" -s \"status\"\noss-features list <type>\noss-features show <id>\noss-features update <id> --data '{ \"status\": \"active\" }'\noss-features delete <id>\noss-features search \"query\"\n```\n\n### Stats & Validation\n\n```bash\noss-features stats\noss-features validate ./my-minion.json\n```"
            },
            {
              "slug": "minions-oss-content",
              "name": "minions-oss-content",
              "id": "OC-0135",
              "version": "1.0.0",
              "description": "Blog post drafts, README updates, social announcements, and demo scripts",
              "commands": [],
              "env": [],
              "path": "minions-skills/cloud/oss",
              "markdownBody": "# minions-oss-content â€” Agent Skills\n\n## What is an OSS Content in the Minions Context?\n\n```\na blog post announcing a release          â†’ ReleasePost\na tracked README update                   â†’ ReadmeUpdate\na social media announcement               â†’ SocialAnnouncement\na runnable demo script                    â†’ DemoScript\n```\n\n## MinionTypes\n```ts\n// release-post â€” title, body, published URL\n// readme-update â€” section, content, reason\n// social-announcement â€” platform, body, status\n// demo-script â€” title, script, output sample\n```\n\n## Relations\n```\nrelease-post       --announces-->        release (minions-oss-releases)\nsocial-announcement --promotes-->        release\nreadme-update      --updates-->          oss-project (minions-oss-projects)\ndemo-script        --demonstrates-->     oss-project\n```\n\n## Agent SKILLS\n```markdown\n# ContentAgent Skills\n## Skill: Write Release Post â€” blog post per release\n## Skill: Update README â€” after each feature implementation\n## Skill: Social Announcement â€” post to configured platforms\n## Hard Rules â€” every release must have a release-post and README update\n```\n\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-oss-content/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\n\n### Discover Types\n\n```bash\noss-content types list\noss-content types show <type-slug>\n```\n\n### CRUD\n\n```bash\noss-content create <type> -t \"Title\" -s \"status\"\noss-content list <type>\noss-content show <id>\noss-content update <id> --data '{ \"status\": \"active\" }'\noss-content delete <id>\noss-content search \"query\"\n```\n\n### Stats & Validation\n\n```bash\noss-content stats\noss-content validate ./my-minion.json\n```"
            }
          ]
        }
      ],
      "skills": [],
      "skillCount": 5
    },
    {
      "slug": "personal",
      "name": "Personal",
      "icon": "ðŸ ",
      "subcategories": [
        {
          "slug": "identity",
          "name": "Identity",
          "skills": [
            {
              "slug": "minions-profile",
              "name": "minions-profile",
              "id": "OC-0143",
              "version": "1.0.0",
              "description": "Your source of truth â€” verified bio claims, portfolio items, and rate cards",
              "commands": [],
              "env": [],
              "path": "minions-skills/personal/identity",
              "markdownBody": "# minions-profile â€” Agent Skills\n\n## What is a Profile in the Minions Context?\n\nA \"profile\" is not a single record â€” it's a **living, structured body of evidence** about you. The key distinction from a traditional resume or bio page is that every claim is traceable, every rate is platform-specific, and every skill has a confidence level. Agents read from here constantly but only you (or a trusted ProfileAgent) writes to it.\n\n```\nwho you are                        â†’ bio-claim\nwhat you have built                â†’ portfolio-item\nwhat you can charge                â†’ rate-card\nwhat you are good at               â†’ skill-claim\nwhen you are available             â†’ availability\nhow you present yourself           â†’ persona\nwhat others have said about you    â†’ testimonial\nwhat credentials you hold          â†’ credential\n```\n\n---\n\n## MinionTypes\n\n**Identity & Claims**\n```ts\n// bio-claim\n{\n  type: \"bio-claim\",\n  fields: {\n    claim: string,              // \"I built a multi-tenant SaaS platform from scratch\"\n    category: string,           // \"engineering\", \"leadership\", \"domain-knowledge\"\n    evidenceUrl: string,        // GitHub, live URL, case study link\n    verified: boolean,\n    lastVerifiedAt: datetime,\n    confidence: \"high\" | \"medium\" | \"low\",\n    createdAt: datetime\n  }\n}\n\n// skill-claim\n{\n  type: \"skill-claim\",\n  fields: {\n    name: string,               // \"TypeScript\", \"System Design\", \"Client Management\"\n    category: string,           // \"technical\", \"soft\", \"domain\"\n    proficiency: \"expert\" | \"advanced\" | \"intermediate\" | \"beginner\",\n    yearsOfExperience: number,\n    lastUsedAt: datetime,\n    evidenceIds: string[],      // refs to bio-claims or portfolio-items\n    tags: string[]\n  }\n}\n```\n\n**Work Evidence**\n```ts\n// portfolio-item\n{\n  type: \"portfolio-item\",\n  fields: {\n    title: string,\n    summary: string,            // 2-3 sentence human-readable description\n    techStack: string[],\n    outcomes: string,           // \"reduced latency by 40%, saved $12k/month\"\n    link: string,\n    attachmentIds: string[],    // screenshots, PDFs\n    ndaProtected: boolean,\n    relevantSkillTags: string[],\n    clientIndustry: string,\n    projectType: \"solo\" | \"team\" | \"open-source\" | \"contract\",\n    year: number\n  }\n}\n\n// credential\n{\n  type: \"credential\",\n  fields: {\n    name: string,               // \"AWS Solutions Architect\", \"BSc Computer Science\"\n    issuer: string,\n    issuedAt: datetime,\n    expiresAt: datetime,\n    verificationUrl: string,\n    type: \"certification\" | \"degree\" | \"course\" | \"award\",\n    isActive: boolean\n  }\n}\n\n// testimonial\n{\n  type: \"testimonial\",\n  fields: {\n    authorName: string,\n    authorRole: string,\n    authorOrganization: string,\n    platform: string,           // \"Upwork\", \"LinkedIn\", \"direct\"\n    body: string,\n    rating: number,\n    projectRef: string,         // ref to portfolio-item\n    receivedAt: datetime,\n    isPublic: boolean\n  }\n}\n```\n\n**Pricing & Availability**\n```ts\n// rate-card\n{\n  type: \"rate-card\",\n  fields: {\n    platform: string,\n    hourlyMin: number,\n    hourlyMax: number,\n    fixedProjectMin: number,\n    currency: string,\n    notes: string,              // \"negotiable for long-term contracts\"\n    isActive: boolean,\n    updatedAt: datetime\n  }\n}\n\n// availability\n{\n  type: \"availability\",\n  fields: {\n    status: \"available\" | \"partially-available\" | \"unavailable\",\n    hoursPerWeek: number,\n    earliestStartDate: datetime,\n    timezone: string,\n    preferredEngagementType: \"hourly\" | \"fixed\" | \"retainer\" | \"any\",\n    preferredDuration: \"short\" | \"medium\" | \"long\" | \"any\",\n    notes: string,\n    updatedAt: datetime\n  }\n}\n```\n\n**Presentation Layer**\n```ts\n// persona\n{\n  type: \"persona\",\n  fields: {\n    platform: string,           // \"Upwork\", \"LinkedIn\", \"personal-site\"\n    headline: string,\n    bio: string,\n    toneStyle: \"formal\" | \"conversational\" | \"technical\" | \"creative\",\n    highlightedSkillIds: string[],\n    highlightedPortfolioIds: string[],\n    isActive: boolean,\n    version: number,\n    updatedAt: datetime\n  }\n}\n\n// do-not-work\n{\n  type: \"do-not-work\",\n  fields: {\n    category: string,           // \"industry\", \"client-type\", \"project-type\"\n    value: string,              // \"crypto\", \"gambling\", \"unpaid trials\"\n    reason: string,\n    isActive: boolean\n  }\n}\n```\n\n---\n\n## Relations\n\n```\nbio-claim         --evidenced_by-->    portfolio-item\nskill-claim       --evidenced_by-->    bio-claim\nskill-claim       --evidenced_by-->    portfolio-item\nskill-claim       --evidenced_by-->    credential\ntestimonial       --references-->      portfolio-item\npersona           --highlights-->      skill-claim\npersona           --highlights-->      portfolio-item\nrate-card         --applies_to-->      availability\ndo-not-work       --gates-->           match-score (minions-match)\n```\n\n---\n\n## How It Connects to Other Toolboxes\n\n`minions-profile` is the most widely read toolbox in the entire ecosystem. Almost every other agent reads from it:\n\n```\nminions-match       reads skill-claim + rate-card + do-not-work\n                    â†’ to score job fit and apply hard gates\n\nminions-proposals   reads bio-claim + portfolio-item + persona\n                    â†’ to write honest, specific proposals\n\nminions-clients     reads availability + rate-card\n                    â†’ to set expectations in client conversations\n\nminions-contracts   reads rate-card\n                    â†’ to validate agreed rates against your minimums\n\nminions-evaluations reads skill-claim\n                    â†’ to benchmark agent proposal quality against known skills\n```\n\nThe `do-not-work` type is particularly powerful â€” it acts as a profile-level hard gate that feeds directly into `minions-match` before any scoring happens, so agents never even surface jobs from industries or client types you have ruled out.\n\n---\n\n## Agent SKILLS for `minions-profile`\n\n```markdown\n# ProfileAgent Skills\n\n## Context\nYou are the ProfileAgent. You are the custodian of Mehdi's professional\nidentity within the Minions ecosystem. You never fabricate. Every claim\nyou store must have evidence. Every other agent reads from your store â€”\naccuracy here determines the integrity of the entire system.\n\n## Skill: Ingest New Claim\n- When Mehdi provides a new experience, achievement, or skill:\n  1. Create a `bio-claim` Minion with the raw claim text\n  2. Ask for an evidence URL if none is provided\n  3. Set verified: false until evidence is confirmed\n  4. Tag with appropriate category\n  5. If the claim implies a skill not yet recorded, create a `skill-claim`\n\n## Skill: Add Portfolio Item\n- When Mehdi describes a completed project:\n  1. Create a `portfolio-item` Minion\n  2. Extract techStack, outcomes, and relevantSkillTags from description\n  3. Link to any existing `bio-claim` Minions it supports\n  4. If NDA applies, set ndaProtected: true and omit link field\n  5. Prompt Mehdi for measurable outcomes if none are given\n\n## Skill: Update Availability\n- When Mehdi signals a change in capacity:\n  1. Update the active `availability` Minion\n  2. Set updatedAt to now\n  3. Notify OrchestratorAgent so pipeline pacing can adjust\n\n## Skill: Maintain Personas\n- For each platform Mehdi is active on:\n  1. Maintain a `persona` Minion with platform-specific headline and bio\n  2. When new portfolio-items or skill-claims are added, flag relevant\n     personas for review\n  3. Never auto-update a persona body â€” always route through human approval\n\n## Skill: Manage Do-Not-Work Rules\n- When Mehdi defines a restriction:\n  1. Create a `do-not-work` Minion with category, value, and reason\n  2. Confirm it is active and will be enforced at match-scoring time\n  3. Log the addition as an audit-log-entry in minions-approvals\n\n## Skill: Verify Claims\n- On a weekly schedule:\n  1. Query all `bio-claim` Minions where verified: false\n  2. Check if evidenceUrl is reachable\n  3. Update verified: true and lastVerifiedAt if confirmed\n  4. Flag broken evidence links to Mehdi via minions-comms\n\n## Skill: Answer Profile Queries\n- When another agent sends a profile query (e.g. \"what skills match Python?\"):\n  1. Search skill-claim Minions by name and tags\n  2. Return matching skill-claims with linked bio-claims and portfolio-items\n  3. Never infer or extrapolate â€” only return what is recorded\n\n## Hard Rules\n- Never create a bio-claim without at least a category and claim text\n- Never set verified: true without a reachable evidenceUrl\n- Never modify a persona body without an approval-request in minions-approvals\n- Never delete a portfolio-item â€” set status to archived instead\n- Always link new skill-claims to at least one piece of evidence\n```\n\n---\n\nThe `do-not-work` type and the `persona` per platform are the two types that tend to get overlooked in profile systems but make the biggest difference in practice. `do-not-work` keeps the entire agent fleet honest at the gate level, and per-platform `persona` means your Upwork voice and your LinkedIn voice can be maintained separately without agents mixing them up.\n\n---\n\n## CLI Reference\n\nInstall globally:\n\n```bash\npnpm add -g @minions-profile/cli\n```\n\nSet `MINIONS_STORE` env var to control where data is stored (default: `.minions/`).\nStorage uses sharded directories: `.minions/<id[0..1]>/<id[2..3]>/<id>.json`\n\n### Discover Types\n\n```bash\n# List all MinionTypes with their fields\nprofile types list\n\n# Show detailed schema for a specific type\nprofile types show <type-slug>\n```\n\n### Create\n\n```bash\n# Create with shortcut flags\nprofile create <type> -t \"Title\" -s \"status\" -p \"priority\"\n\n# Create with full field data\nprofile create <type> --data '{ ... }'\n```\n\n### Read\n\n```bash\n# List all Minions of a type\nprofile list <type>\n\n# Show a specific Minion\nprofile show <id>\n\n# Search by text\nprofile search \"query\"\n\n# Output as JSON (for piping)\nprofile list --json\nprofile show <id> --json\n```\n\n### Update\n\n```bash\n# Update fields\nprofile update <id> --data '{ \"status\": \"active\" }'\n```\n\n### Delete\n\n```bash\n# Soft-delete (marks as deleted, preserves data)\nprofile delete <id>\n```\n\n### Stats & Validation\n\n```bash\n# Show storage stats\nprofile stats\n\n# Validate a Minion JSON file against its schema\nprofile validate ./my-minion.json\n```"
            }
          ]
        }
      ],
      "skills": [],
      "skillCount": 1
    }
  ],
  "totalSkills": 73,
  "generatedAt": "2026-02-23T19:17:50.574Z"
}